/**
 * Loader generated by glad 2.0.4 on Tue Nov 28 05:36:12 2023
 *
 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
 *
 * Generator: C/C++
 * Specification: gl
 * Extensions: 1
 *
 * APIs:
 *  - gl:core=4.6
 *
 * Options:
 *  - ALIAS = False
 *  - DEBUG = False
 *  - HEADER_ONLY = True
 *  - LOADER = True
 *  - MX = False
 *  - ON_DEMAND = False
 *
 * Commandline:
 *    --api='gl:core=4.6' --extensions='GL_EXT_texture_lod_bias' c --header-only --loader
 *
 * Online:
 *    http://glad.sh/#api=gl%3Acore%3D4.6&extensions=GL_EXT_texture_lod_bias&generator=c&options=HEADER_ONLY%2CLOADER
 *
 */

#ifndef GLAD_GL_H_
#define GLAD_GL_H_

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifdef __gl_h_
  #error OpenGL (gl.h) header already included (API: gl), remove previous include!
#endif
#define __gl_h_ 1
#ifdef __gl3_h_
  #error OpenGL (gl3.h) header already included (API: gl), remove previous include!
#endif
#define __gl3_h_ 1
#ifdef __glext_h_
  #error OpenGL (glext.h) header already included (API: gl), remove previous include!
#endif
#define __glext_h_ 1
#ifdef __gl3ext_h_
  #error OpenGL (gl3ext.h) header already included (API: gl), remove previous include!
#endif
#define __gl3ext_h_ 1
#ifdef __clang__
#pragma clang diagnostic pop
#endif

#define GLAD_GL
#define GLAD_OPTION_GL_HEADER_ONLY
#define GLAD_OPTION_GL_LOADER

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GLAD_PLATFORM_H_
#define GLAD_PLATFORM_H_

#ifndef GLAD_PLATFORM_WIN32
  #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__MINGW32__)
    #define GLAD_PLATFORM_WIN32 1
  #else
    #define GLAD_PLATFORM_WIN32 0
  #endif
#endif

#ifndef GLAD_PLATFORM_APPLE
  #ifdef __APPLE__
    #define GLAD_PLATFORM_APPLE 1
  #else
    #define GLAD_PLATFORM_APPLE 0
  #endif
#endif

#ifndef GLAD_PLATFORM_EMSCRIPTEN
  #ifdef __EMSCRIPTEN__
    #define GLAD_PLATFORM_EMSCRIPTEN 1
  #else
    #define GLAD_PLATFORM_EMSCRIPTEN 0
  #endif
#endif

#ifndef GLAD_PLATFORM_UWP
  #if defined(_MSC_VER) && !defined(GLAD_INTERNAL_HAVE_WINAPIFAMILY)
    #ifdef __has_include
      #if __has_include(<winapifamily.h>)
        #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
      #endif
    #elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
      #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
    #endif
  #endif

  #ifdef GLAD_INTERNAL_HAVE_WINAPIFAMILY
    #include <winapifamily.h>
    #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
      #define GLAD_PLATFORM_UWP 1
    #endif
  #endif

  #ifndef GLAD_PLATFORM_UWP
    #define GLAD_PLATFORM_UWP 0
  #endif
#endif

#ifdef __GNUC__
  #define GLAD_GNUC_EXTENSION __extension__
#else
  #define GLAD_GNUC_EXTENSION
#endif

#define GLAD_UNUSED(x) (void)(x)

#ifndef GLAD_API_CALL
  #if defined(GLAD_API_CALL_EXPORT)
    #if GLAD_PLATFORM_WIN32 || defined(__CYGWIN__)
      #if defined(GLAD_API_CALL_EXPORT_BUILD)
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllexport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllexport) extern
        #endif
      #else
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllimport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllimport) extern
        #endif
      #endif
    #elif defined(__GNUC__) && defined(GLAD_API_CALL_EXPORT_BUILD)
      #define GLAD_API_CALL __attribute__ ((visibility ("default"))) extern
    #else
      #define GLAD_API_CALL extern
    #endif
  #else
    #define GLAD_API_CALL extern
  #endif
#endif

#ifdef APIENTRY
  #define GLAD_API_PTR APIENTRY
#elif GLAD_PLATFORM_WIN32
  #define GLAD_API_PTR __stdcall
#else
  #define GLAD_API_PTR
#endif

#ifndef GLAPI
#define GLAPI GLAD_API_CALL
#endif

#ifndef GLAPIENTRY
#define GLAPIENTRY GLAD_API_PTR
#endif

#define GLAD_MAKE_VERSION(major, minor) (major * 10000 + minor)
#define GLAD_VERSION_MAJOR(version) (version / 10000)
#define GLAD_VERSION_MINOR(version) (version % 10000)

#define GLAD_GENERATOR_VERSION "2.0.4"

typedef void (*GLADapiproc)(void);

typedef GLADapiproc (*GLADloadfunc)(const char *name);
typedef GLADapiproc (*GLADuserptrloadfunc)(void *userptr, const char *name);

typedef void (*GLADprecallback)(const char *name, GLADapiproc apiproc, int len_args, ...);
typedef void (*GLADpostcallback)(void *ret, const char *name, GLADapiproc apiproc, int len_args, ...);

#endif /* GLAD_PLATFORM_H_ */

#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS 0x92D9
#define GL_ACTIVE_ATTRIBUTES 0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_PROGRAM 0x8259
#define GL_ACTIVE_RESOURCES 0x92F5
#define GL_ACTIVE_SUBROUTINES 0x8DE5
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH 0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORMS 0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_ACTIVE_TEXTURE 0x84E0
#define GL_ACTIVE_UNIFORMS 0x8B86
#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
#define GL_ACTIVE_VARIABLES 0x9305
#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
#define GL_ALL_BARRIER_BITS 0xFFFFFFFF
#define GL_ALL_SHADER_BITS 0xFFFFFFFF
#define GL_ALPHA 0x1906
#define GL_ALREADY_SIGNALED 0x911A
#define GL_ALWAYS 0x0207
#define GL_AND 0x1501
#define GL_AND_INVERTED 0x1504
#define GL_AND_REVERSE 0x1502
#define GL_ANY_SAMPLES_PASSED 0x8C2F
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_ARRAY_BUFFER 0x8892
#define GL_ARRAY_BUFFER_BINDING 0x8894
#define GL_ARRAY_SIZE 0x92FB
#define GL_ARRAY_STRIDE 0x92FE
#define GL_ATOMIC_COUNTER_BARRIER_BIT 0x00001000
#define GL_ATOMIC_COUNTER_BUFFER 0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS 0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES 0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_BINDING 0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE 0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_INDEX 0x9301
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER 0x92CB
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER 0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER 0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER 0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_SIZE 0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_START 0x92C2
#define GL_ATTACHED_SHADERS 0x8B85
#define GL_AUTO_GENERATE_MIPMAP 0x8295
#define GL_BACK 0x0405
#define GL_BACK_LEFT 0x0402
#define GL_BACK_RIGHT 0x0403
#define GL_BGR 0x80E0
#define GL_BGRA 0x80E1
#define GL_BGRA_INTEGER 0x8D9B
#define GL_BGR_INTEGER 0x8D9A
#define GL_BLEND 0x0BE2
#define GL_BLEND_COLOR 0x8005
#define GL_BLEND_DST 0x0BE0
#define GL_BLEND_DST_ALPHA 0x80CA
#define GL_BLEND_DST_RGB 0x80C8
#define GL_BLEND_EQUATION 0x8009
#define GL_BLEND_EQUATION_ALPHA 0x883D
#define GL_BLEND_EQUATION_RGB 0x8009
#define GL_BLEND_SRC 0x0BE1
#define GL_BLEND_SRC_ALPHA 0x80CB
#define GL_BLEND_SRC_RGB 0x80C9
#define GL_BLOCK_INDEX 0x92FD
#define GL_BLUE 0x1905
#define GL_BLUE_INTEGER 0x8D96
#define GL_BOOL 0x8B56
#define GL_BOOL_VEC2 0x8B57
#define GL_BOOL_VEC3 0x8B58
#define GL_BOOL_VEC4 0x8B59
#define GL_BUFFER 0x82E0
#define GL_BUFFER_ACCESS 0x88BB
#define GL_BUFFER_ACCESS_FLAGS 0x911F
#define GL_BUFFER_BINDING 0x9302
#define GL_BUFFER_DATA_SIZE 0x9303
#define GL_BUFFER_IMMUTABLE_STORAGE 0x821F
#define GL_BUFFER_MAPPED 0x88BC
#define GL_BUFFER_MAP_LENGTH 0x9120
#define GL_BUFFER_MAP_OFFSET 0x9121
#define GL_BUFFER_MAP_POINTER 0x88BD
#define GL_BUFFER_SIZE 0x8764
#define GL_BUFFER_STORAGE_FLAGS 0x8220
#define GL_BUFFER_UPDATE_BARRIER_BIT 0x00000200
#define GL_BUFFER_USAGE 0x8765
#define GL_BUFFER_VARIABLE 0x92E5
#define GL_BYTE 0x1400
#define GL_CAVEAT_SUPPORT 0x82B8
#define GL_CCW 0x0901
#define GL_CLAMP_READ_COLOR 0x891C
#define GL_CLAMP_TO_BORDER 0x812D
#define GL_CLAMP_TO_EDGE 0x812F
#define GL_CLEAR 0x1500
#define GL_CLEAR_BUFFER 0x82B4
#define GL_CLEAR_TEXTURE 0x9365
#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT 0x00004000
#define GL_CLIENT_STORAGE_BIT 0x0200
#define GL_CLIPPING_INPUT_PRIMITIVES 0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES 0x82F7
#define GL_CLIP_DEPTH_MODE 0x935D
#define GL_CLIP_DISTANCE0 0x3000
#define GL_CLIP_DISTANCE1 0x3001
#define GL_CLIP_DISTANCE2 0x3002
#define GL_CLIP_DISTANCE3 0x3003
#define GL_CLIP_DISTANCE4 0x3004
#define GL_CLIP_DISTANCE5 0x3005
#define GL_CLIP_DISTANCE6 0x3006
#define GL_CLIP_DISTANCE7 0x3007
#define GL_CLIP_ORIGIN 0x935C
#define GL_COLOR 0x1800
#define GL_COLOR_ATTACHMENT0 0x8CE0
#define GL_COLOR_ATTACHMENT1 0x8CE1
#define GL_COLOR_ATTACHMENT10 0x8CEA
#define GL_COLOR_ATTACHMENT11 0x8CEB
#define GL_COLOR_ATTACHMENT12 0x8CEC
#define GL_COLOR_ATTACHMENT13 0x8CED
#define GL_COLOR_ATTACHMENT14 0x8CEE
#define GL_COLOR_ATTACHMENT15 0x8CEF
#define GL_COLOR_ATTACHMENT16 0x8CF0
#define GL_COLOR_ATTACHMENT17 0x8CF1
#define GL_COLOR_ATTACHMENT18 0x8CF2
#define GL_COLOR_ATTACHMENT19 0x8CF3
#define GL_COLOR_ATTACHMENT2 0x8CE2
#define GL_COLOR_ATTACHMENT20 0x8CF4
#define GL_COLOR_ATTACHMENT21 0x8CF5
#define GL_COLOR_ATTACHMENT22 0x8CF6
#define GL_COLOR_ATTACHMENT23 0x8CF7
#define GL_COLOR_ATTACHMENT24 0x8CF8
#define GL_COLOR_ATTACHMENT25 0x8CF9
#define GL_COLOR_ATTACHMENT26 0x8CFA
#define GL_COLOR_ATTACHMENT27 0x8CFB
#define GL_COLOR_ATTACHMENT28 0x8CFC
#define GL_COLOR_ATTACHMENT29 0x8CFD
#define GL_COLOR_ATTACHMENT3 0x8CE3
#define GL_COLOR_ATTACHMENT30 0x8CFE
#define GL_COLOR_ATTACHMENT31 0x8CFF
#define GL_COLOR_ATTACHMENT4 0x8CE4
#define GL_COLOR_ATTACHMENT5 0x8CE5
#define GL_COLOR_ATTACHMENT6 0x8CE6
#define GL_COLOR_ATTACHMENT7 0x8CE7
#define GL_COLOR_ATTACHMENT8 0x8CE8
#define GL_COLOR_ATTACHMENT9 0x8CE9
#define GL_COLOR_BUFFER_BIT 0x00004000
#define GL_COLOR_CLEAR_VALUE 0x0C22
#define GL_COLOR_COMPONENTS 0x8283
#define GL_COLOR_ENCODING 0x8296
#define GL_COLOR_LOGIC_OP 0x0BF2
#define GL_COLOR_RENDERABLE 0x8286
#define GL_COLOR_WRITEMASK 0x0C23
#define GL_COMMAND_BARRIER_BIT 0x00000040
#define GL_COMPARE_REF_TO_TEXTURE 0x884E
#define GL_COMPATIBLE_SUBROUTINES 0x8E4B
#define GL_COMPILE_STATUS 0x8B81
#define GL_COMPRESSED_R11_EAC 0x9270
#define GL_COMPRESSED_RED 0x8225
#define GL_COMPRESSED_RED_RGTC1 0x8DBB
#define GL_COMPRESSED_RG 0x8226
#define GL_COMPRESSED_RG11_EAC 0x9272
#define GL_COMPRESSED_RGB 0x84ED
#define GL_COMPRESSED_RGB8_ETC2 0x9274
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_RGBA 0x84EE
#define GL_COMPRESSED_RGBA8_ETC2_EAC 0x9278
#define GL_COMPRESSED_RGBA_BPTC_UNORM 0x8E8C
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT 0x8E8F
#define GL_COMPRESSED_RG_RGTC2 0x8DBD
#define GL_COMPRESSED_SIGNED_R11_EAC 0x9271
#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
#define GL_COMPRESSED_SIGNED_RG11_EAC 0x9273
#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
#define GL_COMPRESSED_SRGB 0x8C48
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_COMPRESSED_SRGB8_ETC2 0x9275
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM 0x8E8D
#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
#define GL_COMPUTE_SHADER 0x91B9
#define GL_COMPUTE_SHADER_BIT 0x00000020
#define GL_COMPUTE_SHADER_INVOCATIONS 0x82F5
#define GL_COMPUTE_SUBROUTINE 0x92ED
#define GL_COMPUTE_SUBROUTINE_UNIFORM 0x92F3
#define GL_COMPUTE_TEXTURE 0x82A0
#define GL_COMPUTE_WORK_GROUP_SIZE 0x8267
#define GL_CONDITION_SATISFIED 0x911C
#define GL_CONSTANT_ALPHA 0x8003
#define GL_CONSTANT_COLOR 0x8001
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
#define GL_CONTEXT_FLAGS 0x821E
#define GL_CONTEXT_FLAG_DEBUG_BIT 0x00000002
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
#define GL_CONTEXT_FLAG_NO_ERROR_BIT 0x00000008
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT 0x00000004
#define GL_CONTEXT_LOST 0x0507
#define GL_CONTEXT_PROFILE_MASK 0x9126
#define GL_CONTEXT_RELEASE_BEHAVIOR 0x82FB
#define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH 0x82FC
#define GL_COPY 0x1503
#define GL_COPY_INVERTED 0x150C
#define GL_COPY_READ_BUFFER 0x8F36
#define GL_COPY_READ_BUFFER_BINDING 0x8F36
#define GL_COPY_WRITE_BUFFER 0x8F37
#define GL_COPY_WRITE_BUFFER_BINDING 0x8F37
#define GL_CULL_FACE 0x0B44
#define GL_CULL_FACE_MODE 0x0B45
#define GL_CURRENT_PROGRAM 0x8B8D
#define GL_CURRENT_QUERY 0x8865
#define GL_CURRENT_VERTEX_ATTRIB 0x8626
#define GL_CW 0x0900
#define GL_DEBUG_CALLBACK_FUNCTION 0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM 0x8245
#define GL_DEBUG_GROUP_STACK_DEPTH 0x826D
#define GL_DEBUG_LOGGED_MESSAGES 0x9145
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH 0x8243
#define GL_DEBUG_OUTPUT 0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS 0x8242
#define GL_DEBUG_SEVERITY_HIGH 0x9146
#define GL_DEBUG_SEVERITY_LOW 0x9148
#define GL_DEBUG_SEVERITY_MEDIUM 0x9147
#define GL_DEBUG_SEVERITY_NOTIFICATION 0x826B
#define GL_DEBUG_SOURCE_API 0x8246
#define GL_DEBUG_SOURCE_APPLICATION 0x824A
#define GL_DEBUG_SOURCE_OTHER 0x824B
#define GL_DEBUG_SOURCE_SHADER_COMPILER 0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY 0x8249
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM 0x8247
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR 0x824D
#define GL_DEBUG_TYPE_ERROR 0x824C
#define GL_DEBUG_TYPE_MARKER 0x8268
#define GL_DEBUG_TYPE_OTHER 0x8251
#define GL_DEBUG_TYPE_PERFORMANCE 0x8250
#define GL_DEBUG_TYPE_POP_GROUP 0x826A
#define GL_DEBUG_TYPE_PORTABILITY 0x824F
#define GL_DEBUG_TYPE_PUSH_GROUP 0x8269
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR 0x824E
#define GL_DECR 0x1E03
#define GL_DECR_WRAP 0x8508
#define GL_DELETE_STATUS 0x8B80
#define GL_DEPTH 0x1801
#define GL_DEPTH24_STENCIL8 0x88F0
#define GL_DEPTH32F_STENCIL8 0x8CAD
#define GL_DEPTH_ATTACHMENT 0x8D00
#define GL_DEPTH_BUFFER_BIT 0x00000100
#define GL_DEPTH_CLAMP 0x864F
#define GL_DEPTH_CLEAR_VALUE 0x0B73
#define GL_DEPTH_COMPONENT 0x1902
#define GL_DEPTH_COMPONENT16 0x81A5
#define GL_DEPTH_COMPONENT24 0x81A6
#define GL_DEPTH_COMPONENT32 0x81A7
#define GL_DEPTH_COMPONENT32F 0x8CAC
#define GL_DEPTH_COMPONENTS 0x8284
#define GL_DEPTH_FUNC 0x0B74
#define GL_DEPTH_RANGE 0x0B70
#define GL_DEPTH_RENDERABLE 0x8287
#define GL_DEPTH_STENCIL 0x84F9
#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
#define GL_DEPTH_STENCIL_TEXTURE_MODE 0x90EA
#define GL_DEPTH_TEST 0x0B71
#define GL_DEPTH_WRITEMASK 0x0B72
#define GL_DISPATCH_INDIRECT_BUFFER 0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING 0x90EF
#define GL_DITHER 0x0BD0
#define GL_DONT_CARE 0x1100
#define GL_DOUBLE 0x140A
#define GL_DOUBLEBUFFER 0x0C32
#define GL_DOUBLE_MAT2 0x8F46
#define GL_DOUBLE_MAT2x3 0x8F49
#define GL_DOUBLE_MAT2x4 0x8F4A
#define GL_DOUBLE_MAT3 0x8F47
#define GL_DOUBLE_MAT3x2 0x8F4B
#define GL_DOUBLE_MAT3x4 0x8F4C
#define GL_DOUBLE_MAT4 0x8F48
#define GL_DOUBLE_MAT4x2 0x8F4D
#define GL_DOUBLE_MAT4x3 0x8F4E
#define GL_DOUBLE_VEC2 0x8FFC
#define GL_DOUBLE_VEC3 0x8FFD
#define GL_DOUBLE_VEC4 0x8FFE
#define GL_DRAW_BUFFER 0x0C01
#define GL_DRAW_BUFFER0 0x8825
#define GL_DRAW_BUFFER1 0x8826
#define GL_DRAW_BUFFER10 0x882F
#define GL_DRAW_BUFFER11 0x8830
#define GL_DRAW_BUFFER12 0x8831
#define GL_DRAW_BUFFER13 0x8832
#define GL_DRAW_BUFFER14 0x8833
#define GL_DRAW_BUFFER15 0x8834
#define GL_DRAW_BUFFER2 0x8827
#define GL_DRAW_BUFFER3 0x8828
#define GL_DRAW_BUFFER4 0x8829
#define GL_DRAW_BUFFER5 0x882A
#define GL_DRAW_BUFFER6 0x882B
#define GL_DRAW_BUFFER7 0x882C
#define GL_DRAW_BUFFER8 0x882D
#define GL_DRAW_BUFFER9 0x882E
#define GL_DRAW_FRAMEBUFFER 0x8CA9
#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
#define GL_DRAW_INDIRECT_BUFFER 0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING 0x8F43
#define GL_DST_ALPHA 0x0304
#define GL_DST_COLOR 0x0306
#define GL_DYNAMIC_COPY 0x88EA
#define GL_DYNAMIC_DRAW 0x88E8
#define GL_DYNAMIC_READ 0x88E9
#define GL_DYNAMIC_STORAGE_BIT 0x0100
#define GL_ELEMENT_ARRAY_BARRIER_BIT 0x00000002
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
#define GL_EQUAL 0x0202
#define GL_EQUIV 0x1509
#define GL_EXTENSIONS 0x1F03
#define GL_FALSE 0
#define GL_FASTEST 0x1101
#define GL_FILL 0x1B02
#define GL_FILTER 0x829A
#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
#define GL_FIXED 0x140C
#define GL_FIXED_ONLY 0x891D
#define GL_FLOAT 0x1406
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT2x3 0x8B65
#define GL_FLOAT_MAT2x4 0x8B66
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT3x2 0x8B67
#define GL_FLOAT_MAT3x4 0x8B68
#define GL_FLOAT_MAT4 0x8B5C
#define GL_FLOAT_MAT4x2 0x8B69
#define GL_FLOAT_MAT4x3 0x8B6A
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FRACTIONAL_EVEN 0x8E7C
#define GL_FRACTIONAL_ODD 0x8E7B
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
#define GL_FRAGMENT_SHADER 0x8B30
#define GL_FRAGMENT_SHADER_BIT 0x00000002
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_FRAGMENT_SHADER_INVOCATIONS 0x82F4
#define GL_FRAGMENT_SUBROUTINE 0x92EC
#define GL_FRAGMENT_SUBROUTINE_UNIFORM 0x92F2
#define GL_FRAGMENT_TEXTURE 0x829F
#define GL_FRAMEBUFFER 0x8D40
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_BARRIER_BIT 0x00000400
#define GL_FRAMEBUFFER_BINDING 0x8CA6
#define GL_FRAMEBUFFER_BLEND 0x828B
#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
#define GL_FRAMEBUFFER_DEFAULT 0x8218
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS 0x9314
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT 0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS 0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES 0x9313
#define GL_FRAMEBUFFER_DEFAULT_WIDTH 0x9310
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_RENDERABLE 0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED 0x828A
#define GL_FRAMEBUFFER_SRGB 0x8DB9
#define GL_FRAMEBUFFER_UNDEFINED 0x8219
#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
#define GL_FRONT 0x0404
#define GL_FRONT_AND_BACK 0x0408
#define GL_FRONT_FACE 0x0B46
#define GL_FRONT_LEFT 0x0400
#define GL_FRONT_RIGHT 0x0401
#define GL_FULL_SUPPORT 0x82B7
#define GL_FUNC_ADD 0x8006
#define GL_FUNC_REVERSE_SUBTRACT 0x800B
#define GL_FUNC_SUBTRACT 0x800A
#define GL_GEOMETRY_INPUT_TYPE 0x8917
#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
#define GL_GEOMETRY_SHADER 0x8DD9
#define GL_GEOMETRY_SHADER_BIT 0x00000004
#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED 0x82F3
#define GL_GEOMETRY_SUBROUTINE 0x92EB
#define GL_GEOMETRY_SUBROUTINE_UNIFORM 0x92F1
#define GL_GEOMETRY_TEXTURE 0x829E
#define GL_GEOMETRY_VERTICES_OUT 0x8916
#define GL_GEQUAL 0x0206
#define GL_GET_TEXTURE_IMAGE_FORMAT 0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE 0x8292
#define GL_GREATER 0x0204
#define GL_GREEN 0x1904
#define GL_GREEN_INTEGER 0x8D95
#define GL_GUILTY_CONTEXT_RESET 0x8253
#define GL_HALF_FLOAT 0x140B
#define GL_HIGH_FLOAT 0x8DF2
#define GL_HIGH_INT 0x8DF5
#define GL_IMAGE_1D 0x904C
#define GL_IMAGE_1D_ARRAY 0x9052
#define GL_IMAGE_2D 0x904D
#define GL_IMAGE_2D_ARRAY 0x9053
#define GL_IMAGE_2D_MULTISAMPLE 0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY 0x9056
#define GL_IMAGE_2D_RECT 0x904F
#define GL_IMAGE_3D 0x904E
#define GL_IMAGE_BINDING_ACCESS 0x8F3E
#define GL_IMAGE_BINDING_FORMAT 0x906E
#define GL_IMAGE_BINDING_LAYER 0x8F3D
#define GL_IMAGE_BINDING_LAYERED 0x8F3C
#define GL_IMAGE_BINDING_LEVEL 0x8F3B
#define GL_IMAGE_BINDING_NAME 0x8F3A
#define GL_IMAGE_BUFFER 0x9051
#define GL_IMAGE_CLASS_10_10_10_2 0x82C3
#define GL_IMAGE_CLASS_11_11_10 0x82C2
#define GL_IMAGE_CLASS_1_X_16 0x82BE
#define GL_IMAGE_CLASS_1_X_32 0x82BB
#define GL_IMAGE_CLASS_1_X_8 0x82C1
#define GL_IMAGE_CLASS_2_X_16 0x82BD
#define GL_IMAGE_CLASS_2_X_32 0x82BA
#define GL_IMAGE_CLASS_2_X_8 0x82C0
#define GL_IMAGE_CLASS_4_X_16 0x82BC
#define GL_IMAGE_CLASS_4_X_32 0x82B9
#define GL_IMAGE_CLASS_4_X_8 0x82BF
#define GL_IMAGE_COMPATIBILITY_CLASS 0x82A8
#define GL_IMAGE_CUBE 0x9050
#define GL_IMAGE_CUBE_MAP_ARRAY 0x9054
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS 0x90C9
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE 0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE 0x90C7
#define GL_IMAGE_PIXEL_FORMAT 0x82A9
#define GL_IMAGE_PIXEL_TYPE 0x82AA
#define GL_IMAGE_TEXEL_SIZE 0x82A7
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_INCR 0x1E02
#define GL_INCR_WRAP 0x8507
#define GL_INFO_LOG_LENGTH 0x8B84
#define GL_INNOCENT_CONTEXT_RESET 0x8254
#define GL_INT 0x1404
#define GL_INTERLEAVED_ATTRIBS 0x8C8C
#define GL_INTERNALFORMAT_ALPHA_SIZE 0x8274
#define GL_INTERNALFORMAT_ALPHA_TYPE 0x827B
#define GL_INTERNALFORMAT_BLUE_SIZE 0x8273
#define GL_INTERNALFORMAT_BLUE_TYPE 0x827A
#define GL_INTERNALFORMAT_DEPTH_SIZE 0x8275
#define GL_INTERNALFORMAT_DEPTH_TYPE 0x827C
#define GL_INTERNALFORMAT_GREEN_SIZE 0x8272
#define GL_INTERNALFORMAT_GREEN_TYPE 0x8279
#define GL_INTERNALFORMAT_PREFERRED 0x8270
#define GL_INTERNALFORMAT_RED_SIZE 0x8271
#define GL_INTERNALFORMAT_RED_TYPE 0x8278
#define GL_INTERNALFORMAT_SHARED_SIZE 0x8277
#define GL_INTERNALFORMAT_STENCIL_SIZE 0x8276
#define GL_INTERNALFORMAT_STENCIL_TYPE 0x827D
#define GL_INTERNALFORMAT_SUPPORTED 0x826F
#define GL_INT_2_10_10_10_REV 0x8D9F
#define GL_INT_IMAGE_1D 0x9057
#define GL_INT_IMAGE_1D_ARRAY 0x905D
#define GL_INT_IMAGE_2D 0x9058
#define GL_INT_IMAGE_2D_ARRAY 0x905E
#define GL_INT_IMAGE_2D_MULTISAMPLE 0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x9061
#define GL_INT_IMAGE_2D_RECT 0x905A
#define GL_INT_IMAGE_3D 0x9059
#define GL_INT_IMAGE_BUFFER 0x905C
#define GL_INT_IMAGE_CUBE 0x905B
#define GL_INT_IMAGE_CUBE_MAP_ARRAY 0x905F
#define GL_INT_SAMPLER_1D 0x8DC9
#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
#define GL_INT_SAMPLER_2D 0x8DCA
#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_INT_SAMPLER_2D_RECT 0x8DCD
#define GL_INT_SAMPLER_3D 0x8DCB
#define GL_INT_SAMPLER_BUFFER 0x8DD0
#define GL_INT_SAMPLER_CUBE 0x8DCC
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY 0x900E
#define GL_INT_VEC2 0x8B53
#define GL_INT_VEC3 0x8B54
#define GL_INT_VEC4 0x8B55
#define GL_INVALID_ENUM 0x0500
#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
#define GL_INVALID_INDEX 0xFFFFFFFF
#define GL_INVALID_OPERATION 0x0502
#define GL_INVALID_VALUE 0x0501
#define GL_INVERT 0x150A
#define GL_ISOLINES 0x8E7A
#define GL_IS_PER_PATCH 0x92E7
#define GL_IS_ROW_MAJOR 0x9300
#define GL_KEEP 0x1E00
#define GL_LAST_VERTEX_CONVENTION 0x8E4E
#define GL_LAYER_PROVOKING_VERTEX 0x825E
#define GL_LEFT 0x0406
#define GL_LEQUAL 0x0203
#define GL_LESS 0x0201
#define GL_LINE 0x1B01
#define GL_LINEAR 0x2601
#define GL_LINEAR_MIPMAP_LINEAR 0x2703
#define GL_LINEAR_MIPMAP_NEAREST 0x2701
#define GL_LINES 0x0001
#define GL_LINES_ADJACENCY 0x000A
#define GL_LINE_LOOP 0x0002
#define GL_LINE_SMOOTH 0x0B20
#define GL_LINE_SMOOTH_HINT 0x0C52
#define GL_LINE_STRIP 0x0003
#define GL_LINE_STRIP_ADJACENCY 0x000B
#define GL_LINE_WIDTH 0x0B21
#define GL_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_LINE_WIDTH_RANGE 0x0B22
#define GL_LINK_STATUS 0x8B82
#define GL_LOCATION 0x930E
#define GL_LOCATION_COMPONENT 0x934A
#define GL_LOCATION_INDEX 0x930F
#define GL_LOGIC_OP_MODE 0x0BF0
#define GL_LOSE_CONTEXT_ON_RESET 0x8252
#define GL_LOWER_LEFT 0x8CA1
#define GL_LOW_FLOAT 0x8DF0
#define GL_LOW_INT 0x8DF3
#define GL_MAJOR_VERSION 0x821B
#define GL_MANUAL_GENERATE_MIPMAP 0x8294
#define GL_MAP_COHERENT_BIT 0x0080
#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
#define GL_MAP_PERSISTENT_BIT 0x0040
#define GL_MAP_READ_BIT 0x0001
#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
#define GL_MAP_WRITE_BIT 0x0002
#define GL_MATRIX_STRIDE 0x92FF
#define GL_MAX 0x8008
#define GL_MAX_3D_TEXTURE_SIZE 0x8073
#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 0x92DC
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE 0x92D8
#define GL_MAX_CLIP_DISTANCES 0x0D32
#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
#define GL_MAX_COMBINED_ATOMIC_COUNTERS 0x92D7
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 0x92D1
#define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES 0x82FA
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
#define GL_MAX_COMBINED_DIMENSIONS 0x8282
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_IMAGE_UNIFORMS 0x90CF
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS 0x8F39
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES 0x8F39
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS 0x90DC
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS 0x8265
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS 0x91BD
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS 0x90DB
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE 0x8262
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS 0x91BC
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS 0x91BB
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS 0x8263
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT 0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS 0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE 0x91BF
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
#define GL_MAX_CULL_DISTANCES 0x82F9
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH 0x826C
#define GL_MAX_DEBUG_LOGGED_MESSAGES 0x9144
#define GL_MAX_DEBUG_MESSAGE_LENGTH 0x9143
#define GL_MAX_DEPTH 0x8280
#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
#define GL_MAX_DRAW_BUFFERS 0x8824
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
#define GL_MAX_ELEMENTS_INDICES 0x80E9
#define GL_MAX_ELEMENTS_VERTICES 0x80E8
#define GL_MAX_ELEMENT_INDEX 0x8D6B
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS 0x92D6
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 0x92D0
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS 0x90CE
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 0x90DA
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS 0x8DFD
#define GL_MAX_FRAMEBUFFER_HEIGHT 0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS 0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES 0x9318
#define GL_MAX_FRAMEBUFFER_WIDTH 0x9315
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS 0x92D5
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0x92CF
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS 0x90CD
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0x90D7
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS 0x8A2C
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_HEIGHT 0x827F
#define GL_MAX_IMAGE_SAMPLES 0x906D
#define GL_MAX_IMAGE_UNITS 0x8F38
#define GL_MAX_INTEGER_SAMPLES 0x9110
#define GL_MAX_LABEL_LENGTH 0x82E8
#define GL_MAX_LAYERS 0x8281
#define GL_MAX_NAME_LENGTH 0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES 0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES 0x92F8
#define GL_MAX_PATCH_VERTICES 0x8E7D
#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
#define GL_MAX_SAMPLES 0x8D57
#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE 0x90DE
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS 0x90DD
#define GL_MAX_SUBROUTINES 0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS 0x92D3
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0x92CD
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS 0x90CB
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0x90D8
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0x92D4
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0x92CE
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0x90CC
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0x90D9
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_GEN_LEVEL 0x8E7E
#define GL_MAX_TESS_PATCH_COMPONENTS 0x8E84
#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
#define GL_MAX_TEXTURE_LOD_BIAS_EXT 0x84FD
#define GL_MAX_TEXTURE_MAX_ANISOTROPY 0x84FF
#define GL_MAX_TEXTURE_SIZE 0x0D33
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
#define GL_MAX_UNIFORM_LOCATIONS 0x826E
#define GL_MAX_VARYING_COMPONENTS 0x8B4B
#define GL_MAX_VARYING_FLOATS 0x8B4B
#define GL_MAX_VARYING_VECTORS 0x8DFC
#define GL_MAX_VERTEX_ATOMIC_COUNTERS 0x92D2
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0x92CC
#define GL_MAX_VERTEX_ATTRIBS 0x8869
#define GL_MAX_VERTEX_ATTRIB_BINDINGS 0x82DA
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D9
#define GL_MAX_VERTEX_ATTRIB_STRIDE 0x82E5
#define GL_MAX_VERTEX_IMAGE_UNIFORMS 0x90CA
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS 0x90D6
#define GL_MAX_VERTEX_STREAMS 0x8E71
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
#define GL_MAX_VERTEX_UNIFORM_VECTORS 0x8DFB
#define GL_MAX_VIEWPORTS 0x825B
#define GL_MAX_VIEWPORT_DIMS 0x0D3A
#define GL_MAX_WIDTH 0x827E
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_MEDIUM_INT 0x8DF4
#define GL_MIN 0x8007
#define GL_MINOR_VERSION 0x821C
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MIN_MAP_BUFFER_ALIGNMENT 0x90BC
#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MIN_SAMPLE_SHADING_VALUE 0x8C37
#define GL_MIPMAP 0x8293
#define GL_MIRRORED_REPEAT 0x8370
#define GL_MIRROR_CLAMP_TO_EDGE 0x8743
#define GL_MULTISAMPLE 0x809D
#define GL_NAME_LENGTH 0x92F9
#define GL_NAND 0x150E
#define GL_NEAREST 0x2600
#define GL_NEAREST_MIPMAP_LINEAR 0x2702
#define GL_NEAREST_MIPMAP_NEAREST 0x2700
#define GL_NEGATIVE_ONE_TO_ONE 0x935E
#define GL_NEVER 0x0200
#define GL_NICEST 0x1102
#define GL_NONE 0
#define GL_NOOP 0x1505
#define GL_NOR 0x1508
#define GL_NOTEQUAL 0x0205
#define GL_NO_ERROR 0
#define GL_NO_RESET_NOTIFICATION 0x8261
#define GL_NUM_ACTIVE_VARIABLES 0x9304
#define GL_NUM_COMPATIBLE_SUBROUTINES 0x8E4A
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_NUM_EXTENSIONS 0x821D
#define GL_NUM_PROGRAM_BINARY_FORMATS 0x87FE
#define GL_NUM_SAMPLE_COUNTS 0x9380
#define GL_NUM_SHADER_BINARY_FORMATS 0x8DF9
#define GL_NUM_SHADING_LANGUAGE_VERSIONS 0x82E9
#define GL_NUM_SPIR_V_EXTENSIONS 0x9554
#define GL_OBJECT_TYPE 0x9112
#define GL_OFFSET 0x92FC
#define GL_ONE 1
#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
#define GL_ONE_MINUS_DST_ALPHA 0x0305
#define GL_ONE_MINUS_DST_COLOR 0x0307
#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
#define GL_ONE_MINUS_SRC_ALPHA 0x0303
#define GL_ONE_MINUS_SRC_COLOR 0x0301
#define GL_OR 0x1507
#define GL_OR_INVERTED 0x150D
#define GL_OR_REVERSE 0x150B
#define GL_OUT_OF_MEMORY 0x0505
#define GL_PACK_ALIGNMENT 0x0D05
#define GL_PACK_COMPRESSED_BLOCK_DEPTH 0x912D
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT 0x912C
#define GL_PACK_COMPRESSED_BLOCK_SIZE 0x912E
#define GL_PACK_COMPRESSED_BLOCK_WIDTH 0x912B
#define GL_PACK_IMAGE_HEIGHT 0x806C
#define GL_PACK_LSB_FIRST 0x0D01
#define GL_PACK_ROW_LENGTH 0x0D02
#define GL_PACK_SKIP_IMAGES 0x806B
#define GL_PACK_SKIP_PIXELS 0x0D04
#define GL_PACK_SKIP_ROWS 0x0D03
#define GL_PACK_SWAP_BYTES 0x0D00
#define GL_PARAMETER_BUFFER 0x80EE
#define GL_PARAMETER_BUFFER_BINDING 0x80EF
#define GL_PATCHES 0x000E
#define GL_PATCH_DEFAULT_INNER_LEVEL 0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL 0x8E74
#define GL_PATCH_VERTICES 0x8E72
#define GL_PIXEL_BUFFER_BARRIER_BIT 0x00000080
#define GL_PIXEL_PACK_BUFFER 0x88EB
#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
#define GL_PIXEL_UNPACK_BUFFER 0x88EC
#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
#define GL_POINT 0x1B00
#define GL_POINTS 0x0000
#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
#define GL_POINT_SIZE 0x0B11
#define GL_POINT_SIZE_GRANULARITY 0x0B13
#define GL_POINT_SIZE_RANGE 0x0B12
#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
#define GL_POLYGON_MODE 0x0B40
#define GL_POLYGON_OFFSET_CLAMP 0x8E1B
#define GL_POLYGON_OFFSET_FACTOR 0x8038
#define GL_POLYGON_OFFSET_FILL 0x8037
#define GL_POLYGON_OFFSET_LINE 0x2A02
#define GL_POLYGON_OFFSET_POINT 0x2A01
#define GL_POLYGON_OFFSET_UNITS 0x2A00
#define GL_POLYGON_SMOOTH 0x0B41
#define GL_POLYGON_SMOOTH_HINT 0x0C53
#define GL_PRIMITIVES_GENERATED 0x8C87
#define GL_PRIMITIVES_SUBMITTED 0x82EF
#define GL_PRIMITIVE_RESTART 0x8F9D
#define GL_PRIMITIVE_RESTART_FIXED_INDEX 0x8D69
#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
#define GL_PROGRAM 0x82E2
#define GL_PROGRAM_BINARY_FORMATS 0x87FF
#define GL_PROGRAM_BINARY_LENGTH 0x8741
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_INPUT 0x92E3
#define GL_PROGRAM_OUTPUT 0x92E4
#define GL_PROGRAM_PIPELINE 0x82E4
#define GL_PROGRAM_PIPELINE_BINDING 0x825A
#define GL_PROGRAM_POINT_SIZE 0x8642
#define GL_PROGRAM_SEPARABLE 0x8258
#define GL_PROVOKING_VERTEX 0x8E4F
#define GL_PROXY_TEXTURE_1D 0x8063
#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
#define GL_PROXY_TEXTURE_2D 0x8064
#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_PROXY_TEXTURE_3D 0x8070
#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY 0x900B
#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
#define GL_QUADS 0x0007
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_QUERY 0x82E3
#define GL_QUERY_BUFFER 0x9192
#define GL_QUERY_BUFFER_BARRIER_BIT 0x00008000
#define GL_QUERY_BUFFER_BINDING 0x9193
#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
#define GL_QUERY_BY_REGION_NO_WAIT_INVERTED 0x8E1A
#define GL_QUERY_BY_REGION_WAIT 0x8E15
#define GL_QUERY_BY_REGION_WAIT_INVERTED 0x8E19
#define GL_QUERY_COUNTER_BITS 0x8864
#define GL_QUERY_NO_WAIT 0x8E14
#define GL_QUERY_NO_WAIT_INVERTED 0x8E18
#define GL_QUERY_RESULT 0x8866
#define GL_QUERY_RESULT_AVAILABLE 0x8867
#define GL_QUERY_RESULT_NO_WAIT 0x9194
#define GL_QUERY_TARGET 0x82EA
#define GL_QUERY_WAIT 0x8E13
#define GL_QUERY_WAIT_INVERTED 0x8E17
#define GL_R11F_G11F_B10F 0x8C3A
#define GL_R16 0x822A
#define GL_R16F 0x822D
#define GL_R16I 0x8233
#define GL_R16UI 0x8234
#define GL_R16_SNORM 0x8F98
#define GL_R32F 0x822E
#define GL_R32I 0x8235
#define GL_R32UI 0x8236
#define GL_R3_G3_B2 0x2A10
#define GL_R8 0x8229
#define GL_R8I 0x8231
#define GL_R8UI 0x8232
#define GL_R8_SNORM 0x8F94
#define GL_RASTERIZER_DISCARD 0x8C89
#define GL_READ_BUFFER 0x0C02
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
#define GL_READ_ONLY 0x88B8
#define GL_READ_PIXELS 0x828C
#define GL_READ_PIXELS_FORMAT 0x828D
#define GL_READ_PIXELS_TYPE 0x828E
#define GL_READ_WRITE 0x88BA
#define GL_RED 0x1903
#define GL_RED_INTEGER 0x8D94
#define GL_REFERENCED_BY_COMPUTE_SHADER 0x930B
#define GL_REFERENCED_BY_FRAGMENT_SHADER 0x930A
#define GL_REFERENCED_BY_GEOMETRY_SHADER 0x9309
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER 0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER 0x9308
#define GL_REFERENCED_BY_VERTEX_SHADER 0x9306
#define GL_RENDERBUFFER 0x8D41
#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
#define GL_RENDERBUFFER_BINDING 0x8CA7
#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
#define GL_RENDERBUFFER_HEIGHT 0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
#define GL_RENDERBUFFER_RED_SIZE 0x8D50
#define GL_RENDERBUFFER_SAMPLES 0x8CAB
#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
#define GL_RENDERBUFFER_WIDTH 0x8D42
#define GL_RENDERER 0x1F01
#define GL_REPEAT 0x2901
#define GL_REPLACE 0x1E01
#define GL_RESET_NOTIFICATION_STRATEGY 0x8256
#define GL_RG 0x8227
#define GL_RG16 0x822C
#define GL_RG16F 0x822F
#define GL_RG16I 0x8239
#define GL_RG16UI 0x823A
#define GL_RG16_SNORM 0x8F99
#define GL_RG32F 0x8230
#define GL_RG32I 0x823B
#define GL_RG32UI 0x823C
#define GL_RG8 0x822B
#define GL_RG8I 0x8237
#define GL_RG8UI 0x8238
#define GL_RG8_SNORM 0x8F95
#define GL_RGB 0x1907
#define GL_RGB10 0x8052
#define GL_RGB10_A2 0x8059
#define GL_RGB10_A2UI 0x906F
#define GL_RGB12 0x8053
#define GL_RGB16 0x8054
#define GL_RGB16F 0x881B
#define GL_RGB16I 0x8D89
#define GL_RGB16UI 0x8D77
#define GL_RGB16_SNORM 0x8F9A
#define GL_RGB32F 0x8815
#define GL_RGB32I 0x8D83
#define GL_RGB32UI 0x8D71
#define GL_RGB4 0x804F
#define GL_RGB5 0x8050
#define GL_RGB565 0x8D62
#define GL_RGB5_A1 0x8057
#define GL_RGB8 0x8051
#define GL_RGB8I 0x8D8F
#define GL_RGB8UI 0x8D7D
#define GL_RGB8_SNORM 0x8F96
#define GL_RGB9_E5 0x8C3D
#define GL_RGBA 0x1908
#define GL_RGBA12 0x805A
#define GL_RGBA16 0x805B
#define GL_RGBA16F 0x881A
#define GL_RGBA16I 0x8D88
#define GL_RGBA16UI 0x8D76
#define GL_RGBA16_SNORM 0x8F9B
#define GL_RGBA2 0x8055
#define GL_RGBA32F 0x8814
#define GL_RGBA32I 0x8D82
#define GL_RGBA32UI 0x8D70
#define GL_RGBA4 0x8056
#define GL_RGBA8 0x8058
#define GL_RGBA8I 0x8D8E
#define GL_RGBA8UI 0x8D7C
#define GL_RGBA8_SNORM 0x8F97
#define GL_RGBA_INTEGER 0x8D99
#define GL_RGB_INTEGER 0x8D98
#define GL_RG_INTEGER 0x8228
#define GL_RIGHT 0x0407
#define GL_SAMPLER 0x82E6
#define GL_SAMPLER_1D 0x8B5D
#define GL_SAMPLER_1D_ARRAY 0x8DC0
#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
#define GL_SAMPLER_1D_SHADOW 0x8B61
#define GL_SAMPLER_2D 0x8B5E
#define GL_SAMPLER_2D_ARRAY 0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
#define GL_SAMPLER_2D_RECT 0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
#define GL_SAMPLER_2D_SHADOW 0x8B62
#define GL_SAMPLER_3D 0x8B5F
#define GL_SAMPLER_BINDING 0x8919
#define GL_SAMPLER_BUFFER 0x8DC2
#define GL_SAMPLER_CUBE 0x8B60
#define GL_SAMPLER_CUBE_MAP_ARRAY 0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW 0x900D
#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
#define GL_SAMPLES 0x80A9
#define GL_SAMPLES_PASSED 0x8914
#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
#define GL_SAMPLE_BUFFERS 0x80A8
#define GL_SAMPLE_COVERAGE 0x80A0
#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
#define GL_SAMPLE_MASK 0x8E51
#define GL_SAMPLE_MASK_VALUE 0x8E52
#define GL_SAMPLE_POSITION 0x8E50
#define GL_SAMPLE_SHADING 0x8C36
#define GL_SCISSOR_BOX 0x0C10
#define GL_SCISSOR_TEST 0x0C11
#define GL_SEPARATE_ATTRIBS 0x8C8D
#define GL_SET 0x150F
#define GL_SHADER 0x82E1
#define GL_SHADER_BINARY_FORMATS 0x8DF8
#define GL_SHADER_BINARY_FORMAT_SPIR_V 0x9551
#define GL_SHADER_COMPILER 0x8DFA
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT 0x00000020
#define GL_SHADER_IMAGE_ATOMIC 0x82A6
#define GL_SHADER_IMAGE_LOAD 0x82A4
#define GL_SHADER_IMAGE_STORE 0x82A5
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#define GL_SHADER_STORAGE_BARRIER_BIT 0x00002000
#define GL_SHADER_STORAGE_BLOCK 0x92E6
#define GL_SHADER_STORAGE_BUFFER 0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING 0x90D3
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 0x90DF
#define GL_SHADER_STORAGE_BUFFER_SIZE 0x90D5
#define GL_SHADER_STORAGE_BUFFER_START 0x90D4
#define GL_SHADER_TYPE 0x8B4F
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#define GL_SHORT 0x1402
#define GL_SIGNALED 0x9119
#define GL_SIGNED_NORMALIZED 0x8F9C
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST 0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE 0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST 0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE 0x82AF
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
#define GL_SPIR_V_BINARY 0x9552
#define GL_SPIR_V_EXTENSIONS 0x9553
#define GL_SRC1_ALPHA 0x8589
#define GL_SRC1_COLOR 0x88F9
#define GL_SRC_ALPHA 0x0302
#define GL_SRC_ALPHA_SATURATE 0x0308
#define GL_SRC_COLOR 0x0300
#define GL_SRGB 0x8C40
#define GL_SRGB8 0x8C41
#define GL_SRGB8_ALPHA8 0x8C43
#define GL_SRGB_ALPHA 0x8C42
#define GL_SRGB_READ 0x8297
#define GL_SRGB_WRITE 0x8298
#define GL_STACK_OVERFLOW 0x0503
#define GL_STACK_UNDERFLOW 0x0504
#define GL_STATIC_COPY 0x88E6
#define GL_STATIC_DRAW 0x88E4
#define GL_STATIC_READ 0x88E5
#define GL_STENCIL 0x1802
#define GL_STENCIL_ATTACHMENT 0x8D20
#define GL_STENCIL_BACK_FAIL 0x8801
#define GL_STENCIL_BACK_FUNC 0x8800
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
#define GL_STENCIL_BACK_REF 0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
#define GL_STENCIL_BUFFER_BIT 0x00000400
#define GL_STENCIL_CLEAR_VALUE 0x0B91
#define GL_STENCIL_COMPONENTS 0x8285
#define GL_STENCIL_FAIL 0x0B94
#define GL_STENCIL_FUNC 0x0B92
#define GL_STENCIL_INDEX 0x1901
#define GL_STENCIL_INDEX1 0x8D46
#define GL_STENCIL_INDEX16 0x8D49
#define GL_STENCIL_INDEX4 0x8D47
#define GL_STENCIL_INDEX8 0x8D48
#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
#define GL_STENCIL_REF 0x0B97
#define GL_STENCIL_RENDERABLE 0x8288
#define GL_STENCIL_TEST 0x0B90
#define GL_STENCIL_VALUE_MASK 0x0B93
#define GL_STENCIL_WRITEMASK 0x0B98
#define GL_STEREO 0x0C33
#define GL_STREAM_COPY 0x88E2
#define GL_STREAM_DRAW 0x88E0
#define GL_STREAM_READ 0x88E1
#define GL_SUBPIXEL_BITS 0x0D50
#define GL_SYNC_CONDITION 0x9113
#define GL_SYNC_FENCE 0x9116
#define GL_SYNC_FLAGS 0x9115
#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
#define GL_SYNC_STATUS 0x9114
#define GL_TESS_CONTROL_OUTPUT_VERTICES 0x8E75
#define GL_TESS_CONTROL_SHADER 0x8E88
#define GL_TESS_CONTROL_SHADER_BIT 0x00000008
#define GL_TESS_CONTROL_SHADER_PATCHES 0x82F1
#define GL_TESS_CONTROL_SUBROUTINE 0x92E9
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM 0x92EF
#define GL_TESS_CONTROL_TEXTURE 0x829C
#define GL_TESS_EVALUATION_SHADER 0x8E87
#define GL_TESS_EVALUATION_SHADER_BIT 0x00000010
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS 0x82F2
#define GL_TESS_EVALUATION_SUBROUTINE 0x92EA
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM 0x92F0
#define GL_TESS_EVALUATION_TEXTURE 0x829D
#define GL_TESS_GEN_MODE 0x8E76
#define GL_TESS_GEN_POINT_MODE 0x8E79
#define GL_TESS_GEN_SPACING 0x8E77
#define GL_TESS_GEN_VERTEX_ORDER 0x8E78
#define GL_TEXTURE 0x1702
#define GL_TEXTURE0 0x84C0
#define GL_TEXTURE1 0x84C1
#define GL_TEXTURE10 0x84CA
#define GL_TEXTURE11 0x84CB
#define GL_TEXTURE12 0x84CC
#define GL_TEXTURE13 0x84CD
#define GL_TEXTURE14 0x84CE
#define GL_TEXTURE15 0x84CF
#define GL_TEXTURE16 0x84D0
#define GL_TEXTURE17 0x84D1
#define GL_TEXTURE18 0x84D2
#define GL_TEXTURE19 0x84D3
#define GL_TEXTURE2 0x84C2
#define GL_TEXTURE20 0x84D4
#define GL_TEXTURE21 0x84D5
#define GL_TEXTURE22 0x84D6
#define GL_TEXTURE23 0x84D7
#define GL_TEXTURE24 0x84D8
#define GL_TEXTURE25 0x84D9
#define GL_TEXTURE26 0x84DA
#define GL_TEXTURE27 0x84DB
#define GL_TEXTURE28 0x84DC
#define GL_TEXTURE29 0x84DD
#define GL_TEXTURE3 0x84C3
#define GL_TEXTURE30 0x84DE
#define GL_TEXTURE31 0x84DF
#define GL_TEXTURE4 0x84C4
#define GL_TEXTURE5 0x84C5
#define GL_TEXTURE6 0x84C6
#define GL_TEXTURE7 0x84C7
#define GL_TEXTURE8 0x84C8
#define GL_TEXTURE9 0x84C9
#define GL_TEXTURE_1D 0x0DE0
#define GL_TEXTURE_1D_ARRAY 0x8C18
#define GL_TEXTURE_2D 0x0DE1
#define GL_TEXTURE_2D_ARRAY 0x8C1A
#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
#define GL_TEXTURE_3D 0x806F
#define GL_TEXTURE_ALPHA_SIZE 0x805F
#define GL_TEXTURE_ALPHA_TYPE 0x8C13
#define GL_TEXTURE_BASE_LEVEL 0x813C
#define GL_TEXTURE_BINDING_1D 0x8068
#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
#define GL_TEXTURE_BINDING_2D 0x8069
#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_BINDING_3D 0x806A
#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
#define GL_TEXTURE_BLUE_SIZE 0x805E
#define GL_TEXTURE_BLUE_TYPE 0x8C12
#define GL_TEXTURE_BORDER_COLOR 0x1004
#define GL_TEXTURE_BUFFER 0x8C2A
#define GL_TEXTURE_BUFFER_BINDING 0x8C2A
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_BUFFER_OFFSET 0x919D
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT 0x919F
#define GL_TEXTURE_BUFFER_SIZE 0x919E
#define GL_TEXTURE_COMPARE_FUNC 0x884D
#define GL_TEXTURE_COMPARE_MODE 0x884C
#define GL_TEXTURE_COMPRESSED 0x86A1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT 0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE 0x82B3
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH 0x82B1
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
#define GL_TEXTURE_CUBE_MAP 0x8513
#define GL_TEXTURE_CUBE_MAP_ARRAY 0x9009
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
#define GL_TEXTURE_DEPTH 0x8071
#define GL_TEXTURE_DEPTH_SIZE 0x884A
#define GL_TEXTURE_DEPTH_TYPE 0x8C16
#define GL_TEXTURE_FETCH_BARRIER_BIT 0x00000008
#define GL_TEXTURE_FILTER_CONTROL_EXT 0x8500
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_TEXTURE_GATHER 0x82A2
#define GL_TEXTURE_GATHER_SHADOW 0x82A3
#define GL_TEXTURE_GREEN_SIZE 0x805D
#define GL_TEXTURE_GREEN_TYPE 0x8C11
#define GL_TEXTURE_HEIGHT 0x1001
#define GL_TEXTURE_IMAGE_FORMAT 0x828F
#define GL_TEXTURE_IMAGE_TYPE 0x8290
#define GL_TEXTURE_IMMUTABLE_FORMAT 0x912F
#define GL_TEXTURE_IMMUTABLE_LEVELS 0x82DF
#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
#define GL_TEXTURE_LOD_BIAS 0x8501
#define GL_TEXTURE_LOD_BIAS_EXT 0x8501
#define GL_TEXTURE_MAG_FILTER 0x2800
#define GL_TEXTURE_MAX_ANISOTROPY 0x84FE
#define GL_TEXTURE_MAX_LEVEL 0x813D
#define GL_TEXTURE_MAX_LOD 0x813B
#define GL_TEXTURE_MIN_FILTER 0x2801
#define GL_TEXTURE_MIN_LOD 0x813A
#define GL_TEXTURE_RECTANGLE 0x84F5
#define GL_TEXTURE_RED_SIZE 0x805C
#define GL_TEXTURE_RED_TYPE 0x8C10
#define GL_TEXTURE_SAMPLES 0x9106
#define GL_TEXTURE_SHADOW 0x82A1
#define GL_TEXTURE_SHARED_SIZE 0x8C3F
#define GL_TEXTURE_STENCIL_SIZE 0x88F1
#define GL_TEXTURE_SWIZZLE_A 0x8E45
#define GL_TEXTURE_SWIZZLE_B 0x8E44
#define GL_TEXTURE_SWIZZLE_G 0x8E43
#define GL_TEXTURE_SWIZZLE_R 0x8E42
#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
#define GL_TEXTURE_TARGET 0x1006
#define GL_TEXTURE_UPDATE_BARRIER_BIT 0x00000100
#define GL_TEXTURE_VIEW 0x82B5
#define GL_TEXTURE_VIEW_MIN_LAYER 0x82DD
#define GL_TEXTURE_VIEW_MIN_LEVEL 0x82DB
#define GL_TEXTURE_VIEW_NUM_LAYERS 0x82DE
#define GL_TEXTURE_VIEW_NUM_LEVELS 0x82DC
#define GL_TEXTURE_WIDTH 0x1000
#define GL_TEXTURE_WRAP_R 0x8072
#define GL_TEXTURE_WRAP_S 0x2802
#define GL_TEXTURE_WRAP_T 0x2803
#define GL_TIMEOUT_EXPIRED 0x911B
#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
#define GL_TIMESTAMP 0x8E28
#define GL_TIME_ELAPSED 0x88BF
#define GL_TOP_LEVEL_ARRAY_SIZE 0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE 0x930D
#define GL_TRANSFORM_FEEDBACK 0x8E22
#define GL_TRANSFORM_FEEDBACK_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT 0x00000800
#define GL_TRANSFORM_FEEDBACK_BINDING 0x8E25
#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX 0x934B
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE 0x934C
#define GL_TRANSFORM_FEEDBACK_OVERFLOW 0x82EC
#define GL_TRANSFORM_FEEDBACK_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW 0x82ED
#define GL_TRANSFORM_FEEDBACK_VARYING 0x92F4
#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRIANGLES 0x0004
#define GL_TRIANGLES_ADJACENCY 0x000C
#define GL_TRIANGLE_FAN 0x0006
#define GL_TRIANGLE_STRIP 0x0005
#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
#define GL_TRUE 1
#define GL_TYPE 0x92FA
#define GL_UNDEFINED_VERTEX 0x8260
#define GL_UNIFORM 0x92E1
#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX 0x92DA
#define GL_UNIFORM_BARRIER_BIT 0x00000004
#define GL_UNIFORM_BLOCK 0x92E2
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BUFFER 0x8A11
#define GL_UNIFORM_BUFFER_BINDING 0x8A28
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
#define GL_UNIFORM_BUFFER_START 0x8A29
#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
#define GL_UNIFORM_NAME_LENGTH 0x8A39
#define GL_UNIFORM_OFFSET 0x8A3B
#define GL_UNIFORM_SIZE 0x8A38
#define GL_UNIFORM_TYPE 0x8A37
#define GL_UNKNOWN_CONTEXT_RESET 0x8255
#define GL_UNPACK_ALIGNMENT 0x0CF5
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH 0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT 0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE 0x912A
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH 0x9127
#define GL_UNPACK_IMAGE_HEIGHT 0x806E
#define GL_UNPACK_LSB_FIRST 0x0CF1
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_IMAGES 0x806D
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#define GL_UNPACK_SWAP_BYTES 0x0CF0
#define GL_UNSIGNALED 0x9118
#define GL_UNSIGNED_BYTE 0x1401
#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
#define GL_UNSIGNED_BYTE_3_3_2 0x8032
#define GL_UNSIGNED_INT 0x1405
#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
#define GL_UNSIGNED_INT_10_10_10_2 0x8036
#define GL_UNSIGNED_INT_24_8 0x84FA
#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
#define GL_UNSIGNED_INT_8_8_8_8 0x8035
#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
#define GL_UNSIGNED_INT_ATOMIC_COUNTER 0x92DB
#define GL_UNSIGNED_INT_IMAGE_1D 0x9062
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY 0x9068
#define GL_UNSIGNED_INT_IMAGE_2D 0x9063
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY 0x9069
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x906C
#define GL_UNSIGNED_INT_IMAGE_2D_RECT 0x9065
#define GL_UNSIGNED_INT_IMAGE_3D 0x9064
#define GL_UNSIGNED_INT_IMAGE_BUFFER 0x9067
#define GL_UNSIGNED_INT_IMAGE_CUBE 0x9066
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY 0x906A
#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8
#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
#define GL_UNSIGNED_INT_VEC2 0x8DC6
#define GL_UNSIGNED_INT_VEC3 0x8DC7
#define GL_UNSIGNED_INT_VEC4 0x8DC8
#define GL_UNSIGNED_NORMALIZED 0x8C17
#define GL_UNSIGNED_SHORT 0x1403
#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
#define GL_UNSIGNED_SHORT_5_6_5 0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
#define GL_UPPER_LEFT 0x8CA2
#define GL_VALIDATE_STATUS 0x8B83
#define GL_VENDOR 0x1F00
#define GL_VERSION 0x1F02
#define GL_VERTEX_ARRAY 0x8074
#define GL_VERTEX_ARRAY_BINDING 0x85B5
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT 0x00000001
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_LONG 0x874E
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
#define GL_VERTEX_ATTRIB_BINDING 0x82D4
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D5
#define GL_VERTEX_BINDING_BUFFER 0x8F4F
#define GL_VERTEX_BINDING_DIVISOR 0x82D6
#define GL_VERTEX_BINDING_OFFSET 0x82D7
#define GL_VERTEX_BINDING_STRIDE 0x82D8
#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
#define GL_VERTEX_SHADER 0x8B31
#define GL_VERTEX_SHADER_BIT 0x00000001
#define GL_VERTEX_SHADER_INVOCATIONS 0x82F0
#define GL_VERTEX_SUBROUTINE 0x92E8
#define GL_VERTEX_SUBROUTINE_UNIFORM 0x92EE
#define GL_VERTEX_TEXTURE 0x829B
#define GL_VERTICES_SUBMITTED 0x82EE
#define GL_VIEWPORT 0x0BA2
#define GL_VIEWPORT_BOUNDS_RANGE 0x825D
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_VIEWPORT_SUBPIXEL_BITS 0x825C
#define GL_VIEW_CLASS_128_BITS 0x82C4
#define GL_VIEW_CLASS_16_BITS 0x82CA
#define GL_VIEW_CLASS_24_BITS 0x82C9
#define GL_VIEW_CLASS_32_BITS 0x82C8
#define GL_VIEW_CLASS_48_BITS 0x82C7
#define GL_VIEW_CLASS_64_BITS 0x82C6
#define GL_VIEW_CLASS_8_BITS 0x82CB
#define GL_VIEW_CLASS_96_BITS 0x82C5
#define GL_VIEW_CLASS_BPTC_FLOAT 0x82D3
#define GL_VIEW_CLASS_BPTC_UNORM 0x82D2
#define GL_VIEW_CLASS_RGTC1_RED 0x82D0
#define GL_VIEW_CLASS_RGTC2_RG 0x82D1
#define GL_VIEW_CLASS_S3TC_DXT1_RGB 0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA 0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA 0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA 0x82CF
#define GL_VIEW_COMPATIBILITY_CLASS 0x82B6
#define GL_WAIT_FAILED 0x911D
#define GL_WRITE_ONLY 0x88B9
#define GL_XOR 0x1506
#define GL_ZERO 0
#define GL_ZERO_TO_ONE 0x935F


#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2018 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
 *
 * The master copy of khrplatform.h is maintained in the Khronos EGL
 * Registry repository at https://github.com/KhronosGroup/EGL-Registry
 * The last semantic modification to khrplatform.h was at commit ID:
 *      67a3e0864c2d75ea5287b9f3d2eb74a745936692
 *
 * Adopters may modify this file to suit their platform. Adopters are
 * encouraged to submit platform specific modifications to the Khronos
 * group so that they can be included in future versions of this file.
 * Please submit changes by filing pull requests or issues on
 * the EGL Registry repository linked above.
 *
 *
 * See the Implementer's Guidelines for information about where this file
 * should be located on your system and for more details of its use:
 *    http://www.khronos.org/registry/implementers_guide.pdf
 *
 * This file should be included as
 *        #include <KHR/khrplatform.h>
 * by Khronos client API header files that use its types and defines.
 *
 * The types in khrplatform.h should only be used to define API-specific types.
 *
 * Types defined in khrplatform.h:
 *    khronos_int8_t              signed   8  bit
 *    khronos_uint8_t             unsigned 8  bit
 *    khronos_int16_t             signed   16 bit
 *    khronos_uint16_t            unsigned 16 bit
 *    khronos_int32_t             signed   32 bit
 *    khronos_uint32_t            unsigned 32 bit
 *    khronos_int64_t             signed   64 bit
 *    khronos_uint64_t            unsigned 64 bit
 *    khronos_intptr_t            signed   same number of bits as a pointer
 *    khronos_uintptr_t           unsigned same number of bits as a pointer
 *    khronos_ssize_t             signed   size
 *    khronos_usize_t             unsigned size
 *    khronos_float_t             signed   32 bit floating point
 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
 *                                         nanoseconds
 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
 *    khronos_boolean_enum_t      enumerated boolean type. This should
 *      only be used as a base type when a client API's boolean type is
 *      an enum. Client APIs which use an integer or other type for
 *      booleans cannot use this as the base type for their boolean.
 *
 * Tokens defined in khrplatform.h:
 *
 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
 *
 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
 *
 * Calling convention macros defined in this file:
 *    KHRONOS_APICALL
 *    KHRONOS_GLAD_API_PTR
 *    KHRONOS_APIATTRIBUTES
 *
 * These may be used in function prototypes as:
 *
 *      KHRONOS_APICALL void KHRONOS_GLAD_API_PTR funcname(
 *                                  int arg1,
 *                                  int arg2) KHRONOS_APIATTRIBUTES;
 */

#if defined(__SCITECH_SNAP__) && !defined(KHRONOS_STATIC)
#   define KHRONOS_STATIC 1
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APICALL
 *-------------------------------------------------------------------------
 * This precedes the return type of the function in the function prototype.
 */
#if defined(KHRONOS_STATIC)
    /* If the preprocessor constant KHRONOS_STATIC is defined, make the
     * header compatible with static linking. */
#   define KHRONOS_APICALL
#elif defined(_WIN32)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_GLAD_API_PTR
 *-------------------------------------------------------------------------
 * This follows the return type of the function  and precedes the function
 * name in the function prototype.
 */
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
    /* Win32 but not WinCE */
#   define KHRONOS_GLAD_API_PTR __stdcall
#else
#   define KHRONOS_GLAD_API_PTR
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIATTRIBUTES
 *-------------------------------------------------------------------------
 * This follows the closing parenthesis of the function prototype arguments.
 */
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
 * basic type definitions
 *-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
 * Using <stdint.h>
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1
/*
 * To support platform where unsigned long cannot be used interchangeably with
 * inptr_t (e.g. CHERI-extended ISAs), we can use the stdint.h intptr_t.
 * Ideally, we could just use (u)intptr_t everywhere, but this could result in
 * ABI breakage if khronos_uintptr_t is changed from unsigned long to
 * unsigned long long or similar (this results in different C++ name mangling).
 * To avoid changes for existing platforms, we restrict usage of intptr_t to
 * platforms where the size of a pointer is larger than the size of long.
 */
#if defined(__SIZEOF_LONG__) && defined(__SIZEOF_POINTER__)
#if __SIZEOF_POINTER__ > __SIZEOF_LONG__
#define KHRONOS_USE_INTPTR_T
#endif
#endif

#elif defined(__VMS ) || defined(__sgi)

/*
 * Using <inttypes.h>
 */
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
 * Win32
 */
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
 * Sun or Digital
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
 * Hypothetical platform with no float or int64 support
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
 * Generic fallback
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
 * Types that are (so far) the same on all platforms
 */
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
 * Types that differ between LLP64 and LP64 architectures - in LLP64,
 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
 * to be the only LLP64 architecture in current use.
 */
#ifdef KHRONOS_USE_INTPTR_T
typedef intptr_t               khronos_intptr_t;
typedef uintptr_t              khronos_uintptr_t;
#elif defined(_WIN64)
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
#endif

#if defined(_WIN64)
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
 * Float type
 */
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
 *
 * These types can be used to represent a time interval in nanoseconds or
 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
 * of nanoseconds since some arbitrary system event (e.g. since the last
 * time the system booted).  The Unadjusted System Time is an unsigned
 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
 * may be either signed or unsigned.
 */
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
 * Dummy value used to pad enum types to 32 bits.
 */
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
 * Enumerated boolean type
 *
 * Values other than zero should be considered to be true.  Therefore
 * comparisons should not be made against KHRONOS_TRUE.
 */
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;
#ifdef __APPLE__
typedef void *GLhandleARB;
#else
typedef unsigned int GLhandleARB;
#endif
typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_intptr_t GLintptr;
#else
typedef khronos_intptr_t GLintptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_intptr_t GLintptrARB;
#else
typedef khronos_intptr_t GLintptrARB;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_ssize_t GLsizeiptr;
#else
typedef khronos_ssize_t GLsizeiptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_ssize_t GLsizeiptrARB;
#else
typedef khronos_ssize_t GLsizeiptrARB;
#endif
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (GLAD_API_PTR *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (GLAD_API_PTR *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (GLAD_API_PTR *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (GLAD_API_PTR *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void (GLAD_API_PTR *GLVULKANPROCNV)(void);


#define GL_VERSION_1_0 1
GLAD_API_CALL int GLAD_GL_VERSION_1_0;
#define GL_VERSION_1_1 1
GLAD_API_CALL int GLAD_GL_VERSION_1_1;
#define GL_VERSION_1_2 1
GLAD_API_CALL int GLAD_GL_VERSION_1_2;
#define GL_VERSION_1_3 1
GLAD_API_CALL int GLAD_GL_VERSION_1_3;
#define GL_VERSION_1_4 1
GLAD_API_CALL int GLAD_GL_VERSION_1_4;
#define GL_VERSION_1_5 1
GLAD_API_CALL int GLAD_GL_VERSION_1_5;
#define GL_VERSION_2_0 1
GLAD_API_CALL int GLAD_GL_VERSION_2_0;
#define GL_VERSION_2_1 1
GLAD_API_CALL int GLAD_GL_VERSION_2_1;
#define GL_VERSION_3_0 1
GLAD_API_CALL int GLAD_GL_VERSION_3_0;
#define GL_VERSION_3_1 1
GLAD_API_CALL int GLAD_GL_VERSION_3_1;
#define GL_VERSION_3_2 1
GLAD_API_CALL int GLAD_GL_VERSION_3_2;
#define GL_VERSION_3_3 1
GLAD_API_CALL int GLAD_GL_VERSION_3_3;
#define GL_VERSION_4_0 1
GLAD_API_CALL int GLAD_GL_VERSION_4_0;
#define GL_VERSION_4_1 1
GLAD_API_CALL int GLAD_GL_VERSION_4_1;
#define GL_VERSION_4_2 1
GLAD_API_CALL int GLAD_GL_VERSION_4_2;
#define GL_VERSION_4_3 1
GLAD_API_CALL int GLAD_GL_VERSION_4_3;
#define GL_VERSION_4_4 1
GLAD_API_CALL int GLAD_GL_VERSION_4_4;
#define GL_VERSION_4_5 1
GLAD_API_CALL int GLAD_GL_VERSION_4_5;
#define GL_VERSION_4_6 1
GLAD_API_CALL int GLAD_GL_VERSION_4_6;
#define GL_EXT_texture_lod_bias 1
GLAD_API_CALL int GLAD_GL_EXT_texture_lod_bias;


typedef void (GLAD_API_PTR *PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
typedef void (GLAD_API_PTR *PFNGLACTIVETEXTUREPROC)(GLenum texture);
typedef void (GLAD_API_PTR *PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (GLAD_API_PTR *PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
typedef void (GLAD_API_PTR *PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (GLAD_API_PTR *PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXARRAYPROC)(GLuint array);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (GLAD_API_PTR *PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (GLAD_API_PTR *PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
typedef void (GLAD_API_PTR *PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
typedef void (GLAD_API_PTR *PFNGLCLEARPROC)(GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHPROC)(GLdouble depth);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHFPROC)(GLfloat d);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARSTENCILPROC)(GLint s);
typedef void (GLAD_API_PTR *PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);
typedef GLenum (GLAD_API_PTR *PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GLAD_API_PTR *PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (GLAD_API_PTR *PFNGLCOMPILESHADERPROC)(GLuint shader);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (GLAD_API_PTR *PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef GLuint (GLAD_API_PTR *PFNGLCREATEPROGRAMPROC)(void);
typedef void (GLAD_API_PTR *PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint * samplers);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROC)(GLenum type);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const* strings);
typedef void (GLAD_API_PTR *PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLCULLFACEPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void * userParam);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
typedef void (GLAD_API_PTR *PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLDELETESHADERPROC)(GLuint shader);
typedef void (GLAD_API_PTR *PFNGLDELETESYNCPROC)(GLsync sync);
typedef void (GLAD_API_PTR *PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLDEPTHFUNCPROC)(GLenum func);
typedef void (GLAD_API_PTR *PFNGLDEPTHMASKPROC)(GLboolean flag);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
typedef void (GLAD_API_PTR *PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (GLAD_API_PTR *PFNGLDISABLEPROC)(GLenum cap);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEIPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERPROC)(GLenum buf);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLENABLEPROC)(GLenum cap);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEIPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENDCONDITIONALRENDERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDQUERYPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENDTRANSFORMFEEDBACKPROC)(void);
typedef GLsync (GLAD_API_PTR *PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLFINISHPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFLUSHPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLFRONTFACEPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLGENBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLGENQUERIESPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLGENTEXTURESPROC)(GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLGENERATEMIPMAPPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
typedef GLint (GLAD_API_PTR *PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void * img);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);
typedef GLuint (GLAD_API_PTR *PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble * data);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble * data);
typedef GLenum (GLAD_API_PTR *PFNGLGETERRORPROC)(void);
typedef void (GLAD_API_PTR *PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETFLOATVPROC)(GLenum pname, GLfloat * data);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef GLenum (GLAD_API_PTR *PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
typedef void (GLAD_API_PTR *PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERVPROC)(GLenum pname, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat * val);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTPTRLABELPROC)(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETPOINTERVPROC)(GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint * params);
typedef GLuint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision);
typedef void (GLAD_API_PTR *PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
typedef void (GLAD_API_PTR *PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint * params);
typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGPROC)(GLenum name);
typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
typedef GLuint (GLAD_API_PTR *PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 * param);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint * param);
typedef GLuint (GLAD_API_PTR *PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar * uniformBlockName);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
typedef GLint (GLAD_API_PTR *PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLHINTPROC)(GLenum target, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments);
typedef void (GLAD_API_PTR *PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments);
typedef void (GLAD_API_PTR *PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
typedef GLboolean (GLAD_API_PTR *PFNGLISBUFFERPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDPROC)(GLenum cap);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
typedef GLboolean (GLAD_API_PTR *PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPROC)(GLuint program);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef GLboolean (GLAD_API_PTR *PFNGLISQUERYPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISSAMPLERPROC)(GLuint sampler);
typedef GLboolean (GLAD_API_PTR *PFNGLISSHADERPROC)(GLuint shader);
typedef GLboolean (GLAD_API_PTR *PFNGLISSYNCPROC)(GLsync sync);
typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREPROC)(GLuint texture);
typedef GLboolean (GLAD_API_PTR *PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISVERTEXARRAYPROC)(GLuint array);
typedef void (GLAD_API_PTR *PFNGLLINEWIDTHPROC)(GLfloat width);
typedef void (GLAD_API_PTR *PFNGLLINKPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLLOGICOPPROC)(GLenum opcode);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);
typedef void (GLAD_API_PTR *PFNGLOBJECTPTRLABELPROC)(const void * ptr, GLsizei length, const GLchar * label);
typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPOINTSIZEPROC)(GLfloat size);
typedef void (GLAD_API_PTR *PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
typedef void (GLAD_API_PTR *PFNGLPOPDEBUGGROUPPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar * message);
typedef void (GLAD_API_PTR *PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
typedef void (GLAD_API_PTR *PFNGLREADBUFFERPROC)(GLenum src);
typedef void (GLAD_API_PTR *PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
typedef void (GLAD_API_PTR *PFNGLRELEASESHADERCOMPILERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
typedef void (GLAD_API_PTR *PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (GLAD_API_PTR *PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
typedef void (GLAD_API_PTR *PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
typedef void (GLAD_API_PTR *PFNGLSPECIALIZESHADERPROC)(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILMASKPROC)(GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBARRIERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint * indices);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPBUFFERPROC)(GLenum target);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);

GLAD_API_CALL PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;
/**
* @name glActiveShaderProgram - set the active program object for a program pipeline object
* @usage
* @code void glActiveShaderProgram(GLuint pipeline, GLuint program); @endcode
* @param pipeline Specifies the program pipeline object to set the active program object for.
* @param program Specifies the program object to set as the active program pipeline object <em class="parameter"><b>pipeline</b></em>.
* @description
* 	glActiveShaderProgram sets the linked program named by program to be the active program for the program pipeline object
* pipeline. The active program in the active program pipeline object is the target of calls to glUniform when no program
* has been made current through a call to glUseProgram.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
* @errors GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked.
*
*/
#define glActiveShaderProgram glad_glActiveShaderProgram
GLAD_API_CALL PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
/**
* @name glActiveTexture - select active texture unit
* @usage
* @code void glActiveTexture(GLenum texture); @endcode
* @param texture Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least
*                80. <em class="parameter"><b>texture</b></em> must be one of <b>GL_TEXTURE</b><span class="emphasis"><em>i</em></span>,
*                where <span class="emphasis"><em>i</em></span> ranges from zero to the value of <b>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</b>
*                minus one. The initial value is <b>GL_TEXTURE0</b>.
* @description
* 	glActiveTexture selects which texture unit subsequent texture state calls will affect.  The number of texture units an
* implementation supports is implementation dependent, but must be at least 80.<br>
*
*
* @errors GL_INVALID_ENUM is generated if texture is not one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
*         minus one.
*
*/
#define glActiveTexture glad_glActiveTexture
GLAD_API_CALL PFNGLATTACHSHADERPROC glad_glAttachShader;
/**
* @name glAttachShader - Attaches a shader object to a program object
* @usage
* @code void glAttachShader(GLuint program, GLuint shader); @endcode
* @param program Specifies the program object to which a shader object will be attached.
* @param shader Specifies the shader object that is to be attached.
* @description
* 	In order to create a complete shader program, there must be a way to specify the list of things that will be linked together.
* Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be
* attached to that program object. glAttachShader attaches the shader object specified by shader to the program object specified
* by program. This indicates that shader will be included in link operations that will be performed on program.<br>
* 	All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program
* object. It is permissible to attach a shader object to a program object before source code has been loaded into the
* shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the
* same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to
* more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged
* for deletion, and deletion will not occur until glDetachShader is called to detach it from all program objects to which
* it is attached.<br>
*
*
* @errors GL_INVALID_VALUE is generated if either program or shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_OPERATION is generated if shader is already attached to program.
*
*/
#define glAttachShader glad_glAttachShader
GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
/**
* @name glBeginConditionalRender - start conditional rendering
* @usage
* @code void glBeginConditionalRender(GLuint id, GLenum mode); @endcode
* @param id Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
* @param mode Specifies how <b>glBeginConditionalRender</b> interprets the results of the occlusion query.
* @description
* 	Conditional rendering is started using glBeginConditionalRender and ended using glEndConditionalRender. During conditional
* rendering, all vertex array commands, as well as glClear and glClearBuffer have no effect if the (GL_SAMPLES_PASSED)
* result of the query object id is zero, or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE. The results of commands setting
* the current vertex state, such as glVertexAttrib are undefined. If the (GL_SAMPLES_PASSED) result is non-zero or if
* the (GL_ANY_SAMPLES_PASSED) result is GL_TRUE, such commands are not discarded. The id parameter to glBeginConditionalRender
* must be the name of a query object previously returned from a call to glGenQueries. mode specifies how the results
* of the query object are to be interpreted. If mode is GL_QUERY_WAIT, the GL waits for the results of the query to be available
* and then uses the results to determine if subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT,
* the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.<br>
* 	If mode is GL_QUERY_BY_REGION_WAIT, the GL will also wait for occlusion query results and discard rendering commands if
* the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed,
* but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample
* count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering
* command results may not be discarded for any samples that contributed to the occlusion query sample count. If mode
* is GL_QUERY_BY_REGION_NO_WAIT, the GL operates as in GL_QUERY_BY_REGION_WAIT, but may choose to unconditionally execute
* the subsequent rendering commands without waiting for the query to complete.<br>
*
* @note glBeginConditionalRender and glEndConditionalRender are available only if the GL version is 3.0 or greater.
* @note The GL_ANY_SAMPLES_PASSED query result is available only if the GL version is 3.3 or greater.
*
* @errors GL_INVALID_VALUE is generated if id is not the name of an existing query object.
* @errors GL_INVALID_ENUM is generated if mode is not one of the accepted tokens.
* @errors GL_INVALID_OPERATION is generated if glBeginConditionalRender is called while conditional rendering is active, or if glEndConditionalRender
*         is called while conditional rendering is inactive.
* @errors GL_INVALID_OPERATION is generated if id is the name of a query object with a target other than GL_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED.
* @errors GL_INVALID_OPERATION is generated if id is the name of a query currently in progress.
*
*/
#define glBeginConditionalRender glad_glBeginConditionalRender
GLAD_API_CALL PFNGLBEGINQUERYPROC glad_glBeginQuery;
/**
* @name glBeginQuery - delimit the boundaries of a query object
* @usage
* @code void glBeginQuery(GLenum target, GLuint id); @endcode
* @param target Specifies the target type of query object established between <b>glBeginQuery</b> and the subsequent  <b>glEndQuery</b>.
*               The symbolic constant must be one of <b>GL_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</b>,
*               <b>GL_PRIMITIVES_GENERATED</b>, <b>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</b>, or <b>GL_TIME_ELAPSED</b>.
* @param id Specifies the name of a query object.
* @description
* 	glBeginQuery and  glEndQuery delimit the boundaries of a query object.  query must be a name previously returned from a
* call to glGenQueries. If a query object with name id does not yet exist it is created with the type determined by target.
* target must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,
* or GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows.<br>
* 	If target is GL_SAMPLES_PASSED, id must be an unused name, or the name of an existing occlusion query object. When glBeginQuery
* is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment the
* counter for every sample that passes the depth test.  If the value of GL_SAMPLE_BUFFERS is 0, then the samples-passed count
* is incremented by 1 for each fragment. If the value of GL_SAMPLE_BUFFERS is 1, then the samples-passed count is incremented
* by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase
* the samples-passed count by the value of GL_SAMPLES if any sample in the fragment is covered. When glEndQuery is
* executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by calling
* glGetQueryObject with pnameGL_QUERY_RESULT.<br>
* 	If target is GL_ANY_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED_CONSERVATIVE, id must be an unused name, or the name of an
* existing boolean occlusion query object. When glBeginQuery is executed, the query object's samples-passed flag is reset
* to GL_FALSE. Subsequent rendering causes the flag to be set to GL_TRUE if any sample passes the depth test in the case of
* GL_ANY_SAMPLES_PASSED, or if the implementation determines that any sample might pass the depth test in the case of GL_ANY_SAMPLES_PASSED_CONSERVATIVE.
* The implementation may be able to provide a more efficient test in the case of GL_ANY_SAMPLES_PASSED_CONSERVATIVE
* if some false positives are acceptable to the application.  When glEndQuery is executed, the
* samples-passed flag is assigned to the query object's result value.  This value can be queried by calling glGetQueryObject
* with pnameGL_QUERY_RESULT.<br>
* 	If target is GL_PRIMITIVES_GENERATED, id must be an unused name, or the name of an existing primitive query object previously
* bound to the GL_PRIMITIVES_GENERATED query binding. When glBeginQuery is executed, the query object's primitives-generated
* counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is emitted
* from the geometry shader, or from the vertex shader if no geometry shader is present.  When glEndQuery is executed, the
* primitives-generated counter is assigned to the query object's result value.  This value can be queried by calling glGetQueryObject
* with pnameGL_QUERY_RESULT.<br>
* 	If target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, id must be an unused name, or the name of an existing primitive
* query object previously bound to the GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN query binding. When glBeginQuery is executed,
* the query object's primitives-written counter is reset to 0.  Subsequent rendering will increment the counter once for
* every vertex that is written into the bound transform feedback buffer(s).  If transform feedback mode is not activated
* between the call to glBeginQuery and glEndQuery, the counter will not be incremented.  When glEndQuery is executed, the
* primitives-written counter is assigned to the query object's result value.  This value can be queried by calling glGetQueryObject
* with pnameGL_QUERY_RESULT.<br>
* 	If target is GL_TIME_ELAPSED, id must be an unused name, or the name of an existing timer query object previously bound
* to the GL_TIME_ELAPSED query binding. When glBeginQuery is executed, the query object's time counter is reset to 0.  When
* glEndQuery is executed, the elapsed server time that has passed since the call to glBeginQuery is written into the query
* object's time counter.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.<br>
* 	Querying the GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the query object has completed
* and the result is available.  GL_QUERY_RESULT_AVAILABLE can be queried to determine if the result is immediately
* available or if the rendering is not yet complete.<br>
*
* @note If the query target's count exceeds the maximum value representable in the number of available bits, as reported by glGetQueryiv
*       with target set to the appropriate query target and pnameGL_QUERY_COUNTER_BITS, the count becomes undefined.
* @note An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.
* @note When GL_SAMPLE_BUFFERS is 0, the samples-passed counter of an occlusion query will increment once for each fragment that
*       passes the depth test.  When GL_SAMPLE_BUFFERS is 1, an implementation may either increment the samples-passed counter
*       individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all
*       samples of a fragment if any one of them passes the depth test.
* @note The query targets GL_ANY_SAMPLES_PASSED, and GL_TIME_ELAPSED are availale only if the GL version is 3.3 or higher.
* @note The query target GL_ANY_SAMPLES_PASSED_CONSERVATIVE is available only of the GL version is 4.3 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the accepted tokens.
* @errors GL_INVALID_OPERATION is generated if glBeginQuery is executed while a query object of the same target is already active.
* @errors GL_INVALID_OPERATION is generated if  glEndQuery is executed when a query object of the same target is not active.
* @errors GL_INVALID_OPERATION is generated if id is 0.
* @errors GL_INVALID_OPERATION is generated if id is the name of an already active query object.
* @errors GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target.
*
*/
#define glBeginQuery glad_glBeginQuery
GLAD_API_CALL PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;
/**
* @name glBeginQueryIndexed, glEndQueryIndexed - delimit the boundaries of a query object on an indexed target
* @usage
* @code void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id); @endcode
* @param target Specifies the target type of query object established between <b>glBeginQueryIndexed</b> and the subsequent  <b>glEndQueryIndexed</b>.
*               The symbolic constant must be one of <b>GL_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED</b>, <b>GL_PRIMITIVES_GENERATED</b>,
*               <b>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</b>, or <b>GL_TIME_ELAPSED</b>.
* @param index Specifies the index of the query target upon which to begin the query.
* @param id Specifies the name of a query object.
* @description
* 	glBeginQueryIndexed and  glEndQueryIndexed delimit the boundaries of a query object.  query must be a name previously returned
* from a call to glGenQueries. If a query object with name id does not yet exist it is created with the type determined
* by target. target must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,
* or GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows.<br>
* 	index specifies the index of the query target and must be between a target-specific maximum.<br>
* 	If target is GL_SAMPLES_PASSED, id must be an unused name, or the name of an existing occlusion query object. When glBeginQueryIndexed
* is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment
* the counter for every sample that passes the depth test.  If the value of GL_SAMPLE_BUFFERS is 0, then the samples-passed
* count is incremented by 1 for each fragment. If the value of GL_SAMPLE_BUFFERS is 1, then the samples-passed count
* is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead
* increase the samples-passed count by the value of GL_SAMPLES if any sample in the fragment is covered. When glEndQueryIndexed
* is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried
* by calling glGetQueryObject with pnameGL_QUERY_RESULT. When target is GL_SAMPLES_PASSED, index must be zero.<br>
* 	If target is GL_ANY_SAMPLES_PASSED, id must be an unused name, or the name of an existing boolean occlusion query object.
* When glBeginQueryIndexed is executed, the query object's samples-passed flag is reset to GL_FALSE. Subsequent rendering
* causes the flag to be set to GL_TRUE if any sample passes the depth test.  When glEndQueryIndexed is executed, the samples-passed
* flag is assigned to the query object's result value.  This value can be queried by calling glGetQueryObject
* with pnameGL_QUERY_RESULT. When target is GL_ANY_SAMPLES_PASSED, index must be zero.<br>
* 	If target is GL_PRIMITIVES_GENERATED, id must be an unused name, or the name of an existing primitive query object previously
* bound to the GL_PRIMITIVES_GENERATED query binding. When glBeginQueryIndexed is executed, the query object's primitives-generated
* counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is emitted
* from the geometry shader to the stream given by index, or from the vertex shader if index is zero and no geometry
* shader is present. When glEndQueryIndexed is executed, the primitives-generated counter for stream index is assigned to
* the query object's result value.  This value can be queried by calling glGetQueryObject with pname GL_QUERY_RESULT. When
* target is GL_PRIMITIVES_GENERATED, index must be less than the value of GL_MAX_VERTEX_STREAMS.<br>
* 	If target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, id must be an unused name, or the name of an existing primitive
* query object previously bound to the GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN query binding. When glBeginQueryIndexed is
* executed, the query object's primitives-written counter for the stream specified by index is reset to 0.  Subsequent rendering
* will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for
* stream index.  If transform feedback mode is not activated between the call to glBeginQueryIndexed and glEndQueryIndexed,
* the counter will not be incremented.  When glEndQueryIndexed is executed, the primitives-written counter for stream index
* is assigned to the query object's result value.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
* When target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, index must be less than the value of GL_MAX_VERTEX_STREAMS.<br>
* 	If target is GL_TIME_ELAPSED, id must be an unused name, or the name of an existing timer query object previously bound
* to the GL_TIME_ELAPSED query binding. When glBeginQueryIndexed is executed, the query object's time counter is reset to
* 0.  When glEndQueryIndexed is executed, the elapsed server time that has passed since the call to glBeginQueryIndexed is
* written into the query object's time counter.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
* When target is GL_TIME_ELAPSED, index must be zero.<br>
* 	Querying the GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the query object has completed
* and the result is available.  GL_QUERY_RESULT_AVAILABLE can be queried to determine if the result is immediately
* available or if the rendering is not yet complete.<br>
*
* @note If the query target's count exceeds the maximum value representable in the number of available bits, as reported by glGetQueryiv
*       with target set to the appropriate query target and pnameGL_QUERY_COUNTER_BITS, the count becomes undefined.
* @note An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.
* @note When GL_SAMPLE_BUFFERS is 0, the samples-passed counter of an occlusion query will increment once for each fragment that
*       passes the depth test.  When GL_SAMPLE_BUFFERS is 1, an implementation may either increment the samples-passed counter
*       individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all
*       samples of a fragment if any one of them passes the depth test.
* @note Calling glBeginQuery or glEndQuery is equivalent to calling glBeginQueryIndexed or glEndQueryIndexed with index set to zero,
*       respectively.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the accepted tokens.
* @errors GL_INVALID_VALUE is generated if index is greater than the query target-specific maximum.
* @errors GL_INVALID_OPERATION is generated if glBeginQueryIndexed is executed while a query object of the same target is already
*         active.
* @errors GL_INVALID_OPERATION is generated if  glEndQueryIndexed is executed when a query object of the same target is not active.
* @errors GL_INVALID_OPERATION is generated if id is 0.
* @errors GL_INVALID_OPERATION is generated if id is the name of an already active query object.
* @errors GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target.
*
*/
#define glBeginQueryIndexed glad_glBeginQueryIndexed
GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
/**
* @name glBeginTransformFeedback - start transform feedback operation
* @usage
* @code void glBeginTransformFeedback(GLenum primitiveMode); @endcode
* @param primitiveMode Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
* @description
* 	Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry
* shader). Transform feedback is said to be active after a call to glBeginTransformFeedback until a subsequent call to
*  glEndTransformFeedback. Transform feedback commands must be paired.<br>
* 	If no geometry shader is present, while transform feedback is active the mode parameter to glDrawArrays must match those
* specified in the following table:<br>
* 	If a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following
* table:<br>
*
* @note Geometry shaders, and the GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY, GL_LINES_ADJACENCY and GL_LINE_STRIP_ADJACENCY
*       primtive modes are available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_OPERATION is generated if glBeginTransformFeedback is executed while transform feedback is active.
* @errors GL_INVALID_OPERATION is generated if glEndTransformFeedback is executed while transform feedback is not active.
* @errors GL_INVALID_OPERATION is generated by glDrawArrays if no geometry shader is present, transform feedback is active and mode
*         is not one of the allowed modes.
* @errors GL_INVALID_OPERATION is generated by glDrawArrays if a geometry shader is present, transform feedback is active and the
*         output primitive type of the geometry shader does not match the transform feedback primitiveMode.
* @errors GL_INVALID_OPERATION is generated by glBeginTransformFeedback if any binding point used in transform feedback mode does
*         not have a buffer object bound.
* @errors GL_INVALID_OPERATION is generated by glBeginTransformFeedback if no binding points would be used, either because no program
*         object is active of because the active program object has specified no varying variables to record.
*
*/
#define glBeginTransformFeedback glad_glBeginTransformFeedback
GLAD_API_CALL PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
/**
* @name glBindAttribLocation - Associates a generic vertex attribute index with a named attribute variable
* @usage
* @code void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name); @endcode
* @param program Specifies the handle of the program object in which the association is to be made.
* @param index Specifies the index of the generic vertex attribute to be bound.
* @param name Specifies a null terminated string containing the name of the vertex shader attribute variable to which <em class="parameter"><b>index</b></em>
*             is to be bound.
* @description
* 	glBindAttribLocation is used to associate a user-defined attribute variable in the program object specified by program
* with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string
* in name. The generic vertex attribute index to be bound to this variable is specified by index. When program is made
* part of current state, values provided via the generic vertex attribute index will modify the value of the user-defined
* attribute variable specified by name.<br>
* 	If name refers to a matrix attribute variable, index refers to the first column of the matrix. Other matrix columns are
* then automatically bound to locations index+1 for a matrix of type mat2; index+1 and index+2 for a matrix of type mat3;
* and index+1, index+2, and index+3 for a matrix of type mat4.<br>
* 	This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic
* variables that are numbered from zero to the value of GL_MAX_VERTEX_ATTRIBS minus one. The values sent to each generic attribute
* index are part of current state. If a different program object is made current by calling glUseProgram, the generic
* vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program
* object that are also bound to index.<br>
* 	Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time
* by calling glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program
* object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried)
* until the next link command occurs.<br>
* 	Any attribute binding that occurs after the program object has been linked will not take effect until the next time the
* program object is linked.<br>
*
* @note glBindAttribLocation can be called before any vertex shader objects are bound to the specified program object. It is also
*       permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.
* @note If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple
*       indices, but you can bind multiple user-defined attribute variables to the same index.
* @note Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index.
*       This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program,
*       or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location.
*       The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work
*       only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing.
* @note Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram is called. The locations
*       assigned can be queried by calling glGetAttribLocation.
* @note OpenGL copies the name string when glBindAttribLocation is called, so an application may free its copy of the name string
*       immediately after the function returns.
* @note Generic attribute locations may be specified in the shader source text using a location layout qualifier. In this case,
*       the location of the attribute specified in the shader's source takes precedence and may be queried by calling glGetAttribLocation.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
*
*/
#define glBindAttribLocation glad_glBindAttribLocation
GLAD_API_CALL PFNGLBINDBUFFERPROC glad_glBindBuffer;
/**
* @name glBindBuffer - bind a named buffer object
* @usage
* @code void glBindBuffer(GLenum target, GLuint buffer); @endcode
* @param target Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following
*               table:
* @param buffer Specifies the name of a buffer object.
* @description
* 	glBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with target set to one of
* the accepted symbolic constants and buffer set to the name of a buffer object binds that buffer object name to the target.
* If no buffer object with name buffer exists, one is created with that name. When a buffer object is bound to a target,
* the previous binding for that target is automatically broken.<br>
* 	Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer
* object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client
* memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding
* buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts
* share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces
* functions.<br>
* 	glGenBuffers must be used to generate a set of unused buffer object names.<br>
* 	The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with GL_READ_WRITE
* access and GL_STATIC_DRAW usage.<br>
* 	While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer
* object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name
* zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates
* an GL_INVALID_OPERATION error.<br>
* 	When a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, the vertex array pointer parameter is interpreted
* as an offset within the buffer object measured in basic machine units.<br>
* 	When a non-zero buffer object is bound to the GL_DRAW_INDIRECT_BUFFER target, parameters for draws issued through glDrawArraysIndirect
* and glDrawElementsIndirect are sourced from the specified offset in that buffer object's data store.<br>
* 	When a non-zero buffer object is bound to the GL_DISPATCH_INDIRECT_BUFFER target, the parameters for compute dispatches
* issued through glDispatchComputeIndirect are sourced from the specified offset in that buffer object's data store.<br>
* 	While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the indices parameter of glDrawElements,
* glDrawElementsInstanced, glDrawElementsBaseVertex, glDrawRangeElements, glDrawRangeElementsBaseVertex, glMultiDrawElements,
* or glMultiDrawElementsBaseVertex is interpreted as an offset within the buffer object measured in basic machine units.<br>
* 	While a non-zero buffer object is bound to the GL_PIXEL_PACK_BUFFER target, the following commands are affected: glGetCompressedTexImage,
* glGetTexImage, and glReadPixels. The pointer parameter is interpreted as an offset within the buffer
* object measured in basic machine units.<br>
* 	While a non-zero buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target, the following commands are affected: glCompressedTexImage1D,
* glCompressedTexImage2D, glCompressedTexImage3D, glCompressedTexSubImage1D, glCompressedTexSubImage2D,
* glCompressedTexSubImage3D, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and glTexSubImage3D.
* The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.<br>
* 	The buffer targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided to allow glCopyBufferSubData to be used without
* disturbing the state of other bindings. However, glCopyBufferSubData may be used with any pair of buffer binding points.<br>
* 	The GL_TRANSFORM_FEEDBACK_BUFFER buffer binding point may be passed to glBindBuffer, but will not directly affect transform
* feedback state. Instead, the indexed GL_TRANSFORM_FEEDBACK_BUFFER bindings must be used through a call to glBindBufferBase
* or glBindBufferRange. This will affect the generic GL_TRANSFORM_FEEDBACK_BUFFER binding.<br>
* 	Likewise, the GL_UNIFORM_BUFFER, GL_ATOMIC_COUNTER_BUFFER and GL_SHADER_STORAGE_BUFFER buffer binding points may be used,
* but do not directly affect uniform buffer, atomic counter buffer or shader storage buffer state, respectively. glBindBufferBase
* or glBindBufferRange must be used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader
* storage buffer binding point.<br>
* 	The GL_QUERY_BUFFER binding point is used to specify a buffer object that is to receive the results of query objects through
* calls to the glGetQueryObject family of commands.<br>
* 	A buffer object binding created with glBindBuffer remains active until a different buffer object name is bound to the same
* target, or until the bound buffer object is deleted with glDeleteBuffers.<br>
* 	Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may
* make choices about how to optimize the storage of a buffer object based on its initial binding target.<br>
*
* @note The GL_COPY_READ_BUFFER, GL_UNIFORM_BUFFER and GL_TEXTURE_BUFFER targets are available only if the GL version is 3.1 or
*       greater.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if buffer is not a name previously returned from a call to glGenBuffers.
*
*/
#define glBindBuffer glad_glBindBuffer
GLAD_API_CALL PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
/**
* @name glBindBufferBase - bind a buffer object to an indexed buffer target
* @usage
* @code void glBindBufferBase(GLenum target, GLuint index, GLuint buffer); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b> or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param index Specify the index of the binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param buffer The name of a buffer object to bind to the specified binding point.
* @description
* 	glBindBufferBase binds the buffer object buffer to the binding point at index index of the array of targets specified by
* target. Each target represents an indexed array of buffer binding points, as well as a single general binding point that
* can be used by other buffer manipulation functions such as glBindBuffer or glMapBuffer. In addition to binding buffer
* to the indexed buffer binding target, glBindBufferBase also binds buffer to the generic buffer binding point specified
* by target.<br>
*
* @note Calling glBindBufferBase is equivalent to calling glBindBufferRange with offset zero and size equal to the size of the buffer.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_SHADER_STORAGE_BUFFER target is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points.
* @errors GL_INVALID_VALUE is generated if buffer does not have an associated data store, or if the size of that store is zero.
*
*/
#define glBindBufferBase glad_glBindBufferBase
GLAD_API_CALL PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
/**
* @name glBindBufferRange - bind a range within a buffer object to an indexed buffer target
* @usage
* @code void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b>, or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param index Specify the index of the binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param buffer The name of a buffer object to bind to the specified binding point.
* @param offset The starting offset in basic machine units into the buffer object <em class="parameter"><b>buffer</b></em>.
* @param size The amount of data in machine units that can be read from the buffer object while used as an indexed target.
* @description
* 	glBindBufferRange binds a range the buffer object buffer represented by offset and size to the binding point at index index
* of the array of targets specified by target. Each target represents an indexed array of buffer binding points, as well
* as a single general binding point that can be used by other buffer manipulation functions such as glBindBuffer or glMapBuffer.
* In addition to binding a range of buffer to the indexed buffer binding target, glBindBufferRange also binds the
* range to the generic buffer binding point specified by target.<br>
* 	offset specifies the offset in basic machine units into the buffer object buffer and size specifies the amount of data
* that can be read from the buffer object while used as an indexed target.<br>
*
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_SHADER_STORAGE_BUFFER target is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if target is not one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points.
* @errors GL_INVALID_VALUE is generated if size is less than or equal to zero, or if offset + size is greater than the value of GL_BUFFER_SIZE.
* @errors Additional errors may be generated if offset violates any target-specific alignmemt restrictions.
*
*/
#define glBindBufferRange glad_glBindBufferRange
GLAD_API_CALL PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;
/**
* @name glBindBuffersBase - bind one or more buffer objects to a sequence of indexed buffer targets
* @usage
* @code void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b> or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param first Specify the index of the first binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param count Specify the number of contiguous binding points to which to bind buffers.
* @param buffers A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or <b>NULL</b>.
* @description
* 	glBindBuffersBase binds a set of count buffer objects whose names are given in the array buffers to the count consecutive
* binding points starting from index first of the array of targets specified by target. If buffers is NULL then glBindBuffersBase
* unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
* it is equivalent to the following pseudo-code, which calls glBindBufferBase, with the exception that the non-indexed
* target is not changed by glBindBuffersBase:<br>
* 	Each entry in buffers will be checked individually and if found to be invalid, the state for that buffer binding index
* will not be changed and an error will be generated. However, the state for other buffer binding indices referenced by the
* command will still be updated.<br>
*
* @note glBindBuffersBase is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
*
*/
#define glBindBuffersBase glad_glBindBuffersBase
GLAD_API_CALL PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;
/**
* @name glBindBuffersRange - bind ranges of one or more buffer objects to a sequence of indexed buffer targets
* @usage
* @code void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLintptr *sizes); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b> or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param first Specify the index of the first binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param count Specify the number of contiguous binding points to which to bind buffers.
* @param buffers A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or <b>NULL</b>.
* @param offsets A pointer to an array of offsets into the corresponding buffer in <em class="parameter"><b>buffers</b></em> to bind, or
*                <b>NULL</b> if <em class="parameter"><b>buffers</b></em> is <b>NULL</b>.
* @param sizes A pointer to an array of sizes of the corresponding buffer in <em class="parameter"><b>buffers</b></em> to bind, or <b>NULL</b>
*              if <em class="parameter"><b>buffers</b></em> is <b>NULL</b>.
* @description
* 	glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the array buffers to the count
* consecutive binding points starting from index first of the array of targets specified by target. offsets specifies
* the address of an array containing count starting offsets within the buffers, and sizes specifies the address of an array
* of count sizes of the ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
* buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to
* the following pseudo-code, which calls glBindBufferRange, with the exception that the non-indexed target is not changed
* by glBindBuffersRange:<br>
* 	Each entry in buffers, offsets, and sizes will be checked individually and if found to be invalid, the state for that buffer
* binding index will not be changed and an error will be generated. However, the state for other buffer binding indices
* referenced by the command will still be updated.<br>
*
* @note glBindBuffersBase is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated by if any value in offsets is less than zero or if any value in sizes is less than zero.
* @errors GL_INVALID_VALUE is generated if any pair of values in offsets and sizes does not respectively satisfy the constraints described
*         for those parameters for the specified target.
*
*/
#define glBindBuffersRange glad_glBindBuffersRange
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
/**
* @name glBindFragDataLocation - bind a user-defined varying out variable to a fragment shader color number
* @usage
* @code void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name); @endcode
* @param program The name of the program containing varying out variable whose binding to modify
* @param colorNumber The color number to bind the user-defined varying out variable to
* @param name The name of the user-defined varying out variable whose binding to modify
* @description
* 	glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable name to fragment shader
* color number colorNumber for program program. If name was bound previously, its assigned binding is replaced with colorNumber.
* name must be a null-terminated string. colorNumber must be less than GL_MAX_DRAW_BUFFERS.<br>
* 	The bindings specified by glBindFragDataLocation have no effect until program is next linked. Bindings may be specified
* at any time after program has been created. Specifically, they may be specified before shader objects are attached to the
* program. Therefore, any name may be specified in name, including a name that is never used as a varying out variable
* in any fragment shader object. Names beginning with gl_ are reserved by the GL.<br>
* 	In addition to the errors generated by glBindFragDataLocation, the program program will fail to link if:<br>
* 	The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.<br>
* 	More than one varying out variable is bound to the same color number.<br>
*
* @note Varying out varyings may have indexed locations assigned explicitly in the shader text using a location layout qualifier.
*       If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any
*       location assigned with glBindFragDataLocation is ignored.
*
* @errors GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS.
* @errors GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix.
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glBindFragDataLocation glad_glBindFragDataLocation
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
/**
* @name glBindFragDataLocationIndexed - bind a user-defined varying out variable to a fragment shader color number and index
* @usage
* @code void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char *name); @endcode
* @param program The name of the program containing varying out variable whose binding to modify
* @param colorNumber The color number to bind the user-defined varying out variable to
* @param index The index of the color input to bind the user-defined varying out variable to
* @param name The name of the user-defined varying out variable whose binding to modify
* @description
* 	glBindFragDataLocationIndexed specifies that the varying out variable name in program should be bound to fragment color
* colorNumber when the program is next linked. index may be zero or one to specify that the color be used as either the first
* or second color input to the blend equation, respectively.<br>
* 	The bindings specified by glBindFragDataLocationIndexed have no effect until program is next linked. Bindings may be specified
* at any time after program has been created. Specifically, they may be specified before shader objects are attached
* to the program. Therefore, any name may be specified in name, including a name that is never used as a varying out variable
* in any fragment shader object. Names beginning with gl_ are reserved by the GL.<br>
* 	If name was bound previously, its assigned binding is replaced with colorNumber and index. name must be a null-terminated
* string. index must be less than or equal to one, and colorNumber must be less than the value of GL_MAX_DRAW_BUFFERS if
* index is zero, and less than the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS if index is greater than or equal to one.<br>
* 	In addition to the errors generated by glBindFragDataLocationIndexed, the program program will fail to link if:<br>
* 	The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.<br>
* 	More than one varying out variable is bound to the same color number.<br>
*
* @note Varying out varyings may have locations assigned explicitly in the shader text using a location layout qualifier. If a shader
*       statically assigns a location to a varying out variable in the shader text, that location is used and any location
*       assigned with glBindFragDataLocation is ignored.
*
* @errors GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS.
* @errors GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DUAL_SOURCE_DRAW_BUFFERS and index is greater
*         than or equal to one.
* @errors GL_INVALID_VALUE is generated if index is greater than one.
* @errors GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix.
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glBindFragDataLocationIndexed glad_glBindFragDataLocationIndexed
GLAD_API_CALL PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
/**
* @name glBindFramebuffer - bind a framebuffer to a framebuffer target
* @usage
* @code void glBindFramebuffer(GLenum target, GLuint framebuffer); @endcode
* @param target Specifies the framebuffer target of the binding operation.
* @param framebuffer Specifies the name of the framebuffer object to bind.
* @description
* 	glBindFramebuffer binds the framebuffer object with name framebuffer to the framebuffer target specified by target. target
* must be either GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. If a framebuffer object is bound to GL_DRAW_FRAMEBUFFER
* or GL_READ_FRAMEBUFFER, it becomes the target for rendering or readback operations, respectively, until it
* is deleted or another framebuffer is bound to the corresponding bind point. Calling glBindFramebuffer with target set
* to GL_FRAMEBUFFER binds framebuffer to both the read and draw framebuffer targets. framebuffer is the name of a framebuffer
* object previously returned from a call to glGenFramebuffers, or zero to break the existing binding of a framebuffer
* object to target.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
* @errors GL_INVALID_OPERATION is generated if framebuffer is not zero or the name of a framebuffer previously returned from a call
*         to glGenFramebuffers.
*
*/
#define glBindFramebuffer glad_glBindFramebuffer
GLAD_API_CALL PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;
/**
* @name glBindImageTexture - bind a level of a texture to an image unit
* @usage
* @code void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format); @endcode
* @param unit Specifies the index of the image unit to which to bind the texture
* @param texture Specifies the name of the texture to bind to the image unit.
* @param level Specifies the level of the texture that is to be bound.
* @param layered Specifies whether a layered texture binding is to be established.
* @param layer If <em class="parameter"><b>layered</b></em> is <b>GL_FALSE</b>, specifies the layer of <em class="parameter"><b>texture</b></em>
*              to be bound to the image unit. Ignored otherwise.
* @param access Specifies a token indicating the type of access that will be performed on the image.
* @param format Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.
* @description
* 	glBindImageTexture binds a single level of a texture to an image unit for the purpose of reading and writing it from shaders.
* unit specifies the zero-based index of the image unit to which to bind the texture level. texture specifies the name
* of an existing texture object to bind to the image unit. If texture is zero, then any existing binding to the image
* unit is broken. level specifies the level of the texture to bind to the image unit.<br>
* 	If texture is the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array texture, or a
* two-dimensional multisample array texture, then it is possible to bind either the entire array, or only a single layer of
* the array to the image unit. In such cases, if layered is GL_TRUE, the entire array is attached to the image unit and
* layer is ignored. However, if layered is GL_FALSE then layer specifies the layer of the array to attach to the image unit.<br>
* 	access specifies the access types to be performed by shaders and may be set to GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE
* to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in access
* (for example, if a shader writes to an image bound with access set to GL_READ_ONLY) will lead to undefined results,
* possibly including program termination.<br>
* 	format specifies the format that is to be used when performing formatted stores into the image from shaders. format must
* be compatible with the texture's internal format and must be one of the formats listed in the following table.<br>
* 	When a texture is bound to an image unit, the format parameter for the image unit need not exactly match the texture internal
* format as long as the formats are considered compatible as defined in the OpenGL Specification. The matching criterion
* used for a given texture may be determined by calling glGetTexParameter with value set to GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
* with return values of GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE and GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS, specifying
* matches by size and class, respectively.<br>
*
* @note The glBindImageTexture is available only if the GL version is 4.2 or greater.
*
* @errors GL_INVALID_VALUE is generated if unit greater than or equal to the value of GL_MAX_IMAGE_UNITS.
* @errors GL_INVALID_VALUE is generated if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level or layer is less than zero.
* @errors GL_INVALID_ENUM is generated if access or format is not one of the supported tokens.
*
*/
#define glBindImageTexture glad_glBindImageTexture
GLAD_API_CALL PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;
/**
* @name glBindImageTextures - bind one or more named texture images to a sequence of consecutive image units
* @usage
* @code void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures); @endcode
* @param first Specifies the first image unit to which a texture is to be bound.
* @param count Specifies the number of textures to bind.
* @param textures Specifies the address of an array of names of existing texture objects.
* @description
* 	glBindImageTextures binds images from an array of existing texture objects to a specified number of consecutive image units.
* count specifies the number of texture objects whose names are stored in the array textures. That number of texture
* names are read from the array and bound to the count consecutive texture units starting from first. If the name zero appears
* in the textures array, any existing binding to the image unit is reset. Any non-zero entry in textures must be the
* name of an existing texture object. When a non-zero entry in textures is present, the image at level zero is bound, the
* binding is considered layered, with the first layer set to zero, and the image is bound for read-write access. The image
* unit format parameter is taken from the internal format of the image at level zero of the texture object. For cube map
* textures, the internal format of the positive X image of level zero is used. If textures is NULL then it is as if an appropriately
* sized array containing only zeros had been specified.<br>
* 	glBindImageTextures is equivalent to the following pseudo code:<br>
* 	Each entry in textures will be checked individually and if found to be invalid, the state for that image unit will not
* be changed and an error will be generated. However, the state for other texture image units referenced by the command will
* still be updated.<br>
*
* @note glBindImageTextures is available only if the GL version is 4.4 or higher.
* @note Note that because glBindImageTextures cannot create new textures (even if a name passed has been previously generated by
*       call to glGenTextures), names passed to glBindImageTextures must have been bound at least once previously via a call to
*       glBindTexture.
*
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of image units supported by the implementation.
* @errors GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object.
* @errors GL_INVALID_OPERATION error is generated if the internal format of the level zero texture image of any texture in textures
*         is not supported.
* @errors GL_INVALID_OPERATION error is generated if the width, height, or depth of the level zero texture image of any texture in
*         textures is zero.
*
*/
#define glBindImageTextures glad_glBindImageTextures
GLAD_API_CALL PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;
/**
* @name glBindProgramPipeline - bind a program pipeline to the current context
* @usage
* @code void glBindProgramPipeline(GLuint pipeline); @endcode
* @param pipeline Specifies the name of the pipeline object to bind to the context.
* @description
* 	glBindProgramPipeline binds a program pipeline object to the current context. pipeline must be a name previously returned
* from a call to glGenProgramPipelines. If no program pipeline exists with name pipeline then a new pipeline object is
* created with that name and initialized to the default state vector.<br>
* 	When a program pipeline object is bound using glBindProgramPipeline, any previous binding is broken and is replaced with
* a binding to the specified pipeline object. If pipeline is zero, the previous binding is broken and is not replaced, leaving
* no pipeline object bound. If no current program object has been established by glUseProgram, the program objects
* used for each stage and for uniform updates are taken from the bound program pipeline object, if any. If there is a current
* program object established by glUseProgram, the bound program pipeline object has no effect on rendering or uniform
* updates. When a bound program pipeline object is used for rendering, individual shader executables are taken from its program
* objects.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not zero or a name previously returned from a call to glGenProgramPipelines
*         or if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glBindProgramPipeline glad_glBindProgramPipeline
GLAD_API_CALL PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
/**
* @name glBindRenderbuffer - bind a renderbuffer to a renderbuffer target
* @usage
* @code void glBindRenderbuffer(GLenum target, GLuint renderbuffer); @endcode
* @param target Specifies the renderbuffer target of the binding operation. <em class="parameter"><b>target</b></em> must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object to bind.
* @description
* 	glBindRenderbuffer binds the renderbuffer object with name renderbuffer to the renderbuffer target specified by target.
* target must be GL_RENDERBUFFER. renderbuffer is the name of a renderbuffer object previously returned from a call to glGenRenderbuffers,
* or zero to break the existing binding of a renderbuffer object to target.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated if renderbuffer is not zero or the name of a renderbuffer previously returned from a call
*         to glGenRenderbuffers.
*
*/
#define glBindRenderbuffer glad_glBindRenderbuffer
GLAD_API_CALL PFNGLBINDSAMPLERPROC glad_glBindSampler;
/**
* @name glBindSampler - bind a named sampler to a texturing target
* @usage
* @code void glBindSampler(GLuint unit, GLuint sampler); @endcode
* @param unit Specifies the index of the texture unit to which the sampler is bound.
* @param sampler Specifies the name of a sampler.
* @description
* 	glBindSampler binds sampler to the texture unit at index unit. sampler must be zero or the name of a sampler object previously
* returned from a call to glGenSamplers. unit must be less than the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS.<br>
* 	When a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to that texture
* unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler state becomes active.
* A single sampler object may be bound to multiple texture units simultaneously.<br>
*
* @note glBindSampler is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if unit is greater than or equal to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS.
* @errors GL_INVALID_OPERATION is generated if sampler is not zero or a name previously returned from a call to glGenSamplers, or
*         if such a name has been deleted by a call to glDeleteSamplers.
*
*/
#define glBindSampler glad_glBindSampler
GLAD_API_CALL PFNGLBINDSAMPLERSPROC glad_glBindSamplers;
/**
* @name glBindSamplers - bind one or more named sampler objects to a sequence of consecutive sampler units
* @usage
* @code void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers); @endcode
* @param first Specifies the first sampler unit to which a sampler object is to be bound.
* @param count Specifies the number of samplers to bind.
* @param samplers Specifies the address of an array of names of existing sampler objects.
* @description
* 	glBindSamplers binds samplers from an array of existing sampler objects to a specified number of consecutive sampler units.
* count specifies the number of sampler objects whose names are stored in the array samplers. That number of sampler
* names is read from the array and bound to the count consecutive sampler units starting from first.<br>
* 	If the name zero appears in the samplers array, any existing binding to the sampler unit is reset. Any non-zero entry in
* samplers must be the name of an existing sampler object. When a non-zero entry in samplers is present, that sampler object
* is bound to the corresponding sampler unit. If samplers is NULL then it is as if an appropriately sized array containing
* only zeros had been specified.<br>
* 	glBindSamplers is equivalent to the following pseudo code:<br>
* 	Each entry in samplers will be checked individually and if found to be invalid, the state for that sampler unit will not
* be changed and an error will be generated. However, the state for other sampler units referenced by the command will still
* be updated.<br>
*
* @note glBindSamplers is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of sampler units supported by the implementation.
* @errors GL_INVALID_OPERATION is generated if any value in samplers is not zero or the name of an existing sampler object.
*
*/
#define glBindSamplers glad_glBindSamplers
GLAD_API_CALL PFNGLBINDTEXTUREPROC glad_glBindTexture;
/**
* @name glBindTexture - bind a named texture to a texturing target
* @usage
* @code void glBindTexture(GLenum target, GLuint texture); @endcode
* @param target Specifies the target to which the texture is bound. Must be one of <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_BUFFER</b>, <b>GL_TEXTURE_2D_MULTISAMPLE</b> or <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param texture Specifies the name of a texture.
* @description
* 	glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to GL_TEXTURE_1D, GL_TEXTURE_2D,
* GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY,
* GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and texture set to the name
* of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for
* that target is automatically broken.<br>
* 	Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target.
* Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering
* context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the
* appropriate GL windows interfaces functions.<br>
* 	You must use glGenTextures to generate a set of new texture names.<br>
* 	When a texture is first bound, it assumes the specified target: A texture first bound to GL_TEXTURE_1D becomes one-dimensional
* texture, a texture first bound to GL_TEXTURE_2D becomes two-dimensional texture, a texture first bound to GL_TEXTURE_3D
* becomes three-dimensional texture, a texture first bound to GL_TEXTURE_1D_ARRAY becomes one-dimensional array texture,
* a texture first bound to GL_TEXTURE_2D_ARRAY becomes two-dimensional array texture, a texture first bound to GL_TEXTURE_RECTANGLE
* becomes rectangle texture, a texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture,
* a texture first bound to GL_TEXTURE_CUBE_MAP_ARRAY becomes a cube-mapped array texture, a texture first bound to GL_TEXTURE_BUFFER
* becomes a buffer texture, a texture first bound to GL_TEXTURE_2D_MULTISAMPLE becomes a two-dimensional multisampled
* texture, and a texture first bound to GL_TEXTURE_2D_MULTISAMPLE_ARRAY becomes a two-dimensional multisampled array
* texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the
* default GL_TEXTURE_1D at GL initialization, and similarly for the other texture types.<br>
* 	While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the
* target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the
* textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.<br>
* 	A texture binding created with glBindTexture remains active until a different texture is bound to the same target, or until
* the bound texture is deleted with glDeleteTextures.<br>
* 	Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster
* to use glBindTexture to bind an existing named texture to one of the texture targets than it is to reload the texture image
* using glTexImage1D, glTexImage2D, glTexImage3D or another similar function.<br>
*
* @note The GL_TEXTURE_2D_MULTISAMPLE and GL_TEXTURE_2D_MULTISAMPLE_ARRAY targets are available only if the GL version is 3.2 or
*       higher.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if texture is not a name returned from a previous call to glGenTextures.
* @errors GL_INVALID_OPERATION is generated if texture was previously created with a target that doesn't match that of target.
*
*/
#define glBindTexture glad_glBindTexture
GLAD_API_CALL PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;
/**
* @name glBindTextureUnit - bind an existing texture object to the specified texture unit
* @usage
* @code void glBindTextureUnit(GLuint unit, GLuint texture); @endcode
* @param unit Specifies the texture unit, to which the texture object should be bound to.
* @param texture Specifies the name of a texture.
* @description
* 	glBindTextureUnit binds an existing texture object to the texture unit numbered unit.<br>
* 	texture must be zero or the name of an existing texture object. When texture is the name of an existing texture object,
* that object is bound to the target, in the corresponding texture unit, that was specified when the object was created.
* When texture is zero, each of the targets enumerated at the beginning of this section is reset to its default texture for
* the corresponding texture image unit.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated if texture is not zero or the name of an existing texture object.
*
*/
#define glBindTextureUnit glad_glBindTextureUnit
GLAD_API_CALL PFNGLBINDTEXTURESPROC glad_glBindTextures;
/**
* @name glBindTextures - bind one or more named textures to a sequence of consecutive texture units
* @usage
* @code void glBindTextures(GLuint first, GLsizei count, const GLuint *textures); @endcode
* @param first Specifies the first texture unit to which a texture is to be bound.
* @param count Specifies the number of textures to bind.
* @param textures Specifies the address of an array of names of existing texture objects.
* @description
* 	glBindTextures binds an array of existing texture objects to a specified number of consecutive texture units. count specifies
* the number of texture objects whose names are stored in the array textures. That number of texture names are read
* from the array and bound to the count consecutive texture units starting from first. The target, or type of texture is
* deduced from the texture object and each texture is bound to the corresponding target of the texture unit. If the name zero
* appears in the textures array, any existing binding to any target of the texture unit is reset and the default texture
* for that target is bound in its place. Any non-zero entry in textures must be the name of an existing texture object.
* If textures is NULL then it is as if an appropriately sized array containing only zeros had been specified.<br>
* 	With the exception that the active texture selector maintains its current value, glBindTextures is equivalent to the following
* pseudo code:<br>
* 	Each entry in textures will be checked individually and if found to be invalid, the state for that texture unit will not
* be changed and an error will be generated. However, the state for other texture units referenced by the command will still
* be updated.<br>
*
* @note glBindTextures is available only if the GL version is 4.4 or higher.
* @note Note that because glBindTextures cannot create new textures (even if a name passed has been previously generated by call
*       to glGenTextures), names passed to glBindTextures must have been bound at least once previously via a call to glBindTexture.
*
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of texture image units supported by the implementation.
* @errors GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object.
*
*/
#define glBindTextures glad_glBindTextures
GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;
/**
* @name glBindTransformFeedback - bind a transform feedback object
* @usage
* @code void glBindTransformFeedback(GLenum target, GLuint id); @endcode
* @param target Specifies the target to which to bind the transform feedback object <em class="parameter"><b>id</b></em>. <em class="parameter"><b>target</b></em>
*               must be <b>GL_TRANSFORM_FEEDBACK</b>.
* @param id Specifies the name of a transform feedback object reserved by <a class="citerefentry" href="glGenTransformFeedbacks. xhtml"><span
*           class="citerefentry"><span class="refentrytitle">glGenTransformFeedbacks</span></span></a>.
* @description
* 	glBindTransformFeedback binds the transform feedback object with name id to the current GL state. id must be a name previously
* returned from a call to glGenTransformFeedbacks. If id has not previously been bound, a new transform feedback object
* with name id and initialized with the default transform state vector is created.<br>
* 	In the initial state, a default transform feedback object is bound and treated as a transform feedback object with a name
* of zero. If the name zero is subsequently bound, the default transform feedback object is again bound to the GL state.<br>
* 	While a transform feedback buffer object is bound, GL operations on the target to which it is bound affect the bound transform
* feedback object, and queries of the target to which a transform feedback object is bound return state from the bound
* object. When buffer objects are bound for transform feedback, they are attached to the currently bound transform feedback
* object. Buffer objects are used for trans- form feedback only if they are attached to the currently bound transform
* feedback object.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TRANSFORM_FEEDBACK.
* @errors GL_INVALID_OPERATION is generated if the transform feedback operation is active on the currently bound transform feedback
*         object, and that operation is not paused.
* @errors GL_INVALID_OPERATION is generated if id is not zero or the name of a transform feedback object returned from a previous
*         call to glGenTransformFeedbacks, or if such a name has been deleted by glDeleteTransformFeedbacks.
*
*/
#define glBindTransformFeedback glad_glBindTransformFeedback
GLAD_API_CALL PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
/**
* @name glBindVertexArray - bind a vertex array object
* @usage
* @code void glBindVertexArray(GLuint array); @endcode
* @param array Specifies the name of the vertex array to bind.
* @description
* 	glBindVertexArray binds the vertex array object with name array. array is the name of a vertex array object previously
* returned from a call to glGenVertexArrays, or zero to break the existing vertex array object binding.<br>
* 	If no vertex array object with name array exists, one is created when array is first bound. If the bind is successful no
* change is made to the state of the vertex array object, and any previous vertex array object binding is broken.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if array is not zero or the name of a vertex array object previously returned from a call
*         to glGenVertexArrays.
*
*/
#define glBindVertexArray glad_glBindVertexArray
GLAD_API_CALL PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;
/**
* @name glBindVertexBuffer, glVertexArrayVertexBuffer - bind a buffer to a vertex buffer bind point
* @usage
* @code void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @code void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @param vaobj Specifies the name of the vertex array object to be used by <b>glVertexArrayVertexBuffer</b> function.
* @param bindingindex The index of the vertex buffer binding point to which to bind the buffer.
* @param buffer The name of a buffer to bind to the vertex buffer binding point.
* @param offset The offset of the first element of the buffer.
* @param stride The distance between elements within the buffer.
* @description
* 	glBindVertexBuffer and glVertexArrayVertexBuffer bind the buffer named buffer to the vertex buffer binding point whose
* index is given by bindingindex. glBindVertexBuffer modifies the binding of the currently bound vertex array object, whereas
* glVertexArrayVertexBuffer allows the caller to specify ID of the vertex array object with an argument named vaobj, for
* which the binding should be modified. offset and stride specify the offset of the first element within the buffer and
* the distance between elements within the buffer, respectively, and are both measured in basic machine units. bindingindex
* must be less than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. offset and stride must be greater than or equal to zero.
* If buffer is zero, then any buffer currently bound to the specified binding point is unbound.<br>
* 	If buffer is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized
* memory buffer and comprising all the state and with the same initial values as in case of glBindBuffer. buffer is
* then attached to the specified bindingindex of the vertex array object.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffer if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffer if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_VALUE is generated if offset or stride is less than zero, or if stride is greater than the value of GL_MAX_VERTEX_ATTRIB_STRIDE.
* @errors GL_INVALID_VALUE is generated if buffer is not zero or the name of an existing buffer object (as returned by glGenBuffers
*         or glCreateBuffers).
*
*/
#define glBindVertexBuffer glad_glBindVertexBuffer
GLAD_API_CALL PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;
/**
* @name glBindVertexBuffers, glVertexArrayVertexBuffers - attach multiple buffer objects to a vertex array object
* @usage
* @code void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @code void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayVertexBuffers</b>.
* @param first Specifies the first vertex buffer binding point to which a buffer object is to be bound.
* @param count Specifies the number of buffers to bind.
* @param buffers Specifies the address of an array of names of existing buffer objects.
* @param offsets Specifies the address of an array of offsets to associate with the binding points.
* @param strides Specifies the address of an array of strides to associate with the binding points.
* @description
* 	glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer objects to a specified
* number of consecutive vertex buffer binding points units in a vertex array object. For glBindVertexBuffers, the vertex
* array object is the currently bound vertex array object. For glVertexArrayVertexBuffers, vaobj is the name of the vertex
* array object.<br>
* 	count existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If
* buffers is not NULL, it specifies an array of count values, each of which must be zero or the name of an existing buffer
* object. offsets and strides specify arrays of count values indicating the offset of the first element and stride between
* elements in each buffer, respectively. If buffers is NULL, each affected vertex buffer binding point from $first$ through
* $first + count - 1$ will be reset to have no bound buffer object. In this case, the offsets and strides associated
* with the binding points are set to default values, ignoring offsets and strides.<br>
* 	glBindVertexBuffers is equivalent (assuming no errors are generated) to:<br>
* 	except that buffers will not be created if they do not exist.<br>
* 	glVertexArrayVertexBuffers is equivalent to the pseudocode above, but replacing glBindVertexBuffers(args) with glVertexArrayVertexBuffers(vaobj,
* args).<br>
* 	The values specified in buffers, offsets, and strides will be checked separately for each vertex buffer binding point.
* When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and
* an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding
* values are valid.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffers if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffers if vaobj is not the name of the vertex array object.
* @errors GL_INVALID_OPERATION is generated if $first + count$ is greater than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if any value in offsets or strides is negative, or if a value is stride is greater than the
*         value of GL_MAX_VERTEX_ATTRIB_STRIDE.
*
*/
#define glBindVertexBuffers glad_glBindVertexBuffers
GLAD_API_CALL PFNGLBLENDCOLORPROC glad_glBlendColor;
/**
* @name glBlendColor - set the blend color
* @usage
* @code void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); @endcode
* @param red, green, blue, alpha specify the components of <b>GL_BLEND_COLOR</b>
* @description
* 	The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color components are clamped
* to the range 01 before being stored. See glBlendFunc for a complete description of the blending operations. Initially
* the GL_BLEND_COLOR is set to (0, 0, 0, 0).<br>
*
* @note The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent
*       to user code and is described in detail on the removedTypes page.
*
*
*/
#define glBlendColor glad_glBlendColor
GLAD_API_CALL PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
/**
* @name glBlendEquation - specify the equation used for both the RGB blend equation and the Alpha blend equation
* @usage
* @code void glBlendEquation(GLenum mode); @endcode
* @code void glBlendEquationi(GLuint buf, GLenum mode); @endcode
* @param buf for <b>glBlendEquationi</b>, specifies the index of the draw buffer for which to set the blend equation.
* @param mode specifies how source and destination colors are combined. It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>,
*             <b>GL_MIN</b>, <b>GL_MAX</b>.
* @description
* 	The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer
* (the ''destination'' color).  This function sets both the RGB blend equation and the alpha blend equation to a single
* equation. glBlendEquationi specifies the blend equation for a single draw buffer whereas glBlendEquation sets the blend
* equation for all draw buffers.<br>
* 	These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See
* glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.<br>
* 	In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad ,
* respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG
* sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range
* 01 .<br>
* 	The results of these equations are clamped to the range 01 .<br>
* 	The GL_MIN and GL_MAX equations are useful for applications that analyze image data (image thresholding against a constant
* color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.<br>
* 	Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.<br>
*
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquation glad_glBlendEquation
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
/**
* @name glBlendEquationSeparate - set the RGB blend equation and the alpha blend equation separately
* @usage
* @code void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha); @endcode
* @code void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha); @endcode
* @param buf for <b>glBlendEquationSeparatei</b>, specifies the index of the draw buffer for which to set the blend equations.
* @param modeRGB specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
*                It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @param modeAlpha specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be
*                  <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @description
* 	The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer
* (the ''destination'' color).  These functions specify one blend equation for the RGB-color components and one blend equation
* for the alpha component. glBlendEquationSeparatei specifies the blend equations for a single draw buffer whereas
* glBlendEquationSeparate sets the blend equations for all draw buffers.<br>
* 	The blend equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate.
* See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.<br>
* 	In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad ,
* respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG
* sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range
* 01 .<br>
* 	The results of these equations are clamped to the range 01 .<br>
* 	The GL_MIN and GL_MAX equations are useful for applications that analyze image data (image thresholding against a constant
* color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.<br>
* 	Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.<br>
*
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT,
*         GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquationSeparate glad_glBlendEquationSeparate
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;
/**
* @name glBlendEquationSeparate - set the RGB blend equation and the alpha blend equation separately
* @usage
* @code void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha); @endcode
* @code void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha); @endcode
* @param buf for <b>glBlendEquationSeparatei</b>, specifies the index of the draw buffer for which to set the blend equations.
* @param modeRGB specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
*                It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @param modeAlpha specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be
*                  <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @description
* 	The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer
* (the ''destination'' color).  These functions specify one blend equation for the RGB-color components and one blend equation
* for the alpha component. glBlendEquationSeparatei specifies the blend equations for a single draw buffer whereas
* glBlendEquationSeparate sets the blend equations for all draw buffers.<br>
* 	The blend equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate.
* See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.<br>
* 	In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad ,
* respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG
* sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range
* 01 .<br>
* 	The results of these equations are clamped to the range 01 .<br>
* 	The GL_MIN and GL_MAX equations are useful for applications that analyze image data (image thresholding against a constant
* color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.<br>
* 	Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.<br>
*
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT,
*         GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquationSeparatei glad_glBlendEquationSeparatei
GLAD_API_CALL PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;
/**
* @name glBlendEquation - specify the equation used for both the RGB blend equation and the Alpha blend equation
* @usage
* @code void glBlendEquation(GLenum mode); @endcode
* @code void glBlendEquationi(GLuint buf, GLenum mode); @endcode
* @param buf for <b>glBlendEquationi</b>, specifies the index of the draw buffer for which to set the blend equation.
* @param mode specifies how source and destination colors are combined. It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>,
*             <b>GL_MIN</b>, <b>GL_MAX</b>.
* @description
* 	The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer
* (the ''destination'' color).  This function sets both the RGB blend equation and the alpha blend equation to a single
* equation. glBlendEquationi specifies the blend equation for a single draw buffer whereas glBlendEquation sets the blend
* equation for all draw buffers.<br>
* 	These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See
* glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.<br>
* 	In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad ,
* respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG
* sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range
* 01 .<br>
* 	The results of these equations are clamped to the range 01 .<br>
* 	The GL_MIN and GL_MAX equations are useful for applications that analyze image data (image thresholding against a constant
* color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.<br>
* 	Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.<br>
*
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquationi glad_glBlendEquationi
GLAD_API_CALL PFNGLBLENDFUNCPROC glad_glBlendFunc;
/**
* @name glBlendFunc - specify pixel arithmetic
* @usage
* @code void glBlendFunc(GLenum sfactor, GLenum dfactor); @endcode
* @code void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor); @endcode
* @param buf For <b>glBlendFunci</b>, specifies the index of the draw buffer for which to set the blend function.
* @param sfactor Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dfactor Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants
*                are accepted: <b>GL_ZERO</b>, <b>GL_ONE</b>, <b>GL_SRC_COLOR</b>, <b>GL_ONE_MINUS_SRC_COLOR</b>, <b>GL_DST_COLOR</b>,
*                <b>GL_ONE_MINUS_DST_COLOR</b>, <b>GL_SRC_ALPHA</b>, <b>GL_ONE_MINUS_SRC_ALPHA</b>, <b>GL_DST_ALPHA</b>, <b>GL_ONE_MINUS_DST_ALPHA</b>.
*                <b>GL_CONSTANT_COLOR</b>, <b>GL_ONE_MINUS_CONSTANT_COLOR</b>, <b>GL_CONSTANT_ALPHA</b>, and <b>GL_ONE_MINUS_CONSTANT_ALPHA</b>.
*                The initial value is <b>GL_ZERO</b>.
* @description
* 	Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already
* in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and  glDisable with argument
* GL_BLEND to enable and disable blending.<br>
* 	glBlendFunc defines the operation of blending for all draw buffers when it is enabled. glBlendFunci defines the operation
* of blending for a single draw buffer specified by buf when enabled for that draw buffer. sfactor specifies which method
* is used to scale the source color components. dfactor specifies which method is used to scale the destination color components.
* Both parameters must be one of the following symbolic constants: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR,
* GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA,
* GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, GL_SRC_ALPHA_SATURATE,
* GL_SRC1_COLOR, GL_ONE_MINUS_SRC1_COLOR, GL_SRC1_ALPHA, and GL_ONE_MINUS_SRC1_ALPHA. The possible methods are described
* in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table
* and in subsequent equations, first source, second source and destination color components are referred to as Rs0 Gs0 Bs0
* As0 , Rs1 Gs1 Bs1 As1 and Rd Gd Bd Ad , respectively. The color specified by glBlendColor is referred to as Rc Gc Bc
* Ac . They are understood to have integer values between 0 and kR kG kB kA , where<br>
* 	kc = 2 mc -1<br>
* 	and mR mG mB mA is the number of red, green, blue, and alpha bitplanes.<br>
* 	Source and destination scale factors are referred to as sR sG sB sA and dR dG dB dA . The scale factors described in the
* table, denoted fR fG fB fA , represent either source or destination factors. All scale factors have range 01 .<br>
* 	In the table,<br>
* 	i= min⁡ As kA -Ad kA<br>
* 	To determine the blended RGBA values of a pixel, the system uses the following equations:<br>
* 	Rd = min⁡ kR Rs ⁢sR +Rd ⁢dR Gd = min⁡ kG Gs ⁢sG +Gd ⁢dG Bd = min⁡ kB Bs ⁢sB +Bd ⁢dB Ad = min⁡ kA As ⁢sA +Ad ⁢dA<br>
* 	Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates
* with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify
* its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when sfactor is GL_SRC_ALPHA,
* dfactor is GL_ONE_MINUS_SRC_ALPHA, and As is equal to kA , the equations reduce to simple replacement:<br>
* 	Rd =Rs Gd =Gs Bd =Bs Ad =As<br>
*
* @note Incoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFunc glad_glBlendFunc
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
/**
* @name glBlendFuncSeparate - specify pixel arithmetic for RGB and alpha components separately
* @usage
* @code void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @code void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @param buf For <b>glBlendFuncSeparatei</b>, specifies the index of the draw buffer for which to set the blend functions.
* @param srcRGB Specifies how the red, green, and blue blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dstRGB Specifies how the red, green, and blue destination blending factors are computed. The initial value is <b>GL_ZERO</b>.
* @param srcAlpha Specified how the alpha source blending factor is computed. The initial value is <b>GL_ONE</b>.
* @param dstAlpha Specified how the alpha destination blending factor is computed. The initial value is <b>GL_ZERO</b>.
* @description
* 	Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already
* in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and  glDisable with argument
* GL_BLEND to enable and disable blending.<br>
* 	glBlendFuncSeparate defines the operation of blending for all draw buffers when it is enabled. glBlendFuncSeparatei defines
* the operation of blending for a single draw buffer specified by buf when enabled for that draw buffer. srcRGB specifies
* which method is used to scale the source RGB-color components. dstRGB specifies which method is used to scale the destination
* RGB-color components. Likewise, srcAlpha specifies which method is used to scale the source alpha color component,
* and dstAlpha specifies which method is used to scale the destination alpha component. The possible methods are described
* in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.<br>
* 	In the table and in subsequent equations, first source, second source and destination color components are referred to
* as Rs0 Gs0 Bs0 As0 , Rs1 Gs1 Bs1 As1 , and Rd Gd Bd Ad , respectively. The color specified by glBlendColor is referred to
* as Rc Gc Bc Ac . They are understood to have integer values between 0 and kR kG kB kA , where<br>
* 	kc = 2 mc -1<br>
* 	and mR mG mB mA is the number of red, green, blue, and alpha bitplanes.<br>
* 	Source and destination scale factors are referred to as sR sG sB sA and dR dG dB dA . All scale factors have range 01 .<br>
* 	In the table,<br>
* 	i= min⁡ As 1- Ad<br>
* 	To determine the blended RGBA values of a pixel, the system uses the following equations:<br>
* 	Rd = min⁡ kR Rs ⁢sR +Rd ⁢dR Gd = min⁡ kG Gs ⁢sG +Gd ⁢dG Bd = min⁡ kB Bs ⁢sB +Bd ⁢dB Ad = min⁡ kA As ⁢sA +Ad ⁢dA<br>
* 	Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates
* with imprecise integer color values.  However, a blend factor that should be equal to 1 is guaranteed not to modify
* its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.  For example, when srcRGB is GL_SRC_ALPHA,
* dstRGB is GL_ONE_MINUS_SRC_ALPHA, and As is equal to kA , the equations reduce to simple replacement:<br>
* 	Rd =Rs Gd =Gs Bd =Bs Ad =As<br>
*
* @note Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFuncSeparate glad_glBlendFuncSeparate
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;
/**
* @name glBlendFuncSeparate - specify pixel arithmetic for RGB and alpha components separately
* @usage
* @code void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @code void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @param buf For <b>glBlendFuncSeparatei</b>, specifies the index of the draw buffer for which to set the blend functions.
* @param srcRGB Specifies how the red, green, and blue blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dstRGB Specifies how the red, green, and blue destination blending factors are computed. The initial value is <b>GL_ZERO</b>.
* @param srcAlpha Specified how the alpha source blending factor is computed. The initial value is <b>GL_ONE</b>.
* @param dstAlpha Specified how the alpha destination blending factor is computed. The initial value is <b>GL_ZERO</b>.
* @description
* 	Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already
* in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and  glDisable with argument
* GL_BLEND to enable and disable blending.<br>
* 	glBlendFuncSeparate defines the operation of blending for all draw buffers when it is enabled. glBlendFuncSeparatei defines
* the operation of blending for a single draw buffer specified by buf when enabled for that draw buffer. srcRGB specifies
* which method is used to scale the source RGB-color components. dstRGB specifies which method is used to scale the destination
* RGB-color components. Likewise, srcAlpha specifies which method is used to scale the source alpha color component,
* and dstAlpha specifies which method is used to scale the destination alpha component. The possible methods are described
* in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.<br>
* 	In the table and in subsequent equations, first source, second source and destination color components are referred to
* as Rs0 Gs0 Bs0 As0 , Rs1 Gs1 Bs1 As1 , and Rd Gd Bd Ad , respectively. The color specified by glBlendColor is referred to
* as Rc Gc Bc Ac . They are understood to have integer values between 0 and kR kG kB kA , where<br>
* 	kc = 2 mc -1<br>
* 	and mR mG mB mA is the number of red, green, blue, and alpha bitplanes.<br>
* 	Source and destination scale factors are referred to as sR sG sB sA and dR dG dB dA . All scale factors have range 01 .<br>
* 	In the table,<br>
* 	i= min⁡ As 1- Ad<br>
* 	To determine the blended RGBA values of a pixel, the system uses the following equations:<br>
* 	Rd = min⁡ kR Rs ⁢sR +Rd ⁢dR Gd = min⁡ kG Gs ⁢sG +Gd ⁢dG Bd = min⁡ kB Bs ⁢sB +Bd ⁢dB Ad = min⁡ kA As ⁢sA +Ad ⁢dA<br>
* 	Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates
* with imprecise integer color values.  However, a blend factor that should be equal to 1 is guaranteed not to modify
* its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.  For example, when srcRGB is GL_SRC_ALPHA,
* dstRGB is GL_ONE_MINUS_SRC_ALPHA, and As is equal to kA , the equations reduce to simple replacement:<br>
* 	Rd =Rs Gd =Gs Bd =Bs Ad =As<br>
*
* @note Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFuncSeparatei glad_glBlendFuncSeparatei
GLAD_API_CALL PFNGLBLENDFUNCIPROC glad_glBlendFunci;
/**
* @name glBlendFunc - specify pixel arithmetic
* @usage
* @code void glBlendFunc(GLenum sfactor, GLenum dfactor); @endcode
* @code void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor); @endcode
* @param buf For <b>glBlendFunci</b>, specifies the index of the draw buffer for which to set the blend function.
* @param sfactor Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dfactor Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants
*                are accepted: <b>GL_ZERO</b>, <b>GL_ONE</b>, <b>GL_SRC_COLOR</b>, <b>GL_ONE_MINUS_SRC_COLOR</b>, <b>GL_DST_COLOR</b>,
*                <b>GL_ONE_MINUS_DST_COLOR</b>, <b>GL_SRC_ALPHA</b>, <b>GL_ONE_MINUS_SRC_ALPHA</b>, <b>GL_DST_ALPHA</b>, <b>GL_ONE_MINUS_DST_ALPHA</b>.
*                <b>GL_CONSTANT_COLOR</b>, <b>GL_ONE_MINUS_CONSTANT_COLOR</b>, <b>GL_CONSTANT_ALPHA</b>, and <b>GL_ONE_MINUS_CONSTANT_ALPHA</b>.
*                The initial value is <b>GL_ZERO</b>.
* @description
* 	Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already
* in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and  glDisable with argument
* GL_BLEND to enable and disable blending.<br>
* 	glBlendFunc defines the operation of blending for all draw buffers when it is enabled. glBlendFunci defines the operation
* of blending for a single draw buffer specified by buf when enabled for that draw buffer. sfactor specifies which method
* is used to scale the source color components. dfactor specifies which method is used to scale the destination color components.
* Both parameters must be one of the following symbolic constants: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR,
* GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA,
* GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, GL_SRC_ALPHA_SATURATE,
* GL_SRC1_COLOR, GL_ONE_MINUS_SRC1_COLOR, GL_SRC1_ALPHA, and GL_ONE_MINUS_SRC1_ALPHA. The possible methods are described
* in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table
* and in subsequent equations, first source, second source and destination color components are referred to as Rs0 Gs0 Bs0
* As0 , Rs1 Gs1 Bs1 As1 and Rd Gd Bd Ad , respectively. The color specified by glBlendColor is referred to as Rc Gc Bc
* Ac . They are understood to have integer values between 0 and kR kG kB kA , where<br>
* 	kc = 2 mc -1<br>
* 	and mR mG mB mA is the number of red, green, blue, and alpha bitplanes.<br>
* 	Source and destination scale factors are referred to as sR sG sB sA and dR dG dB dA . The scale factors described in the
* table, denoted fR fG fB fA , represent either source or destination factors. All scale factors have range 01 .<br>
* 	In the table,<br>
* 	i= min⁡ As kA -Ad kA<br>
* 	To determine the blended RGBA values of a pixel, the system uses the following equations:<br>
* 	Rd = min⁡ kR Rs ⁢sR +Rd ⁢dR Gd = min⁡ kG Gs ⁢sG +Gd ⁢dG Bd = min⁡ kB Bs ⁢sB +Bd ⁢dB Ad = min⁡ kA As ⁢sA +Ad ⁢dA<br>
* 	Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates
* with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify
* its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when sfactor is GL_SRC_ALPHA,
* dfactor is GL_ONE_MINUS_SRC_ALPHA, and As is equal to kA , the equations reduce to simple replacement:<br>
* 	Rd =Rs Gd =Gs Bd =Bs Ad =As<br>
*
* @note Incoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFunci glad_glBlendFunci
GLAD_API_CALL PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
/**
* @name glBlitFramebuffer, glBlitNamedFramebuffer - copy a block of pixels from one framebuffer object to another
* @usage
* @code void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @code void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @param readFramebuffer Specifies the name of the source framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param drawFramebuffer Specifies the name of the destination framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param srcX0, srcY0, srcX1, srcY1 Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
* @param dstX0, dstY0, dstX1, dstY1 Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
* @param mask The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are <b>GL_COLOR_BUFFER_BIT</b>,
*             <b>GL_DEPTH_BUFFER_BIT</b> and <b>GL_STENCIL_BUFFER_BIT</b>.
* @param filter Specifies the interpolation to be applied if the image is stretched. Must be <b>GL_NEAREST</b> or <b>GL_LINEAR</b>.
* @description
* 	glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of a read framebuffer
* to another region of a draw framebuffer.<br>
* 	For glBlitFramebuffer, the read and draw framebuffers are those bound to the GL_READ_FRAMEBUFFER and GL_DRAW_FRAMEBUFFER
* targets respectively.<br>
* 	For glBlitNamedFramebuffer, readFramebuffer and drawFramebuffer are the names of the read and draw framebuffer objects
* respectively. If readFramebuffer or drawFramebuffer is zero, then the default read or draw framebuffer respectively is used.<br>
* 	mask is the bitwise OR of a number of values indicating which buffers are to be copied. The values are GL_COLOR_BUFFER_BIT,
* GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. The pixels corresponding to these buffers are copied from the source
* rectangle bounded by the locations (srcX0, srcY0) and (srcX1, srcY1) to the destination rectangle bounded by the locations
* (dstX0, dstY0) and (dstX1, dstY1). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive.<br>
* 	The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred,
* which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending
* on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being
* written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether
* or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels
* being transferred is performed as though no such limits were present.<br>
* 	If the sizes of the source and destination rectangles are not equal, filter specifies the interpolation method that will
* be applied to resize the source image , and must be GL_NEAREST or GL_LINEAR. GL_LINEAR is only a valid interpolation method
* for the color buffer. If filter is not GL_NEAREST and mask includes GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT,
* no data is transferred and a GL_INVALID_OPERATION error is generated.<br>
* 	If filter is GL_LINEAR and the source rectangle would require sampling outside the bounds of the source framebuffer, values
* are read as if the GL_CLAMP_TO_EDGE texture wrapping mode were applied.<br>
* 	When the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written
* to each of the draw buffers of the specified draw framebuffer.<br>
* 	If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result
* of the operation is undefined.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by BlitNamedFramebuffer if readFramebuffer or drawFramebuffer is not zero or the name
*         of an existing framebuffer object.
* @errors GL_INVALID_OPERATION is generated if mask contains any of the GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and filter is
*         not GL_NEAREST.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT and any of the following conditions hold:
* @errors The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point
*         values.
* @errors The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.
* @errors The read buffer contains signed integer values and any draw buffer does not contain signed integer values.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and the source and destination
*         depth and stencil formats do not match.
* @errors GL_INVALID_OPERATION is generated if filter is GL_LINEAR and the read buffer contains integer data.
* @errors GL_INVALID_OPERATION is generated if both the read and draw framebuffers are multisampled, and their effective values of
*         GL_SAMPLES are not identical.
* @errors GL_INVALID_OPERATION is generated if the value of GL_SAMPLE_BUFFERS for either read or draw buffers is greater than zero
*         and the dimensions of the source and destination rectangles is not identical.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the specified read and draw framebuffers are not framebuffer complete.
*
*/
#define glBlitFramebuffer glad_glBlitFramebuffer
GLAD_API_CALL PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;
/**
* @name glBlitFramebuffer, glBlitNamedFramebuffer - copy a block of pixels from one framebuffer object to another
* @usage
* @code void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @code void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @param readFramebuffer Specifies the name of the source framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param drawFramebuffer Specifies the name of the destination framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param srcX0, srcY0, srcX1, srcY1 Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
* @param dstX0, dstY0, dstX1, dstY1 Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
* @param mask The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are <b>GL_COLOR_BUFFER_BIT</b>,
*             <b>GL_DEPTH_BUFFER_BIT</b> and <b>GL_STENCIL_BUFFER_BIT</b>.
* @param filter Specifies the interpolation to be applied if the image is stretched. Must be <b>GL_NEAREST</b> or <b>GL_LINEAR</b>.
* @description
* 	glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of a read framebuffer
* to another region of a draw framebuffer.<br>
* 	For glBlitFramebuffer, the read and draw framebuffers are those bound to the GL_READ_FRAMEBUFFER and GL_DRAW_FRAMEBUFFER
* targets respectively.<br>
* 	For glBlitNamedFramebuffer, readFramebuffer and drawFramebuffer are the names of the read and draw framebuffer objects
* respectively. If readFramebuffer or drawFramebuffer is zero, then the default read or draw framebuffer respectively is used.<br>
* 	mask is the bitwise OR of a number of values indicating which buffers are to be copied. The values are GL_COLOR_BUFFER_BIT,
* GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. The pixels corresponding to these buffers are copied from the source
* rectangle bounded by the locations (srcX0, srcY0) and (srcX1, srcY1) to the destination rectangle bounded by the locations
* (dstX0, dstY0) and (dstX1, dstY1). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive.<br>
* 	The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred,
* which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending
* on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being
* written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether
* or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels
* being transferred is performed as though no such limits were present.<br>
* 	If the sizes of the source and destination rectangles are not equal, filter specifies the interpolation method that will
* be applied to resize the source image , and must be GL_NEAREST or GL_LINEAR. GL_LINEAR is only a valid interpolation method
* for the color buffer. If filter is not GL_NEAREST and mask includes GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT,
* no data is transferred and a GL_INVALID_OPERATION error is generated.<br>
* 	If filter is GL_LINEAR and the source rectangle would require sampling outside the bounds of the source framebuffer, values
* are read as if the GL_CLAMP_TO_EDGE texture wrapping mode were applied.<br>
* 	When the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written
* to each of the draw buffers of the specified draw framebuffer.<br>
* 	If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result
* of the operation is undefined.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by BlitNamedFramebuffer if readFramebuffer or drawFramebuffer is not zero or the name
*         of an existing framebuffer object.
* @errors GL_INVALID_OPERATION is generated if mask contains any of the GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and filter is
*         not GL_NEAREST.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT and any of the following conditions hold:
* @errors The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point
*         values.
* @errors The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.
* @errors The read buffer contains signed integer values and any draw buffer does not contain signed integer values.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and the source and destination
*         depth and stencil formats do not match.
* @errors GL_INVALID_OPERATION is generated if filter is GL_LINEAR and the read buffer contains integer data.
* @errors GL_INVALID_OPERATION is generated if both the read and draw framebuffers are multisampled, and their effective values of
*         GL_SAMPLES are not identical.
* @errors GL_INVALID_OPERATION is generated if the value of GL_SAMPLE_BUFFERS for either read or draw buffers is greater than zero
*         and the dimensions of the source and destination rectangles is not identical.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the specified read and draw framebuffers are not framebuffer complete.
*
*/
#define glBlitNamedFramebuffer glad_glBlitNamedFramebuffer
GLAD_API_CALL PFNGLBUFFERDATAPROC glad_glBufferData;
/**
* @name glBufferData, glNamedBufferData - creates and initializes a buffer object's data
store
* @usage
* @code void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage); @endcode
* @code void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferData</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param usage Specifies the expected usage pattern of the data store. The symbolic constant must be <b>GL_STREAM_DRAW</b>, <b>GL_STREAM_READ</b>,
*              <b>GL_STREAM_COPY</b>, <b>GL_STATIC_DRAW</b>, <b>GL_STATIC_READ</b>, <b>GL_STATIC_COPY</b>, <b>GL_DYNAMIC_DRAW</b>,
*              <b>GL_DYNAMIC_READ</b>, or <b>GL_DYNAMIC_COPY</b>.
* @description
* 	glBufferData and glNamedBufferData create a new data store for a buffer object. In case of glBufferData, the buffer object
* currently bound to target is used. For glNamedBufferData, a buffer object associated with ID specified by the caller
* in buffer will be used instead.<br>
* 	While creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified
* size in bytes and usage. If data is not NULL, the data store is initialized with data from this pointer. In its initial
* state, the new data store is not mapped, it has a NULL mapped pointer, and its mapped access is GL_READ_WRITE.<br>
* 	usage is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation
* to make more intelligent decisions that may significantly impact buffer object performance. It does not, however,
* constrain the actual usage of the data store. usage can be broken down into two parts: first, the frequency of access
* (modification and usage), and second, the nature of that access. The frequency of access may be one of these:<br>
* 	The data store contents will be modified once and used at most a few times.<br>
* 	The data store contents will be modified once and used many times.<br>
* 	The data store contents will be modified repeatedly and used many times.<br>
* 	The nature of access may be one of these:<br>
* 	The data store contents are modified by the application, and used as the source for GL drawing and image specification
* commands.<br>
* 	The data store contents are modified by reading data from the GL, and used to return that data when queried by the application.<br>
* 	The data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification
* commands.<br>
*
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
* @note Clients must align data elements consistently with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ,
*         GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
* @errors GL_INVALID_VALUE is generated if size is negative.
* @errors GL_INVALID_OPERATION is generated by glBufferData if the reserved buffer object name 0 is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size.
*
*/
#define glBufferData glad_glBufferData
GLAD_API_CALL PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;
/**
* @name glBufferStorage, glNamedBufferStorage - creates and initializes a buffer object's immutable data
store
* @usage
* @code void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags); @endcode
* @code void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferStorage</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferStorage</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param flags Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. <b>GL_DYNAMIC_STORAGE_BIT</b>,
*              <b>GL_MAP_READ_BIT</b>
<b>GL_MAP_WRITE_BIT</b>, <b>GL_MAP_PERSISTENT_BIT</b>, <b>GL_MAP_COHERENT_BIT</b>,
*              and <b>GL_CLIENT_STORAGE_BIT</b>.
* @description
* 	glBufferStorage and glNamedBufferStorage create a new immutable data store. For glBufferStorage, the buffer object currently
* bound to target will be initialized. For glNamedBufferStorage, buffer is the name of the buffer object that will be
* configured. The size of the data store is specified by size. If an initial data is available, its address may be supplied
* in data. Otherwise, to create an uninitialized data store, data should be NULL.<br>
* 	The flags parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset
* of the following flags:<br>
* 	The contents of the data store may be updated after creation through calls to glBufferSubData. If this bit is not set,
* the buffer content may not be directly updated by the client. The data argument may be used to specify the initial content
* of the buffer's data store regardless of the presence of the GL_DYNAMIC_STORAGE_BIT. Regardless of the presence of this
* bit, buffers may always be updated with server-side calls such as glCopyBufferSubData and glClearBufferSubData.<br>
* 	The data store may be mapped by the client for read access and a pointer in the client's address space obtained that may
* be read from.<br>
* 	The data store may be mapped by the client for write access and a pointer in the client's address space obtained that may
* be written through.<br>
* 	The client may request that the server read from or write to the buffer while it is mapped. The client's pointer to the
* data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.<br>
* 	Shared access to buffers that are simultaneously mapped for client access and are used by the server will be coherent,
* so long as that mapping is performed using glMapBufferRange. That is, data written to the store by either the client or
* server will be immediately visible to the other with no further action taken by the application. In particular,<br>
* 	If GL_MAP_COHERENT_BIT is not set and the client performs a write followed by a call to the glMemoryBarrier command with
* the GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT set, then in subsequent commands the server will see the writes.<br>
* 	If GL_MAP_COHERENT_BIT is set and the client performs a write, then in subsequent commands the server will see the writes.<br>
* 	If GL_MAP_COHERENT_BIT is not set and the server performs a write, the application must call glMemoryBarrier with the GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT
* set and then call glFenceSync with GL_SYNC_GPU_COMMANDS_COMPLETE (or glFinish). Then
* the CPU will see the writes after the sync is complete.<br>
* 	If GL_MAP_COHERENT_BIT is set and the server does a write, the app must call glFenceSync with GL_SYNC_GPU_COMMANDS_COMPLETE
* (or glFinish). Then the CPU will see the writes after the sync is complete.<br>
* 	When all other criteria for the buffer storage allocation are met, this bit may be used by an implementation to determine
* whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.<br>
* 	The allowed combinations of flags are subject to certain restrictions. They are as follows:<br>
* 	If flags contains GL_MAP_PERSISTENT_BIT, it must also contain at least one of GL_MAP_READ_BIT or GL_MAP_WRITE_BIT.<br>
* 	If flags contains GL_MAP_COHERENT_BIT, it must also contain GL_MAP_PERSISTENT_BIT.<br>
*
* @note glBufferStorage is available only if the GL version is 4.4 or greater.
* @note glNamedBufferStorage is available only if the GL version is 4.5 or greater.
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
*
* @errors GL_INVALID_ENUM is generated by glBufferStorage if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferStorage if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if size is less than or equal to zero.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the reserved buffer object name 0 is bound to target.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the properties requested in flags.
* @errors GL_INVALID_VALUE is generated if flags has any bits set other than those defined above.
* @errors GL_INVALID_VALUE error is generated if flags contains GL_MAP_PERSISTENT_BIT but does not contain at least one of GL_MAP_READ_BIT
*         or GL_MAP_WRITE_BIT.
* @errors GL_INVALID_VALUE is generated if flags contains GL_MAP_COHERENT_BIT, but does not also contain GL_MAP_PERSISTENT_BIT.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer bound to target
*         is GL_TRUE.
*
*/
#define glBufferStorage glad_glBufferStorage
GLAD_API_CALL PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
/**
* @name glBufferSubData, glNamedBufferSubData - updates a subset of a buffer object's data store
* @usage
* @code void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data); @endcode
* @code void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferSubData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
* @param size Specifies the size in bytes of the data store region being replaced.
* @param data Specifies a pointer to the new data that will be copied into the data store.
* @description
* 	glBufferSubData and glNamedBufferSubData redefine some or all of the data store for the specified buffer object. Data starting
* at byte offset offset and extending for size bytes is copied to the data store from the memory pointed to by data.
* offset and size must define a range lying entirely within the buffer object's data store.<br>
*
* @note When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with
*       glBufferData. This avoids the cost of reallocating the data store.
* @note Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering
*       in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific
*       region being updated, that rendering must drain from the pipeline before the data store can be updated.
* @note Clients must align data elements consistent with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferSubData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the specified buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and
*         the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set.
*
*/
#define glBufferSubData glad_glBufferSubData
GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
/**
* @name glCheckFramebufferStatus, glCheckNamedFramebufferStatus - check the completeness status of a framebuffer
* @usage
* @code GLenum glCheckFramebufferStatus(GLenum target); @endcode
* @code GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target); @endcode
* @param target Specify the target to which the framebuffer is bound for <b>glCheckFramebufferStatus</b>, and the target against which framebuffer
*               completeness of <em class="parameter"><b>framebuffer</b></em> is checked for <b>glCheckNamedFramebufferStatus</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glCheckNamedFramebufferStatus</b>
* @description
* 	glCheckFramebufferStatus and glCheckNamedFramebufferStatus return the completeness status of a framebuffer object when
* treated as a read or draw framebuffer, depending on the value of target.<br>
* 	For glCheckFramebufferStatus, the framebuffer checked is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glCheckNamedFramebufferStatus, framebuffer is zero or the name of the framebuffer object to check. If framebuffer is
* zero, then the status of the default read or draw framebuffer, as determined by target, is returned.<br>
* 	The return value is GL_FRAMEBUFFER_COMPLETE if the specified framebuffer is complete. Otherwise, the return value is determined
* as follows:<br>
* 	GL_FRAMEBUFFER_UNDEFINED is returned if the specified framebuffer is the default read or draw framebuffer, but the default
* framebuffer does not exist.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT is returned if any of the framebuffer attachment points are framebuffer incomplete.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT is returned if the framebuffer does not have at least one image attached to
* it.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER is returned if the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE for
* any color attachment point(s) named by GL_DRAW_BUFFERi.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER is returned if GL_READ_BUFFER is not GL_NONE and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
* is GL_NONE for the color attachment point named by GL_READ_BUFFER.<br>
* 	GL_FRAMEBUFFER_UNSUPPORTED is returned if the combination of internal formats of the attached images violates an implementation-dependent
* set of restrictions.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is returned if the value of GL_RENDERBUFFER_SAMPLES is not the same for all attached
* renderbuffers; if the value of GL_TEXTURE_SAMPLES is the not same for all attached textures; or, if the attached images
* are a mix of renderbuffers and textures, the value of GL_RENDERBUFFER_SAMPLES does not match the value of GL_TEXTURE_SAMPLES.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is also returned if the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS is not the same
* for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS
* is not GL_TRUE for all attached textures.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS is returned if any framebuffer attachment is layered, and any populated attachment
* is not layered, or if all populated color attachments are not from textures of the same target.<br>
* 	Additionally, if an error occurs, zero is returned.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
* @errors GL_INVALID_OPERATION is generated by glCheckNamedFramebufferStatus if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glCheckFramebufferStatus glad_glCheckFramebufferStatus
GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;
/**
* @name glCheckFramebufferStatus, glCheckNamedFramebufferStatus - check the completeness status of a framebuffer
* @usage
* @code GLenum glCheckFramebufferStatus(GLenum target); @endcode
* @code GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target); @endcode
* @param target Specify the target to which the framebuffer is bound for <b>glCheckFramebufferStatus</b>, and the target against which framebuffer
*               completeness of <em class="parameter"><b>framebuffer</b></em> is checked for <b>glCheckNamedFramebufferStatus</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glCheckNamedFramebufferStatus</b>
* @description
* 	glCheckFramebufferStatus and glCheckNamedFramebufferStatus return the completeness status of a framebuffer object when
* treated as a read or draw framebuffer, depending on the value of target.<br>
* 	For glCheckFramebufferStatus, the framebuffer checked is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glCheckNamedFramebufferStatus, framebuffer is zero or the name of the framebuffer object to check. If framebuffer is
* zero, then the status of the default read or draw framebuffer, as determined by target, is returned.<br>
* 	The return value is GL_FRAMEBUFFER_COMPLETE if the specified framebuffer is complete. Otherwise, the return value is determined
* as follows:<br>
* 	GL_FRAMEBUFFER_UNDEFINED is returned if the specified framebuffer is the default read or draw framebuffer, but the default
* framebuffer does not exist.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT is returned if any of the framebuffer attachment points are framebuffer incomplete.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT is returned if the framebuffer does not have at least one image attached to
* it.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER is returned if the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE for
* any color attachment point(s) named by GL_DRAW_BUFFERi.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER is returned if GL_READ_BUFFER is not GL_NONE and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
* is GL_NONE for the color attachment point named by GL_READ_BUFFER.<br>
* 	GL_FRAMEBUFFER_UNSUPPORTED is returned if the combination of internal formats of the attached images violates an implementation-dependent
* set of restrictions.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is returned if the value of GL_RENDERBUFFER_SAMPLES is not the same for all attached
* renderbuffers; if the value of GL_TEXTURE_SAMPLES is the not same for all attached textures; or, if the attached images
* are a mix of renderbuffers and textures, the value of GL_RENDERBUFFER_SAMPLES does not match the value of GL_TEXTURE_SAMPLES.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is also returned if the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS is not the same
* for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS
* is not GL_TRUE for all attached textures.<br>
* 	GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS is returned if any framebuffer attachment is layered, and any populated attachment
* is not layered, or if all populated color attachments are not from textures of the same target.<br>
* 	Additionally, if an error occurs, zero is returned.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
* @errors GL_INVALID_OPERATION is generated by glCheckNamedFramebufferStatus if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glCheckNamedFramebufferStatus glad_glCheckNamedFramebufferStatus
GLAD_API_CALL PFNGLCLAMPCOLORPROC glad_glClampColor;
/**
* @name glClampColor - specify whether data read via glReadPixels should be clamped
* @usage
* @code void glClampColor(GLenum target, GLenum clamp); @endcode
* @param target Target for color clamping. <em class="parameter"><b>target</b></em> must be <b>GL_CLAMP_READ_COLOR</b>.
* @param clamp Specifies whether to apply color clamping. <em class="parameter"><b>clamp</b></em> must be <b>GL_TRUE</b> or <b>GL_FALSE</b>.
* @description
* 	glClampColor controls color clamping that is performed during glReadPixels. target must be GL_CLAMP_READ_COLOR. If clamp
* is GL_TRUE, read color clamping is enabled; if clamp is GL_FALSE, read color clamping is disabled. If clamp is GL_FIXED_ONLY,
* read color clamping is enabled only if the selected read buffer has fixed point components and disabled otherwise.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not GL_CLAMP_READ_COLOR.
* @errors GL_INVALID_ENUM is generated if clamp is not GL_TRUE or GL_FALSE.
*
*/
#define glClampColor glad_glClampColor
GLAD_API_CALL PFNGLCLEARPROC glad_glClear;
/**
* @name glClear - clear buffers to preset values
* @usage
* @code void glClear(GLbitfield mask); @endcode
* @param mask Bitwise OR of masks that indicate the buffers to be cleared. The three masks are <b>GL_COLOR_BUFFER_BIT</b>, <b>GL_DEPTH_BUFFER_BIT</b>,
*             and <b>GL_STENCIL_BUFFER_BIT</b>.
* @description
* 	glClear sets the bitplane area of the window to values previously selected by glClearColor, glClearDepth, and glClearStencil.
* Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using glDrawBuffer.<br>
* 	The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of glClear. The scissor
* box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and
* depth-buffering are ignored by glClear.<br>
* 	glClear takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.<br>
* 	The values are as follows:<br>
* 	Indicates the buffers currently enabled for color writing.<br>
* 	Indicates the depth buffer.<br>
* 	Indicates the stencil buffer.<br>
* 	The value to which each buffer is cleared depends on the setting of the clear value for that buffer.<br>
*
* @note If a buffer is not present, then a glClear directed at that buffer has no effect.
*
* @errors GL_INVALID_VALUE is generated if any bit other than the three defined bits is set in mask.
*
*/
#define glClear glad_glClear
GLAD_API_CALL PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;
/**
* @name glClearBufferData, glClearNamedBufferData - fill a buffer object's data store with a fixed value
* @usage
* @code void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
* @description
* 	glClearBufferData and glClearNamedBufferData fill the entirety of a buffer object's data store with data from client memory.<br>
* 	Data, initially supplied in a format specified by format in data type type is read from the memory address given by data
* and converted into the internal representation given by internalformat, which must be one of the following sized internal
* formats:<br>
* 	This converted data is then replicated throughout the buffer object's data store. If data is NULL, then the buffer's data
* store is filled with zeros.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glClearBufferData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferData if no buffer is bound target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearBufferData glad_glClearBufferData
GLAD_API_CALL PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;
/**
* @name glClearBufferSubData, glClearNamedBufferSubData - fill all or part of buffer object's data store with a fixed value
* @usage
* @code void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferSubData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param offset The offset in basic machine units into the buffer object's data store at which to start filling.
* @param size The size in basic machine units of the range of the data store to fill.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
* @description
* 	glClearBufferSubData and glClearNamedBufferSubData fill a specified region of a buffer object's data store with data from
* client memory.<br>
* 	offset and size specify the extent of the region within the data store of the buffer object to fill with data. Data, initially
* supplied in a format specified by format in data type type is read from the memory address given by data and converted
* into the internal representation given by internalformat, which must be one of the following sized internal formats:<br>
* 	This converted data is then replicated throughout the specified region of the buffer object's data store. If data is NULL,
* then the subrange of the buffer's data store is filled with zeros.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glClearBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferSubData if no buffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_VALUE is generated if offset or range are not multiples of the number of basic machine units per-element for
*         the internal format specified by internalformat. This value may be computed by multiplying the number of components for
*         internalformat from the table by the size of the base type from the table.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearBufferSubData glad_glClearBufferSubData
GLAD_API_CALL PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
// Unable to find the docs for this function!
#define glClearBufferfi glad_glClearBufferfi
GLAD_API_CALL PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
// Unable to find the docs for this function!
#define glClearBufferfv glad_glClearBufferfv
GLAD_API_CALL PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
// Unable to find the docs for this function!
#define glClearBufferiv glad_glClearBufferiv
GLAD_API_CALL PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
// Unable to find the docs for this function!
#define glClearBufferuiv glad_glClearBufferuiv
GLAD_API_CALL PFNGLCLEARCOLORPROC glad_glClearColor;
/**
* @name glClearColor - specify clear values for the color buffers
* @usage
* @code void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); @endcode
* @param red, green, blue, alpha Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
* @description
* 	glClearColor specifies the red, green, blue, and alpha values used by glClear to clear the color buffers. Values specified
* by glClearColor are clamped to the range 01 .<br>
*
* @note The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent
*       to user code and is described in detail on the removedTypes page.
*
*
*/
#define glClearColor glad_glClearColor
GLAD_API_CALL PFNGLCLEARDEPTHPROC glad_glClearDepth;
/**
* @name glClearDepth - specify the clear value for the depth buffer
* @usage
* @code void glClearDepth(GLdouble depth); @endcode
* @code void glClearDepthf(GLfloat depth); @endcode
* @param depth Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
* @description
* 	glClearDepth specifies the depth value used by glClear to clear the depth buffer. Values specified by glClearDepth are
* clamped to the range 01 .<br>
*
* @note The type of the depth parameter was changed from GLclampf to GLfloat for glClearDepthf and from GLclampd to GLdouble for
*       glClearDepth. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glClearDepth glad_glClearDepth
GLAD_API_CALL PFNGLCLEARDEPTHFPROC glad_glClearDepthf;
/**
* @name glClearDepth - specify the clear value for the depth buffer
* @usage
* @code void glClearDepth(GLdouble depth); @endcode
* @code void glClearDepthf(GLfloat depth); @endcode
* @param depth Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
* @description
* 	glClearDepth specifies the depth value used by glClear to clear the depth buffer. Values specified by glClearDepth are
* clamped to the range 01 .<br>
*
* @note The type of the depth parameter was changed from GLclampf to GLfloat for glClearDepthf and from GLclampd to GLdouble for
*       glClearDepth. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glClearDepthf glad_glClearDepthf
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;
/**
* @name glClearBufferData, glClearNamedBufferData - fill a buffer object's data store with a fixed value
* @usage
* @code void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
* @description
* 	glClearBufferData and glClearNamedBufferData fill the entirety of a buffer object's data store with data from client memory.<br>
* 	Data, initially supplied in a format specified by format in data type type is read from the memory address given by data
* and converted into the internal representation given by internalformat, which must be one of the following sized internal
* formats:<br>
* 	This converted data is then replicated throughout the buffer object's data store. If data is NULL, then the buffer's data
* store is filled with zeros.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glClearBufferData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferData if no buffer is bound target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearNamedBufferData glad_glClearNamedBufferData
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;
/**
* @name glClearBufferSubData, glClearNamedBufferSubData - fill all or part of buffer object's data store with a fixed value
* @usage
* @code void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferSubData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param offset The offset in basic machine units into the buffer object's data store at which to start filling.
* @param size The size in basic machine units of the range of the data store to fill.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
* @description
* 	glClearBufferSubData and glClearNamedBufferSubData fill a specified region of a buffer object's data store with data from
* client memory.<br>
* 	offset and size specify the extent of the region within the data store of the buffer object to fill with data. Data, initially
* supplied in a format specified by format in data type type is read from the memory address given by data and converted
* into the internal representation given by internalformat, which must be one of the following sized internal formats:<br>
* 	This converted data is then replicated throughout the specified region of the buffer object's data store. If data is NULL,
* then the subrange of the buffer's data store is filled with zeros.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glClearBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferSubData if no buffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_VALUE is generated if offset or range are not multiples of the number of basic machine units per-element for
*         the internal format specified by internalformat. This value may be computed by multiplying the number of components for
*         internalformat from the table by the size of the base type from the table.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearNamedBufferSubData glad_glClearNamedBufferSubData
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;
// Unable to find the docs for this function!
#define glClearNamedFramebufferfi glad_glClearNamedFramebufferfi
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;
// Unable to find the docs for this function!
#define glClearNamedFramebufferfv glad_glClearNamedFramebufferfv
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;
// Unable to find the docs for this function!
#define glClearNamedFramebufferiv glad_glClearNamedFramebufferiv
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;
// Unable to find the docs for this function!
#define glClearNamedFramebufferuiv glad_glClearNamedFramebufferuiv
GLAD_API_CALL PFNGLCLEARSTENCILPROC glad_glClearStencil;
/**
* @name glClearStencil - specify the clear value for the stencil buffer
* @usage
* @code void glClearStencil(GLint s); @endcode
* @param s Specifies the index used when the stencil buffer is cleared. The initial value is 0.
* @description
* 	glClearStencil specifies the index used by glClear to clear the stencil buffer. s is masked with 2m -1 , where m is the
* number of bits in the stencil buffer.<br>
*
*
*
*/
#define glClearStencil glad_glClearStencil
GLAD_API_CALL PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;
/**
* @name glClearTexImage - fills all a texture image with a constant value
* @usage
* @code void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data); @endcode
* @param texture The name of an existing texture object containing the image to be cleared.
* @param level The level of <em class="parameter"><b>texture</b></em> containing the region to be cleared.
* @param format The format of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param type The type of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param data The address in memory of the data to be used to clear the specified region.
* @description
* 	glClearTexImage fills all an image contained in a texture with an application supplied value. texture must be the name
* of an existing texture. Further, texture may not be the name of a buffer texture, nor may its internal format be compressed.<br>
* 	format and type specify the format and type of the source data and are interpreted as they are for glTexImage3D. Textures
* with a base internal format of GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL require depth component, stencil,
* or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures
* with integer internal formats require integer data.<br>
* 	data is a pointer to an array of between one and four components of texel data that will be used as the source for the
* constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was
* specified when the level was defined by any of the glTexImage*, glTexStorage* or glCopyTexImage* commands), and then used
* to fill the specified range of the destination texture level. If data is NULL, then the pointer is ignored and the sub-range
* of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are
* cleared to the value specified by data.<br>
*
* @note glClearTexImage is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if texture is a buffer texture.
* @errors GL_INVALID_OPERATION is generated if texture has a compressed internal format.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX,
*         or GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data.
* @errors GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data.
* @errors GL_INVALID_OPERATION is generated if the image array identified by level has not previously been defined by a call to glTexImage*
*         or glTexStorage*.
*
*/
#define glClearTexImage glad_glClearTexImage
GLAD_API_CALL PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;
/**
* @name glClearTexSubImage - fills all or part of a texture image with a constant value
* @usage
* @code void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data); @endcode
* @param texture The name of an existing texture object containing the image to be cleared.
* @param level The level of <em class="parameter"><b>texture</b></em> containing the region to be cleared.
* @param xoffset The coordinate of the left edge of the region to be cleared.
* @param yoffset The coordinate of the lower edge of the region to be cleared.
* @param zoffset The coordinate of the front of the region to be cleared.
* @param width The width of the region to be cleared.
* @param height The height of the region to be cleared.
* @param depth The depth of the region to be cleared.
* @param format The format of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param type The type of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param data The address in memory of the data to be used to clear the specified region.
* @description
* 	glClearTexSubImage fills all or part of an image contained in a texture with an application supplied value. texture must
* be the name of an existing texture. Further, texture may not be the name of a buffer texture, nor may its internal format
* be compressed.<br>
* 	Arguments xoffset, yoffset, and zoffset specify the lower left texel coordinates of a width-wide by height-high by depth-deep
* rectangular subregion of the texel array.<br>
* 	For one-dimensional array textures, yoffset is interpreted as the first layer to be cleared and height is the number of
* layers to clear. For two-dimensional array textures, zoffset is interpreted as the first layer to be cleared and depth
* is the number of layers to clear. Cube map textures are treated as an array of six slices in the z-dimension, where the
* value of zoffset is interpreted as specifying the cube map face for the corresponding layer and depth is the number of faces
* to clear. For cube map array textures, zoffset is the first layer-face to clear, and depth is the number of layer-faces
* to clear. Each layer-face is translated into an array layer and a cube map face as described in the OpenGL Specification.<br>
* 	Negative values of xoffset, yoffset, and zoffset correspond to the coordinates of border texels. Taking ws, hs, ds, wb,
* hb, and db to be the specified width, height, depth, and the border width, border height, and border depth of the texel
* array and taking x, y, z, w, h, and d to be the xoffset, yoffset, zoffset, width, height, and depth argument values, any
* of the following relationships generates a GL_INVALID_OPERATION error:<br>
* 	For texture types that do not have certain dimensions, this command treats those dimensions as having a size of 1. For
* example, to clear a portion of a two-dimensional texture, use zoffset equal to zero and depth equal to one.<br>
* 	format and type specify the format and type of the source data and are interpreted as they are for glTexImage3D. Textures
* with a base internal format of GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL require depth component, stencil,
* or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures
* with integer internal formats require integer data.<br>
* 	data is a pointer to an array of between one and four components of texel data that will be used as the source for the
* constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was
* specified when the level was defined by any of the glTexImage*, glTexStorage* or glCopyTexImage* commands), and then used
* to fill the specified range of the destination texture level. If data is NULL, then the pointer is ignored and the sub-range
* of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are
* cleared to the value specified by data.<br>
*
* @note glClearTexSubImage is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if texture is a buffer texture.
* @errors GL_INVALID_OPERATION is generated if texture has a compressed internal format.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX,
*         or GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data.
* @errors GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data.
* @errors GL_INVALID_OPERATION error is generated if the xoffset, yoffset, zoffset, width, height, and depth parameters (or combinations
*         thereof) specify a region that falls outside the defined texture image array (including border, if any).
*
*/
#define glClearTexSubImage glad_glClearTexSubImage
GLAD_API_CALL PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
/**
* @name glClientWaitSync - block and wait for a sync object to become signaled
* @usage
* @code GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout); @endcode
* @param sync The sync object whose status to wait on.
* @param flags A bitfield controlling the command flushing behavior. <em class="parameter"><b>flags</b></em> may be <b>GL_SYNC_FLUSH_COMMANDS_BIT</b>.
* @param timeout The timeout, specified in nanoseconds, for which the implementation should wait for <em class="parameter"><b>sync</b></em>
*                to become signaled.
* @description
* 	glClientWaitSync causes the client to block and wait for the sync object specified by sync to become signaled. If sync
* is signaled when glClientWaitSync is called, glClientWaitSync returns immediately, otherwise it will block and wait for
* up to timeout nanoseconds for sync to become signaled.<br>
* 	The return value is one of four status values:<br>
* 	GL_ALREADY_SIGNALED indicates that sync was signaled at the time that glClientWaitSync was called.<br>
* 	GL_TIMEOUT_EXPIRED indicates that at least timeout nanoseconds passed and sync did not become signaled.<br>
* 	GL_CONDITION_SATISFIED indicates that sync was signaled before the timeout expired.<br>
* 	GL_WAIT_FAILED indicates that an error occurred. Additionally, an OpenGL error will be generated.<br>
*
* @note glClientWaitSync is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_VALUE is generated if sync is not the name of an existing sync object.
* @errors GL_INVALID_VALUE is generated if flags contains any unsupported flag.
*
*/
#define glClientWaitSync glad_glClientWaitSync
GLAD_API_CALL PFNGLCLIPCONTROLPROC glad_glClipControl;
/**
* @name glClipControl - control clip coordinate to window coordinate behavior
* @usage
* @code void glClipControl(GLenum origin, GLenum depth); @endcode
* @param origin Specifies the clip control origin. Must be one of <b>GL_LOWER_LEFT</b> or <b>GL_UPPER_LEFT</b>.
* @param depth Specifies the clip control depth mode. Must be one of <b>GL_NEGATIVE_ONE_TO_ONE</b> or <b>GL_ZERO_TO_ONE</b>.
* @description
* 	glClipControl controls the clipping volume behavior and the clip coordinate to window coordinate transformation behavior.<br>
* 	The view volume is defined by $$z_{min} \leq z_c \leq w_c$$ where $z_{min} = -w_c$ when depth is GL_NEGATIVE_ONE_TO_ONE,
* and $z_{min} = 0$ when depth is GL_ZERO_TO_ONE.<br>
* 	The normalized device coordinate $y_d$ is given by $$y_d = { { f \times y_c } \over w_c }$$ where $f = 1$ when origin is
* GL_LOWER_LEFT, and $f = -1$ when origin is GL_UPPER_LEFT.<br>
* 	The window coordinate $z_w$ is given by $$z_w = s \times z_d + b$$ where $s = { { f - n } \over 2 }$ and $b = { {n + f}
* \over 2 }$ when depth is GL_NEGATIVE_ONE_TO_ONE, and $s = f - n$ and $b = n$ when depth is GL_ZERO_TO_ONE. $n$ and $f$
* are the near and far depth range values set with glDepthRange.<br>
* 	Finally, the polygon area computation defined by gl_FrontFacing to determine if a polygon is front- or back-facing has
* its sign negated when origin is GL_UPPER_LEFT.<br>
*
* @note The default GL clip volume definition is for a origin of GL_LOWER_LEFT and a depth of GL_NEGATIVE_ONE_TO_ONE.
* @note An origin of GL_UPPER_LEFT and a depth of GL_ZERO_TO_ONE corresponds to Direct3D's clip volume definition.
* @note An origin of GL_UPPER_LEFT and a depth of GL_NEGATIVE_ONE_TO_ONE corresponds to the upper-left origin of the window coordinate
*       system of Microsoft Windows and the X Window System.
* @note There is extensive discussion of the uses and further consequences of the different clip volume settings in the GL_ARB_clip_control
*       extension specification in the OpenGL Registry at URL http://www.opengl.org/registry/.
*
* @errors An GL_INVALID_ENUM error is generated if origin is not GL_LOWER_LEFT or GL_UPPER_LEFT.
* @errors An GL_INVALID_ENUM error is generated if depth is not GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE.
*
*/
#define glClipControl glad_glClipControl
GLAD_API_CALL PFNGLCOLORMASKPROC glad_glColorMask;
/**
* @name glColorMask, glColorMaski - enable and disable writing of frame buffer color components
* @usage
* @code void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); @endcode
* @param buf For <b>glColorMaski</b>, specifies the index of the draw buffer whose color mask to set.
* @param red, green, blue, alpha Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all <b>GL_TRUE</b>,
*                                indicating that the color components are written.
* @description
* 	glColorMask and glColorMaski specify whether the individual color components in the frame buffer can or cannot be written.
* glColorMaski sets the mask for a specific draw buffer, whereas glColorMask sets the mask for all draw buffers. If red
* is GL_FALSE, for example, no change is made to the red component of any pixel in any of the color buffers, regardless
* of the drawing operation attempted.<br>
* 	Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire
* color components.<br>
*
*
*
*/
#define glColorMask glad_glColorMask
GLAD_API_CALL PFNGLCOLORMASKIPROC glad_glColorMaski;
// Unable to find the docs for this function!
#define glColorMaski glad_glColorMaski
GLAD_API_CALL PFNGLCOMPILESHADERPROC glad_glCompileShader;
/**
* @name glCompileShader - Compiles a shader object
* @usage
* @code void glCompileShader(GLuint shader); @endcode
* @param shader Specifies the shader object to be compiled.
* @description
* 	glCompileShader compiles the source code strings that have been stored in the shader object specified by shader.<br>
* 	The compilation status will be stored as part of the shader object's state. This value will be set to GL_TRUE if the shader
* was compiled without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling glGetShader
* with arguments shader and GL_COMPILE_STATUS.<br>
* 	Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether
* or not the compilation was successful, information about the compilation can be obtained from the shader object's information
* log by calling glGetShaderInfoLog.<br>
*
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
*
*/
#define glCompileShader glad_glCompileShader
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
/**
* @name glCompressedTexImage1D - specify a one-dimensional texture image in a compressed format
* @usage
* @code void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_1D</b> or <b>GL_PROXY_TEXTURE_1D</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param width Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The
*              height of the 1D texture image is 1.
* @param border This value must be 0.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexImage1D loads a previously defined, and retrieved, compressed one-dimensional texture image if target is
* GL_TEXTURE_1D (see glTexImage1D).<br>
* 	If target is GL_PROXY_TEXTURE_1D, no data is read from data, but all of the texture image state is recalculated, checked
* for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture
* of the requested texture size, it sets all of the image state to 0, but does not generate an error (see glGetError). To
* query for an entire mipmap array, use an image array level greater than or equal to 1.<br>
* 	internalformat must be an extension-specified compressed-texture format. When a texture is loaded with glTexImage1D using
* a generic compressed  texture format (e.g., GL_COMPRESSED_RGB) the GL selects from one of its extensions supporting compressed
* textures.  In order to load the compressed texture image using glCompressedTexImage1D, query the compressed texture
* image's size and format using glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
* 	If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle
* from a larger containing rectangle. These pixel storage modes operate in the same way as they do for glTexImage1D.
* In the following description, denote by bs, bw, bh, and bd the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE,
* GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT, and GL_UNPACK_COMPRESSED_BLOCK_DEPTH,
* respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth
* in pixels.<br>
* 	By default the pixel storage modes GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_IMAGE_HEIGHT
* and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH,
* bs and bw must both be non-zero. To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT, bh must be non-zero.
* To also enable GL_UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must be consistent with the compressed format
* to produce the desired results.<br>
* 	When selecting a sub-rectangle from a compressed image,<br>
* 	the value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw<br>
* 	imageSize must be equal to:<br>
* 	bs × width bw<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is not a supported specific compressed internal formats, or is one of the
*         generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB,
*         or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexImage1D glad_glCompressedTexImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
/**
* @name glCompressedTexImage2D - specify a two-dimensional texture image in a compressed format
* @usage
* @code void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param width Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at
*              least 16384 texels wide.
* @param height Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at
*               least 16384 texels high.
* @param border This value must be 0.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexImage2D loads a previously defined, and retrieved, compressed two-dimensional texture image if target is
* GL_TEXTURE_2D, or one of the cube map faces such as GL_TEXTURE_CUBE_MAP_POSITIVE_X. (see glTexImage2D).<br>
* 	If target is GL_TEXTURE_1D_ARRAY, data is treated as an array of compressed 1D textures.<br>
* 	If target is GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP, no data is read from data, but
* all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.
*  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to
* 0, but does not generate an error (see glGetError). To query for an entire mipmap array, use an image array level greater
* than or equal to 1.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* When a texture is loaded with glTexImage2D using a generic compressed texture format (e.g., GL_COMPRESSED_RGB), the
* GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image
* using glCompressedTexImage2D, query the compressed texture image's size and format using glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
* 	If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle
* from a larger containing rectangle. These pixel storage modes operate in the same way as they do for glTexImage2D.
* In the following description, denote by bs, bw, bh, and bd, the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE,
* GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT, and GL_UNPACK_COMPRESSED_BLOCK_DEPTH,
* respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth
* in pixels.<br>
* 	By default the pixel storage modes GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_IMAGE_HEIGHT
* and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH,
* bs and bw must both be non-zero. To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT, bh must be non-zero.
* To also enable GL_UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must be consistent with the compressed format
* to produce the desired results.<br>
* 	When selecting a sub-rectangle from a compressed image:<br>
* 	The value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;<br>
* 	the value of GL_UNPACK_SKIP_ROWS must be a multiple of bw.<br>
* 	imageSize must be equal to:<br>
* 	bs × width bw × height bh<br>
*
* @note The specific compressed internal formats GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
*       GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
*       GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, and GL_COMPRESSED_SIGNED_RG11_EAC
*       are available only if the GL version is 4.3 or higher.
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the specific compressed internal formats: GL_COMPRESSED_RED_RGTC1,
*         GL_COMPRESSED_SIGNED_RED_RGTC1, GL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2. GL_COMPRESSED_RGBA_BPTC_UNORM,
*         GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, GL_COMPRESSED_RGB8_ETC2,
*         GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
*         GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC,
*         GL_COMPRESSED_RG11_EAC, or GL_COMPRESSED_SIGNED_RG11_EAC.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexImage2D glad_glCompressedTexImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
/**
* @name glCompressedTexImage3D - specify a three-dimensional texture image in a compressed format
* @usage
* @code void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_TEXTURE_2D_ARRAY</b> or <b>GL_PROXY_TEXTURE_2D_ARRAY</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param width Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
* @param height Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
* @param depth Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
* @param border This value must be 0.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexImage3D loads a previously defined, and retrieved, compressed three-dimensional texture image if target
* is GL_TEXTURE_3D (see glTexImage3D).<br>
* 	If target is GL_TEXTURE_2D_ARRAY, data is treated as an array of compressed 2D textures.<br>
* 	If target is GL_PROXY_TEXTURE_3D or GL_PROXY_TEXTURE_2D_ARRAY, no data is read from data, but all of the texture image
* state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation
* cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate
* an error (see glGetError). To query for an entire mipmap array, use an image array level greater than or equal to 1.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* When a texture is loaded with glTexImage2D using a generic compressed texture format (e.g., GL_COMPRESSED_RGB), the
* GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image
* using glCompressedTexImage3D, query the compressed texture image's size and format using glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
* 	If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle
* from a larger containing rectangle. These pixel storage modes operate in the same way as they do for glTexImage1D.
* In the following description, denote by bs, bw, bh, and bd the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE,
* GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT, and GL_UNPACK_COMPRESSED_BLOCK_DEPTH,
* respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth
* in pixels.<br>
* 	By default the pixel storage modes GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_IMAGE_HEIGHT
* and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH,
* bs and bw must both be non-zero. To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT, bh must be non-zero.
* To also enable GL_UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must be consistent with the compressed format
* to produce the desired results.<br>
* 	When selecting a sub-rectangle from a compressed image:<br>
* 	the value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;<br>
* 	the value of GL_UNPACK_SKIP_ROWS must be a multiple of bw;<br>
* 	the value of GL_UNPACK_SKIP_IMAGES must be a multiple of bw.<br>
* 	imageSize must be equal to:<br>
* 	bs × width bw × height bh × depth bd<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED,
*         GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexImage3D glad_glCompressedTexImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
/**
* @name glCompressedTexSubImage1D, glCompressedTextureSubImage1D - specify a one-dimensional texture subimage in a compressed
format
* @usage
* @code void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target, to which the texture is bound, for <b>glCompressedTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexSubImage1D and glCompressedTextureSubImage1D redefine a contiguous subregion of an existing one-dimensional
* texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset
* and xoffset+width-1 , inclusive.  This region may not include any texels outside the range of the texture array as it
* was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage1D),
* and should be queried at the time the texture was compressed with glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED,
*         GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage1D function if texture is not the name of an existing texture
*         object.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexSubImage1D glad_glCompressedTexSubImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
/**
* @name glCompressedTexSubImage2D, glCompressedTextureSubImage2D - specify a two-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, or <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexSubImage2D and glCompressedTextureSubImage2D redefine a contiguous subregion of an existing two-dimensional
* texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset
* and xoffset+width-1 , and the y indices yoffset and yoffset+height-1 , inclusive. This region may not include any texels
* outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with
* width of 0, but such a specification has no effect.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage2D)
* and should be queried at the time the texture was compressed with glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage2D if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if the effective target is GL_TEXTURE_RECTANGLE.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexSubImage2D glad_glCompressedTexSubImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
/**
* @name glCompressedTexSubImage3D, glCompressedTextureSubImage3D - specify a three-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage3D</b> function. Must be <b>GL_TEXTURE_2D_ARRAY</b>,
*               <b>GL_TEXTURE_3D</b>, or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexSubImage3D and glCompressedTextureSubImage3D redefine a contiguous subregion of an existing three-dimensional
* texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset
* and xoffset+width-1 , and the y indices yoffset and yoffset+height-1 , and the z indices zoffset and zoffset+depth-1
* , inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified.
*  It is not an error to specify a subtexture with width of 0, but such a specification has no effect.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage3D)
* and should be queried at the time the texture was compressed with glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage3D if target is not GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexSubImage3D glad_glCompressedTexSubImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;
/**
* @name glCompressedTexSubImage1D, glCompressedTextureSubImage1D - specify a one-dimensional texture subimage in a compressed
format
* @usage
* @code void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target, to which the texture is bound, for <b>glCompressedTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexSubImage1D and glCompressedTextureSubImage1D redefine a contiguous subregion of an existing one-dimensional
* texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset
* and xoffset+width-1 , inclusive.  This region may not include any texels outside the range of the texture array as it
* was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage1D),
* and should be queried at the time the texture was compressed with glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED,
*         GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage1D function if texture is not the name of an existing texture
*         object.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTextureSubImage1D glad_glCompressedTextureSubImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;
/**
* @name glCompressedTexSubImage2D, glCompressedTextureSubImage2D - specify a two-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, or <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexSubImage2D and glCompressedTextureSubImage2D redefine a contiguous subregion of an existing two-dimensional
* texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset
* and xoffset+width-1 , and the y indices yoffset and yoffset+height-1 , inclusive. This region may not include any texels
* outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with
* width of 0, but such a specification has no effect.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage2D)
* and should be queried at the time the texture was compressed with glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage2D if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if the effective target is GL_TEXTURE_RECTANGLE.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTextureSubImage2D glad_glCompressedTextureSubImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;
/**
* @name glCompressedTexSubImage3D, glCompressedTextureSubImage3D - specify a three-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage3D</b> function. Must be <b>GL_TEXTURE_2D_ARRAY</b>,
*               <b>GL_TEXTURE_3D</b>, or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	glCompressedTexSubImage3D and glCompressedTextureSubImage3D redefine a contiguous subregion of an existing three-dimensional
* texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset
* and xoffset+width-1 , and the y indices yoffset and yoffset+height-1 , and the z indices zoffset and zoffset+depth-1
* , inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified.
*  It is not an error to specify a subtexture with width of 0, but such a specification has no effect.<br>
* 	internalformat must be a known compressed image format (such as GL_RGTC) or an extension-specified compressed-texture format.
* The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage3D)
* and should be queried at the time the texture was compressed with glGetTexLevelParameter.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
*
*
* @errors GL_INVALID_ENUM is generated if internalformat is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage3D if target is not GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTextureSubImage3D glad_glCompressedTextureSubImage3D
GLAD_API_CALL PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
/**
* @name glCopyBufferSubData, glCopyNamedBufferSubData - copy all or part of the data store of a buffer object to the data store of another buffer object
* @usage
* @code void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @code void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @param readTarget Specifies the target to which the source buffer object is bound for <b>glCopyBufferSubData</b>
* @param writeTarget Specifies the target to which the destination buffer object is bound for <b>glCopyBufferSubData</b>.
* @param readBuffer Specifies the name of the source buffer object for <b>glCopyNamedBufferSubData</b>.
* @param writeBuffer Specifies the name of the destination buffer object for <b>glCopyNamedBufferSubData</b>.
* @param readOffset Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
* @param writeOffset Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will
*                    be written.
* @param size Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer
*             object.
* @description
* 	glCopyBufferSubData and glCopyNamedBufferSubData copy part of the data store attached to a source buffer object to the
* data store attached to a destination buffer object. The number of basic machine units indicated by size is copied from the
* source at offset readOffset to the destination at writeOffset. readOffset, writeOffset and size are in terms of basic
* machine units.<br>
* 	For glCopyBufferSubData, readTarget and writeTarget specify the targets to which the source and destination buffer objects
* are bound, and must each be one of the buffer binding targets in the following table:<br>
* 	Any of these targets may be used, but the targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided specifically
* to allow copies between buffers without disturbing other GL state.<br>
* 	readOffset, writeOffset and size must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed
* the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to writeTarget.
* If the source and destination are the same buffer object, then the source and destination ranges must not overlap.<br>
*
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glCopyBufferSubData if readTarget or writeTarget is not one of the buffer binding targets
*         listed above.
* @errors GL_INVALID_OPERATION is generated by glCopyBufferSubData if zero is bound to readTarget or writeTarget.
* @errors GL_INVALID_OPERATION is generated by glCopyNamedBufferSubData if readBuffer or writeBuffer is not the name of an existing
*         buffer object.
* @errors GL_INVALID_VALUE is generated if any of readOffset, writeOffset or size is negative, if $readOffset + size$ is greater than
*         the size of the source buffer object (its value of GL_BUFFER_SIZE), or if $writeOffset + size$ is greater than the size
*         of the destination buffer object.
* @errors GL_INVALID_VALUE is generated if the source and destination are the same buffer object, and the ranges $[readOffset,readOffset+size)$
*         and $[writeOffset,writeOffset+size)$ overlap.
* @errors GL_INVALID_OPERATION is generated if either the source or destination buffer object is mapped with glMapBufferRange or glMapBuffer,
*         unless they were mapped with the GL_MAP_PERSISTENT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glCopyBufferSubData glad_glCopyBufferSubData
GLAD_API_CALL PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;
/**
* @name glCopyImageSubData - perform a raw data copy between two images
* @usage
* @code void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth); @endcode
* @param srcName The name of a texture or renderbuffer object from which to copy.
* @param srcTarget The target representing the namespace of the source name <em class="parameter"><b>srcName</b></em>.
* @param srcLevel The mipmap level to read from the source.
* @param srcX The X coordinate of the left edge of the souce region to copy.
* @param srcY The Y coordinate of the top edge of the souce region to copy.
* @param srcZ The Z coordinate of the near edge of the souce region to copy.
* @param dstName The name of a texture or renderbuffer object to which to copy.
* @param dstTarget The target representing the namespace of the destination name <em class="parameter"><b>dstName</b></em>.
* @param dstX The X coordinate of the left edge of the destination region.
* @param dstY The Y coordinate of the top edge of the destination region.
* @param dstZ The Z coordinate of the near edge of the destination region.
* @param srcWidth The width of the region to be copied.
* @param srcHeight The height of the region to be copied.
* @param srcDepth The depth of the region to be copied.
* @description
* 	glCopyImageSubData may be used to copy data from one image (i.e. texture or renderbuffer) to another. glCopyImageSubData
* does not perform general-purpose conversions such as scaling, resizing, blending, color-space, or format conversions.
* It should be considered to operate in a manner similar to a CPU memcpy. CopyImageSubData can copy between images with different
* internal formats, provided the formats are compatible.<br>
* 	glCopyImageSubData also allows copying between certain types of compressed and uncompressed internal formats. This copy
* does not perform on-the-fly compression or decompression. When copying from an uncompressed internal format to a compressed
* internal format, each texel of uncompressed data becomes a single block of compressed data. When copying from a compressed
* internal format to an uncompressed internal format, a block of compressed data becomes a single texel of uncompressed
* data. The texel size of the uncompressed format must be the same size the block size of the compressed formats. Thus
* it is permitted to copy between a 128-bit uncompressed format and a compressed format which uses 8-bit 4x4 blocks, or
* between a 64-bit uncompressed format and a compressed format which uses 4-bit 4x4 blocks.<br>
* 	The source object is identified by srcName and srcTarget and the destination object is identified by dstName and dstTarget.
* The interpretation of the name depends on the value of the corresponding target parameter. If target is GL_RENDERBUFFER,
* the name is interpreted as the name of a renderbuffer object.  If the target parameter is a texture target, the name
* is interpreted as a texture object.  All non-proxy texture targets are accepted, with the exception of GL_TEXTURE_BUFFER
* and the cubemap face selectors.<br>
* 	srcLevel and dstLevel identify the source and destination level of detail.  For textures, this must be a valid level of
* detail in the texture object.  For renderbuffers, this value must be zero.<br>
* 	srcX, srcY, and srcZ specify the lower left texel coordinates of a srcWidth-wide by srcHeight-high by srcDepth-deep rectangular
* subregion of the source texel array. Similarly, dstX, dstY and dstZ specify the coordinates of a subregion of the
* destination texel array.  The source and destination subregions must be contained entirely within the specified level
* of the corresponding image objects.<br>
* 	The dimensions are always specified in texels, even for compressed texture formats. However, it should be noted that if
* only one of the source and destination textures is compressed then the number of texels touched in the compressed image
* will be a factor of the block size larger than in the uncompressed image.<br>
* 	Slices of a GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAYGL_TEXTURE_3D and faces of GL_TEXTURE_CUBE_MAP
* are all compatible provided they share a compatible internal format, and multiple slices or faces may be copied between
* these objects with a single call by specifying the starting slice with srcZ and dstZ, and the number of slices to
* be copied with srcDepth.  Cubemap textures always have six faces which are selected by a zero-based face index.<br>
* 	For the purposes of CopyImageSubData, two internal formats are considered compatible if any of the following conditions
* are met:<br>
* 	the formats are the same,<br>
* 	the formats are considered compatible according to the compatibility rules used for texture views as defined in section
* 3.9.X. In particular, if both internal formats are listed in the same entry of Table 3.X.2, they are considered compatible,
* or<br>
* 	one format is compressed and the other is uncompressed and Table 4.X.1 lists the two formats in the same row.<br>
* 	If the formats are not compatible, an INVALID_OPERATION error is generated.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if the texel size of the uncompressed image is not equal to the block size of the compressed
*         image.
* @errors GL_INVALID_ENUM is generated if either target parameter is not GL_RENDERBUFFER, a valid non-proxy texture target other than
*         GL_TEXTURE_BUFFER, or is one of the cubemap face selectors.
* @errors GL_INVALID_ENUM is generated if target does not match the type of the object.
* @errors GL_INVALID_OPERATION is generated if either object is a texture and the texture is not complete.
* @errors GL_INVALID_OPERATION is generated if the source and destination internal formats are not compatible, or if the number of
*         samples do not match.
* @errors GL_INVALID_VALUE is generated if either name does not correspond to a valid renderbuffer or texture object according to
*         the corresponding target parameter.
* @errors GL_INVALID_VALUE is generated if the specified level of either the source or destination is not a valid level for the corresponding
*         image.
* @errors GL_INVALID_VALUE is generated if the dimensions of the either subregion exceeds the boundaries of the corresponding image
*         object, or if the image format is compressed and the dimensions of the subregion fail to meet the alignment constraints
*         of the format.
*
*/
#define glCopyImageSubData glad_glCopyImageSubData
GLAD_API_CALL PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;
/**
* @name glCopyBufferSubData, glCopyNamedBufferSubData - copy all or part of the data store of a buffer object to the data store of another buffer object
* @usage
* @code void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @code void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @param readTarget Specifies the target to which the source buffer object is bound for <b>glCopyBufferSubData</b>
* @param writeTarget Specifies the target to which the destination buffer object is bound for <b>glCopyBufferSubData</b>.
* @param readBuffer Specifies the name of the source buffer object for <b>glCopyNamedBufferSubData</b>.
* @param writeBuffer Specifies the name of the destination buffer object for <b>glCopyNamedBufferSubData</b>.
* @param readOffset Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
* @param writeOffset Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will
*                    be written.
* @param size Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer
*             object.
* @description
* 	glCopyBufferSubData and glCopyNamedBufferSubData copy part of the data store attached to a source buffer object to the
* data store attached to a destination buffer object. The number of basic machine units indicated by size is copied from the
* source at offset readOffset to the destination at writeOffset. readOffset, writeOffset and size are in terms of basic
* machine units.<br>
* 	For glCopyBufferSubData, readTarget and writeTarget specify the targets to which the source and destination buffer objects
* are bound, and must each be one of the buffer binding targets in the following table:<br>
* 	Any of these targets may be used, but the targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided specifically
* to allow copies between buffers without disturbing other GL state.<br>
* 	readOffset, writeOffset and size must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed
* the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to writeTarget.
* If the source and destination are the same buffer object, then the source and destination ranges must not overlap.<br>
*
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glCopyBufferSubData if readTarget or writeTarget is not one of the buffer binding targets
*         listed above.
* @errors GL_INVALID_OPERATION is generated by glCopyBufferSubData if zero is bound to readTarget or writeTarget.
* @errors GL_INVALID_OPERATION is generated by glCopyNamedBufferSubData if readBuffer or writeBuffer is not the name of an existing
*         buffer object.
* @errors GL_INVALID_VALUE is generated if any of readOffset, writeOffset or size is negative, if $readOffset + size$ is greater than
*         the size of the source buffer object (its value of GL_BUFFER_SIZE), or if $writeOffset + size$ is greater than the size
*         of the destination buffer object.
* @errors GL_INVALID_VALUE is generated if the source and destination are the same buffer object, and the ranges $[readOffset,readOffset+size)$
*         and $[writeOffset,writeOffset+size)$ overlap.
* @errors GL_INVALID_OPERATION is generated if either the source or destination buffer object is mapped with glMapBufferRange or glMapBuffer,
*         unless they were mapped with the GL_MAP_PERSISTENT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glCopyNamedBufferSubData glad_glCopyNamedBufferSubData
GLAD_API_CALL PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
/**
* @name glCopyTexImage1D - copy pixels into a 1D texture image
* @usage
* @code void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_1D</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: <b>GL_COMPRESSED_RED</b>,
*                       <b>GL_COMPRESSED_RG</b>, <b>GL_COMPRESSED_RGB</b>, <b>GL_COMPRESSED_RGBA</b>. <b>GL_COMPRESSED_SRGB</b>, <b>GL_COMPRESSED_SRGB_ALPHA</b>.
*                       <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>, <b>GL_DEPTH_COMPONENT24</b>, <b>GL_DEPTH_COMPONENT32</b>,
*                       <b>GL_STENCIL_INDEX8</b>, <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_R3_G3_B2</b>, <b>GL_RGB4</b>, <b>GL_RGB5</b>,
*                       <b>GL_RGB8</b>, <b>GL_RGB10</b>, <b>GL_RGB12</b>, <b>GL_RGB16</b>, <b>GL_RGBA</b>, <b>GL_RGBA2</b>, <b>GL_RGBA4</b>,
*                       <b>GL_RGB5_A1</b>, <b>GL_RGBA8</b>, <b>GL_RGB10_A2</b>, <b>GL_RGBA12</b>, <b>GL_RGBA16</b>, <b>GL_SRGB</b>,
*                       <b>GL_SRGB8</b>, <b>GL_SRGB_ALPHA</b>, or <b>GL_SRGB8_ALPHA8</b>.
* @param x, y Specify the window coordinates of the left corner of the row of pixels to be copied.
* @param width Specifies the width of the texture image. The height of the texture image is 1.
* @param border Must be 0.
* @description
* 	glCopyTexImage1D defines a one-dimensional texture image with pixels from the current GL_READ_BUFFER.<br>
* 	The screen-aligned pixel row with left corner at xy and with a length of width defines the texture array at the mipmap
* level specified by level. internalformat specifies the internal format of the texture array.<br>
* 	The pixels in the row are processed exactly as if glReadPixels had been called, but the process stops just before final
* conversion. At this point all pixel component values are clamped to the range 01 and then converted to the texture's internal
* format for storage in the texel array.<br>
* 	Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates.<br>
* 	If any of the pixels within the specified row of the current GL_READ_BUFFER are outside the window associated with the
* current rendering context, then the values obtained for those pixels are undefined.<br>
* 	glCopyTexImage1D defines a one-dimensional texture image with pixels from the current GL_READ_BUFFER.<br>
* 	When internalformat is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color
* space.  In this case, the glPixelMap function can be used to accomplish the conversion.<br>
*
* @note 1, 2, 3, and 4 are not accepted values for internalformat.
* @note An image with 0 width indicates a NULL texture.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁢max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not an allowable value.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32 and there is no depth buffer.
*
*/
#define glCopyTexImage1D glad_glCopyTexImage1D
GLAD_API_CALL PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
/**
* @name glCopyTexImage2D - copy pixels into a 2D texture image
* @usage
* @code void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               or <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: <b>GL_COMPRESSED_RED</b>,
*                       <b>GL_COMPRESSED_RG</b>, <b>GL_COMPRESSED_RGB</b>, <b>GL_COMPRESSED_RGBA</b>. <b>GL_COMPRESSED_SRGB</b>, <b>GL_COMPRESSED_SRGB_ALPHA</b>.
*                       <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>, <b>GL_DEPTH_COMPONENT24</b>, <b>GL_DEPTH_COMPONENT32</b>,
*                       <b>GL_STENCIL_INDEX8</b>, <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_R3_G3_B2</b>, <b>GL_RGB4</b>, <b>GL_RGB5</b>,
*                       <b>GL_RGB8</b>, <b>GL_RGB10</b>, <b>GL_RGB12</b>, <b>GL_RGB16</b>, <b>GL_RGBA</b>, <b>GL_RGBA2</b>, <b>GL_RGBA4</b>,
*                       <b>GL_RGB5_A1</b>, <b>GL_RGBA8</b>, <b>GL_RGB10_A2</b>, <b>GL_RGBA12</b>, <b>GL_RGBA16</b>, <b>GL_SRGB</b>,
*                       <b>GL_SRGB8</b>, <b>GL_SRGB_ALPHA</b>, or <b>GL_SRGB8_ALPHA8</b>.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture image.
* @param height Specifies the height of the texture image.
* @param border Must be 0.
* @description
* 	glCopyTexImage2D defines a two-dimensional texture image, or cube-map texture image with pixels from the current GL_READ_BUFFER.<br>
* 	The screen-aligned pixel rectangle with lower left corner at (x, y) and with a width of width and a height of height defines
* the texture array at the mipmap level specified by level. internalformat specifies the internal format of the texture
* array.<br>
* 	The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the process stops just before
* final conversion. At this point all pixel component values are clamped to the range 01 and then converted to the texture's
* internal format for storage in the texel array.<br>
* 	Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.<br>
* 	If any of the pixels within the specified rectangle of the current GL_READ_BUFFER are outside the window associated with
* the current rendering context, then the values obtained for those pixels are undefined.<br>
* 	When internalformat is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color
* space.  In this case, the glPixelMap function can be used to accomplish the conversion.<br>
*
* @note 1, 2, 3, and 4 are not accepted values for internalformat.
* @note An image with height or width of 0 indicates a NULL texture.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁢max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_VALUE is generated if internalformat is not an accepted format.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32 and there is no depth buffer.
*
*/
#define glCopyTexImage2D glad_glCopyTexImage2D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
/**
* @name glCopyTexSubImage1D, glCopyTextureSubImage1D - copy a one-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @code void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies the texel offset within the texture array.
* @param x, y Specify the window coordinates of the left corner of the row of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @description
* 	glCopyTexSubImage1D and glCopyTextureSubImage1D replace a portion of a one-dimensional texture image with pixels from the
* current GL_READ_BUFFER (rather than from main memory, as is the case for glTexSubImage1D). For glCopyTexSubImage1D, the
* texture object that is bound to target will be used for the process. For glCopyTextureSubImage1D, texture tells which
* texture object should be used for the purpose of the call.<br>
* 	The screen-aligned pixel row with left corner at (x,\ y), and with length width replaces the portion of the texture array
* with x indices xoffset through xoffset+width-1 , inclusive. The destination in the texture array may not include any
* texels outside the texture array as it was originally specified.<br>
* 	The pixels in the row are processed exactly as if glReadPixels had been called, but the process stops just before final
* conversion. At this point, all pixel component values are clamped to the range  01 and then converted to the texture's
* internal format for storage in the texel array.<br>
* 	It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels
* within the specified row of the current GL_READ_BUFFER are outside the read window associated with the current rendering
* context, then the values obtained for those pixels are undefined.<br>
* 	No change is made to the internalformat or width parameters of the specified texture array or to texel values outside the
* specified subregion.<br>
*
* @note The glPixelStore mode affects texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage1D if target is not GL_TEXTURE_1D.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage1D if texture is not the name of an existing texture object, or
*         if the effective target of texture is not GL_TEXTURE_1D.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D, glCopyTexImage1D,
*         or glTexStorage1D operation.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , or xoffset+width >w , where w is the GL_TEXTURE_WIDTH of the texture image
*         being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTexSubImage1D glad_glCopyTexSubImage1D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
/**
* @name glCopyTexSubImage2D, glCopyTextureSubImage2D - copy a two-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               or <b>GL_TEXTURE_RECTANGLE</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @description
* 	glCopyTexSubImage2D and glCopyTextureSubImage2D replace a rectangular portion of a two-dimensional texture image, cube-map
* texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with
* pixels from the current GL_READ_BUFFER (rather than from main memory, as is the case for glTexSubImage2D).<br>
* 	The screen-aligned pixel rectangle with lower left corner at xy and with width width and height height replaces the portion
* of the texture array with x indices xoffset through  xoffset+width-1 , inclusive, and y indices yoffset through  yoffset+height-1
* , inclusive, at the mipmap level specified by level.<br>
* 	The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the process stops just before
* final conversion. At this point, all pixel component values are clamped to the range $[0,1]$ and then converted to the
* texture's internal format for storage in the texel array.<br>
* 	The destination rectangle in the texture array may not include any texels outside the texture array as it was originally
* specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.<br>
* 	When target is GL_TEXTURE_1D_ARRAY then the y coordinate and height are treated as the start slice and number of slices
* to modify, respectively.<br>
* 	If any of the pixels within the specified rectangle of the current GL_READ_BUFFER are outside the read window associated
* with the current rendering context, then the values obtained for those pixels are undefined.<br>
* 	No change is made to the internalformat, width or height parameters of the specified texture array, or to texel values
* outside the specified subregion.<br>
*
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
*         GL_TEXTURE_1D_ARRAY or GL_RECTANGLE.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D, glTexStorage2D or
*         glCopyTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if the effective target of texture does not correspond to one
*         of the texture targets supported by the function.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE is generated if the effective target is GL_TEXTURE_RECTANGLE and level is not zero.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 ,  xoffset+width >w , yoffset<0 , or yoffset+height >h , where w is the GL_TEXTURE_WIDTH
*         and h is the GL_TEXTURE_HEIGHT of the texture image being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTexSubImage2D glad_glCopyTexSubImage2D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
/**
* @name glCopyTexSubImage3D, glCopyTextureSubImage3D - copy a three-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage3D</b> function. Must be <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b> or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @description
* 	glCopyTexSubImage3D and glCopyTextureSubImage3D functions replace a rectangular portion of a three-dimensional or two-dimensional
* array texture image with pixels from the current GL_READ_BUFFER (rather than from main memory, as is the case
* for glTexSubImage3D).<br>
* 	The screen-aligned pixel rectangle with lower left corner at (x, y) and with width width and height height replaces the
* portion of the texture array with x indices xoffset through xoffset+width-1 , inclusive, and y indices yoffset through
* yoffset+height-1 , inclusive, at z index zoffset and at the mipmap level specified by level.<br>
* 	The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the process stops just before
* final conversion. At this point, all pixel component values are clamped to the range 01 and then converted to the texture's
* internal format for storage in the texel array.<br>
* 	The destination rectangle in the texture array may not include any texels outside the texture array as it was originally
* specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.<br>
* 	If any of the pixels within the specified rectangle of the current GL_READ_BUFFER are outside the read window associated
* with the current rendering context, then the values obtained for those pixels are undefined.<br>
* 	No change is made to the internalformat, width, height, depth, or border parameters of the specified texture array or to
* texel values outside the specified subregion.<br>
*
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage3D if target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if the effective target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY,
*         GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_CUBE_MAP.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_3D_TEXTURE_SIZE if target
*         is GL_TEXTURE_3D or the returned value of GL_MAX_ARRAY_TEXTURE_LAYERS if target is GL_TEXTURE_2D_ARRAY.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , xoffset+width >w , yoffset<0 , yoffset+height >h , zoffset<0 , or zoffset+1
*         >d , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and of the texture image being
*         modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTexSubImage3D glad_glCopyTexSubImage3D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;
/**
* @name glCopyTexSubImage1D, glCopyTextureSubImage1D - copy a one-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @code void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies the texel offset within the texture array.
* @param x, y Specify the window coordinates of the left corner of the row of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @description
* 	glCopyTexSubImage1D and glCopyTextureSubImage1D replace a portion of a one-dimensional texture image with pixels from the
* current GL_READ_BUFFER (rather than from main memory, as is the case for glTexSubImage1D). For glCopyTexSubImage1D, the
* texture object that is bound to target will be used for the process. For glCopyTextureSubImage1D, texture tells which
* texture object should be used for the purpose of the call.<br>
* 	The screen-aligned pixel row with left corner at (x,\ y), and with length width replaces the portion of the texture array
* with x indices xoffset through xoffset+width-1 , inclusive. The destination in the texture array may not include any
* texels outside the texture array as it was originally specified.<br>
* 	The pixels in the row are processed exactly as if glReadPixels had been called, but the process stops just before final
* conversion. At this point, all pixel component values are clamped to the range  01 and then converted to the texture's
* internal format for storage in the texel array.<br>
* 	It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels
* within the specified row of the current GL_READ_BUFFER are outside the read window associated with the current rendering
* context, then the values obtained for those pixels are undefined.<br>
* 	No change is made to the internalformat or width parameters of the specified texture array or to texel values outside the
* specified subregion.<br>
*
* @note The glPixelStore mode affects texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage1D if target is not GL_TEXTURE_1D.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage1D if texture is not the name of an existing texture object, or
*         if the effective target of texture is not GL_TEXTURE_1D.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D, glCopyTexImage1D,
*         or glTexStorage1D operation.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , or xoffset+width >w , where w is the GL_TEXTURE_WIDTH of the texture image
*         being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTextureSubImage1D glad_glCopyTextureSubImage1D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;
/**
* @name glCopyTexSubImage2D, glCopyTextureSubImage2D - copy a two-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               or <b>GL_TEXTURE_RECTANGLE</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @description
* 	glCopyTexSubImage2D and glCopyTextureSubImage2D replace a rectangular portion of a two-dimensional texture image, cube-map
* texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with
* pixels from the current GL_READ_BUFFER (rather than from main memory, as is the case for glTexSubImage2D).<br>
* 	The screen-aligned pixel rectangle with lower left corner at xy and with width width and height height replaces the portion
* of the texture array with x indices xoffset through  xoffset+width-1 , inclusive, and y indices yoffset through  yoffset+height-1
* , inclusive, at the mipmap level specified by level.<br>
* 	The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the process stops just before
* final conversion. At this point, all pixel component values are clamped to the range $[0,1]$ and then converted to the
* texture's internal format for storage in the texel array.<br>
* 	The destination rectangle in the texture array may not include any texels outside the texture array as it was originally
* specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.<br>
* 	When target is GL_TEXTURE_1D_ARRAY then the y coordinate and height are treated as the start slice and number of slices
* to modify, respectively.<br>
* 	If any of the pixels within the specified rectangle of the current GL_READ_BUFFER are outside the read window associated
* with the current rendering context, then the values obtained for those pixels are undefined.<br>
* 	No change is made to the internalformat, width or height parameters of the specified texture array, or to texel values
* outside the specified subregion.<br>
*
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
*         GL_TEXTURE_1D_ARRAY or GL_RECTANGLE.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D, glTexStorage2D or
*         glCopyTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if the effective target of texture does not correspond to one
*         of the texture targets supported by the function.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE is generated if the effective target is GL_TEXTURE_RECTANGLE and level is not zero.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 ,  xoffset+width >w , yoffset<0 , or yoffset+height >h , where w is the GL_TEXTURE_WIDTH
*         and h is the GL_TEXTURE_HEIGHT of the texture image being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTextureSubImage2D glad_glCopyTextureSubImage2D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;
/**
* @name glCopyTexSubImage3D, glCopyTextureSubImage3D - copy a three-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage3D</b> function. Must be <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b> or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @description
* 	glCopyTexSubImage3D and glCopyTextureSubImage3D functions replace a rectangular portion of a three-dimensional or two-dimensional
* array texture image with pixels from the current GL_READ_BUFFER (rather than from main memory, as is the case
* for glTexSubImage3D).<br>
* 	The screen-aligned pixel rectangle with lower left corner at (x, y) and with width width and height height replaces the
* portion of the texture array with x indices xoffset through xoffset+width-1 , inclusive, and y indices yoffset through
* yoffset+height-1 , inclusive, at z index zoffset and at the mipmap level specified by level.<br>
* 	The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the process stops just before
* final conversion. At this point, all pixel component values are clamped to the range 01 and then converted to the texture's
* internal format for storage in the texel array.<br>
* 	The destination rectangle in the texture array may not include any texels outside the texture array as it was originally
* specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.<br>
* 	If any of the pixels within the specified rectangle of the current GL_READ_BUFFER are outside the read window associated
* with the current rendering context, then the values obtained for those pixels are undefined.<br>
* 	No change is made to the internalformat, width, height, depth, or border parameters of the specified texture array or to
* texel values outside the specified subregion.<br>
*
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage3D if target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if the effective target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY,
*         GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_CUBE_MAP.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_3D_TEXTURE_SIZE if target
*         is GL_TEXTURE_3D or the returned value of GL_MAX_ARRAY_TEXTURE_LAYERS if target is GL_TEXTURE_2D_ARRAY.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , xoffset+width >w , yoffset<0 , yoffset+height >h , zoffset<0 , or zoffset+1
*         >d , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and of the texture image being
*         modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTextureSubImage3D glad_glCopyTextureSubImage3D
GLAD_API_CALL PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;
/**
* @name glCreateBuffers - create buffer objects
* @usage
* @code void glCreateBuffers(GLsizei n, GLuint *buffers); @endcode
* @param n Specifies the number of buffer objects to create.
* @param buffers Specifies an array in which names of the new buffer objects are stored.
* @description
* 	glCreateBuffers returns n previously unused buffer names in buffers, each representing a new buffer object initialized
* as if it had been bound to an unspecified target.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateBuffers glad_glCreateBuffers
GLAD_API_CALL PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;
/**
* @name glCreateFramebuffers - create framebuffer objects
* @usage
* @code void glCreateFramebuffers(GLsizei n, GLuint *framebuffers); @endcode
* @param n Number of framebuffer objects to create.
* @param framebuffers Specifies an array in which names of the new framebuffer objects are stored.
* @description
* 	glCreateFramebuffers returns n previously unused framebuffer names in framebuffers, each representing a new framebuffer
* object initialized to the default state.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateFramebuffers glad_glCreateFramebuffers
GLAD_API_CALL PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
/**
* @name glCreateProgram - Creates a program object
* @usage
* @code GLuint glCreateProgram(void); @endcode
* @description
* 	glCreateProgram creates an empty program object and returns a non-zero value by which it can be referenced. A program object
* is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that
* will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be
* used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When
* no longer needed as part of a program object, shader objects can be detached.<br>
* 	One or more executables are created in a program object by successfully attaching shader objects to it with glAttachShader,
* successfully compiling the shader objects with glCompileShader, and successfully linking the program object with glLinkProgram.
* These executables are made part of current state when glUseProgram is called. Program objects can be deleted
* by calling glDeleteProgram. The memory associated with the program object will be deleted when it is no longer part of
* current rendering state for any context.<br>
*
* @note Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the
*       server sides of the contexts share the same address space. If the name space is shared across contexts, any attached
*       objects and the data associated with those attached objects are shared as well.
* @note Applications are responsible for providing the synchronization across API calls when objects are accessed from different
*       execution threads.
*
* @errors This function returns 0 if an error occurs creating the program object.
*
*/
#define glCreateProgram glad_glCreateProgram
GLAD_API_CALL PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;
/**
* @name glCreateProgramPipelines - create program pipeline objects
* @usage
* @code void glCreateProgramPipelines(GLsizei n, GLuint *pipelines); @endcode
* @param n Number of program pipeline objects to create.
* @param pipelines Specifies an array in which names of the new program pipeline objects are stored.
* @description
* 	glCreateProgramPipelines returns n previously unused program pipeline names in pipelines, each representing a new program
* pipeline object initialized to the default state.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateProgramPipelines glad_glCreateProgramPipelines
GLAD_API_CALL PFNGLCREATEQUERIESPROC glad_glCreateQueries;
/**
* @name glCreateQueries - create query objects
* @usage
* @code void glCreateQueries(GLenum target, GLsizei n, GLuint *ids); @endcode
* @param target Specifies the target of each created query object.
* @param n Number of query objects to create.
* @param ids Specifies an array in which names of the new query objects are stored.
* @description
* 	glCreateQueries returns n previously unused query object names in ids, each representing a new query object with the specified
* target.<br>
* 	target may be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_TIME_ELAPSED, GL_TIMESTAMP,
* GL_PRIMITIVES_GENERATED or GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not an accepted value.
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateQueries glad_glCreateQueries
GLAD_API_CALL PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;
/**
* @name glCreateRenderbuffers - create renderbuffer objects
* @usage
* @code void glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers); @endcode
* @param n Number of renderbuffer objects to create.
* @param renderbuffers Specifies an array in which names of the new renderbuffer objects are stored.
* @description
* 	glCreateRenderbuffers returns n previously unused renderbuffer object names in renderbuffers, each representing a new renderbuffer
* object initialized to the default state.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateRenderbuffers glad_glCreateRenderbuffers
GLAD_API_CALL PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;
/**
* @name glCreateSamplers - create sampler objects
* @usage
* @code void glCreateSamplers(GLsizei n, GLuint *samplers); @endcode
* @param n Number of sampler objects to create.
* @param samplers Specifies an array in which names of the new sampler objects are stored.
* @description
* 	glCreateSamplers returns n previously unused sampler names in samplers, each representing a new sampler object initialized
* to the default state.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateSamplers glad_glCreateSamplers
GLAD_API_CALL PFNGLCREATESHADERPROC glad_glCreateShader;
/**
* @name glCreateShader - Creates a shader object
* @usage
* @code GLuint glCreateShader(GLenum shaderType); @endcode
* @param shaderType Specifies the type of shader to be created. Must be one of <b>GL_COMPUTE_SHADER</b>, <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>,
*                   <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>, or <b>GL_FRAGMENT_SHADER</b>.
* @description
* 	glCreateShader creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object
* is used to maintain the source code strings that define a shader. shaderType indicates the type of shader to be created.
* Five types of shader are supported. A shader of type GL_COMPUTE_SHADER is a shader that is intended to run on the programmable
* compute processor. A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable
* vertex processor. A shader of type GL_TESS_CONTROL_SHADER is a shader that is intended to run on the programmable tessellation
* processor in the control stage. A shader of type GL_TESS_EVALUATION_SHADER is a shader that is intended to run on
* the programmable tessellation processor in the evaluation stage. A shader of type GL_GEOMETRY_SHADER is a shader that is
* intended to run on the programmable geometry processor. A shader of type GL_FRAGMENT_SHADER is a shader that is intended
* to run on the programmable fragment processor.<br>
* 	When created, a shader object's GL_SHADER_TYPE parameter is set to either GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,
* GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER, depending on the value of shaderType.<br>
*
* @note Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the
*       server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects
*       and the data associated with those attached objects are shared as well.
* @note Applications are responsible for providing the synchronization across API calls when objects are accessed from different
*       execution threads.
* @note GL_COMPUTE_SHADER is available only if the GL version is 4.3 or higher.
*
* @errors This function returns 0 if an error occurs creating the shader object.
* @errors GL_INVALID_ENUM is generated if shaderType is not an accepted value.
*
*/
#define glCreateShader glad_glCreateShader
GLAD_API_CALL PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;
// Unable to find the docs for this function!
#define glCreateShaderProgramv glad_glCreateShaderProgramv
GLAD_API_CALL PFNGLCREATETEXTURESPROC glad_glCreateTextures;
/**
* @name glCreateTextures - create texture objects
* @usage
* @code void glCreateTextures(GLenum target, GLsizei n, GLuint *textures); @endcode
* @param target Specifies the effective texture target of each created texture.
* @param n Number of texture objects to create.
* @param textures Specifies an array in which names of the new texture objects are stored.
* @description
* 	glCreateTextures returns n previously unused texture names in textures, each representing a new texture object of the dimensionality
* and type specified by target and initialized to the default values for that texture type.<br>
* 	target must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
* GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.<br>
*
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateTextures glad_glCreateTextures
GLAD_API_CALL PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;
/**
* @name glCreateTransformFeedbacks - create transform feedback objects
* @usage
* @code void glCreateTransformFeedbacks(GLsizei n, GLuint *ids); @endcode
* @param n Number of transform feedback objects to create.
* @param ids Specifies an array in which names of the new transform feedback objects are stored.
* @description
* 	glCreateTransformFeedbacks returns n previously unused transform feedback object names in ids, each representing a new
* transform feedback object initialized to the default state.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateTransformFeedbacks glad_glCreateTransformFeedbacks
GLAD_API_CALL PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;
/**
* @name glCreateVertexArrays - create vertex array objects
* @usage
* @code void glCreateVertexArrays(GLsizei n, GLuint *arrays); @endcode
* @param n Number of vertex array objects to create.
* @param arrays Specifies an array in which names of the new vertex array objects are stored.
* @description
* 	glCreateVertexArrays returns n previously unused vertex array object names in arrays, each representing a new vertex array
* object initialized to the default state.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateVertexArrays glad_glCreateVertexArrays
GLAD_API_CALL PFNGLCULLFACEPROC glad_glCullFace;
/**
* @name glCullFace - specify whether front- or back-facing facets can be culled
* @usage
* @code void glCullFace(GLenum mode); @endcode
* @param mode Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants <b>GL_FRONT</b>, <b>GL_BACK</b>,
*             and <b>GL_FRONT_AND_BACK</b> are accepted. The initial value is <b>GL_BACK</b>.
* @description
* 	glCullFace specifies whether front- or back-facing facets are culled (as specified by mode) when facet culling is enabled.
* Facet culling is initially disabled. To enable and disable facet culling, call the glEnable and  glDisable commands
* with the argument GL_CULL_FACE. Facets include triangles, quadrilaterals, polygons, and rectangles.<br>
* 	glFrontFace specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See glFrontFace.<br>
*
* @note If mode is GL_FRONT_AND_BACK, no facets are drawn, but other primitives such as points and lines are drawn.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
*
*/
#define glCullFace glad_glCullFace
GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;
/**
* @name glDebugMessageCallback - specify a callback to receive debugging messages from the GL
* @usage
* @code void glDebugMessageCallback(DEBUGPROC callback, const void * userParam); @endcode
* @param callback The address of a callback function that will be called when a debug message is generated.
* @param userParam A user supplied pointer that will be passed on each invocation of <em class="parameter"><b>callback</b></em>.
* @description
* 	glDebugMessageCallback sets the current debug output callback function to the function whose address is given in callback.
* The callback function should have the following prototype (in C), or be otherwise compatible with such a prototype:<br>
* 	This function is defined to have the same calling convention as the GL API functions. In most cases this is defined as
* APIENTRY, although it will vary depending on platform, language and compiler.<br>
* 	Each time a debug message is generated the debug callback function will be invoked with source, type, id, and severity
* associated with the message, and length set to the length of debug message whose character string is in the array pointed
* to by message. userParam will be set to the value passed in the userParam parameter to the most recent call to glDebugMessageCallback.<br>
*
* @note When the GL is in use remotely, the server may not be able to call functions in the client's address space. In such cases,
*       the callback function may not be invoked and the user should retrieve debug messages from the context's debug message
*       log by calling glGetDebugMessageLog.
*
*
*/
#define glDebugMessageCallback glad_glDebugMessageCallback
GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;
/**
* @name glDebugMessageControl - control the reporting of debug messages in a debug context
* @usage
* @code void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled); @endcode
* @param source The source of debug messages to enable or disable.
* @param type The type of debug messages to enable or disable.
* @param severity The severity of debug messages to enable or disable.
* @param count The length of the array <em class="parameter"><b>ids</b></em>.
* @param ids The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
* @param enabled A Boolean flag determining whether the selected messages should be enabled or disabled.
* @description
* 	glDebugMessageControl controls the reporting of debug messages generated by a debug context. The parameters source, type
* and severity form a filter to select messages from the pool of potential messages generated by the GL.<br>
* 	source may be GL_DEBUG_SOURCE_API, GL_DEBUG_SOURCE_WINDOW_SYSTEM_, GL_DEBUG_SOURCE_SHADER_COMPILER, GL_DEBUG_SOURCE_THIRD_PARTY,
* GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_SOURCE_OTHER to select messages generated by usage of the GL API, the window
* system, the shader compiler, third party tools or libraries, explicitly by the application or by some other source,
* respectively. It may also take the value GL_DONT_CARE. If source is not GL_DONT_CARE then only messages whose source matches
* source will be referenced.<br>
* 	type may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR, GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,
* GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, or
* GL_DEBUG_TYPE_OTHER to indicate the type of messages describing GL errors, attempted use of deprecated features, triggering
* of undefined behavior, portability issues, performance notifications, markers, group push and pop events, and other
* types of messages, respectively. It may also take the value GL_DONT_CARE. If type is not GL_DONT_CARE then only messages
* whose type matches type will be referenced.<br>
* 	severity may be one of GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM, or GL_DEBUG_SEVERITY_HIGH to select messages of
* low, medium or high severity messages or to GL_DEBUG_SEVERITY_NOTIFICATION for notifications. It may also take the value
* GL_DONT_CARE. If severity is not GL_DONT_CARE then only messages whose severity matches severity will be referenced.<br>
* 	ids contains a list of count message identifiers to select specific messages from the pool of available messages. If count
* is zero then the value of ids is ignored. Otherwise, only messages appearing in this list are selected. In this case,
* source and type may not be GL_DONT_CARE and severity must be GL_DONT_CARE.<br>
* 	If enabled is GL_TRUE then messages that match the filter formed by source, type, severity and ids are enabled. Otherwise,
* those messages are disabled.<br>
*
* @note Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially
*       inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug
*       context may produce no messages at all.
* @note GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, and GL_DEBUG_SEVERITY_NOTIFICATION are available
*       only if the GL version is 4.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types.
* @errors GL_INVALID_OPERATION is generated if count is non-zero and either source or type is GL_DONT_CARE or if severity is not GL_DONT_CARE.
*
*/
#define glDebugMessageControl glad_glDebugMessageControl
GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;
/**
* @name glDebugMessageInsert - inject an application-supplied message into the debug message queue
* @usage
* @code void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message); @endcode
* @param source The source of the debug message to insert.
* @param type The type of the debug message insert.
* @param id The user-supplied identifier of the message to insert.
* @param severity The severity of the debug messages to insert.
* @param length The length string contained in the character array whose address is given by <em class="parameter"><b>message</b></em>.
* @param message The address of a character array containing the message to insert.
* @description
* 	glDebugMessageInsert inserts a user-supplied message into the debug output queue. source specifies the source that will
* be used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION or GL_DEBUG_SOURCE_THIRD_PARTY. All other sources
* are reserved for use by the GL implementation. type indicates the type of the message to be inserted and may be one of
* GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR, GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY, GL_DEBUG_TYPE_PERFORMANCE,
* GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER.
* severity indicates the severity of the message and may be GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH
* or GL_DEBUG_SEVERITY_NOTIFICATION. id is available for application defined use and may be any value. This value
* will be recorded and used to identify the message.<br>
* 	length contains a count of the characters in the character array whose address is given in message. If length is negative
* then message is treated as a null-terminated string. The length of the message, whether specified explicitly or implicitly,
* must be less than or equal to the implementation defined constant GL_MAX_DEBUG_MESSAGE_LENGTH.<br>
*
* @note GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, and GL_DEBUG_SEVERITY_NOTIFICATION are available
*       only if the GL version is 4.3 or higher.
*
* @errors GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types.
* @errors GL_INVALID_VALUE is generated if the length of the message is greater than the value of GL_MAX_DEBUG_MESSAGE_LENGTH.
*
*/
#define glDebugMessageInsert glad_glDebugMessageInsert
GLAD_API_CALL PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
/**
* @name glDeleteBuffers - delete named buffer objects
* @usage
* @code void glDeleteBuffers(GLsizei n, const GLuint * buffers); @endcode
* @param n Specifies the number of buffer objects to be deleted.
* @param buffers Specifies an array of buffer objects to be deleted.
* @description
* 	glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer object is deleted,
* it has no contents, and its name is free for reuse (for example by glGenBuffers). If a buffer object that is currently bound
* is deleted, the binding reverts to 0 (the absence of any buffer object).<br>
* 	glDeleteBuffers silently ignores 0's and names that do not correspond to existing buffer objects.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteBuffers glad_glDeleteBuffers
GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
/**
* @name glDeleteFramebuffers - delete framebuffer objects
* @usage
* @code void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers); @endcode
* @param n Specifies the number of framebuffer objects to be deleted.
* @param framebuffers A pointer to an array containing <em class="parameter"><b>n</b></em> framebuffer objects to be deleted.
* @description
* 	glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in the array addressed by framebuffers. The
* name zero is reserved by the GL and is silently ignored, should it occur in framebuffers, as are other unused names.
* Once a framebuffer object is deleted, its name is again unused and it has no attachments. If a framebuffer that is currently
* bound to one or more of the targets GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer
* had been executed with the corresponding target and framebuffer zero.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteFramebuffers glad_glDeleteFramebuffers
GLAD_API_CALL PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
/**
* @name glDeleteProgram - Deletes a program object
* @usage
* @code void glDeleteProgram(GLuint program); @endcode
* @param program Specifies the program object to be deleted.
* @description
* 	glDeleteProgram frees the memory and invalidates the name associated with the program object specified by program. This
* command effectively undoes the effects of a call to glCreateProgram.<br>
* 	If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted
* until it is no longer part of current state for any rendering context. If a program object to be deleted has shader
* objects attached to it, those shader objects will be automatically detached but not deleted unless they have already
* been flagged for deletion by a previous call to glDeleteShader. A value of 0 for program will be silently ignored.<br>
* 	To determine whether a program object has been flagged for deletion, call glGetProgram with arguments program and GL_DELETE_STATUS.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
*
*/
#define glDeleteProgram glad_glDeleteProgram
GLAD_API_CALL PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;
/**
* @name glDeleteProgramPipelines - delete program pipeline objects
* @usage
* @code void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines); @endcode
* @param n Specifies the number of program pipeline objects to delete.
* @param pipelines Specifies an array of names of program pipeline objects to delete.
* @description
* 	glDeleteProgramPipelines deletes the n program pipeline objects whose names are stored in the array pipelines. Unused names
* in pipelines are ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused
* and it has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts
* to zero and no program pipeline object becomes current.<br>
*
*
*
*/
#define glDeleteProgramPipelines glad_glDeleteProgramPipelines
GLAD_API_CALL PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
/**
* @name glDeleteQueries - delete named query objects
* @usage
* @code void glDeleteQueries(GLsizei n, const GLuint * ids); @endcode
* @param n Specifies the number of query objects to be deleted.
* @param ids Specifies an array of query objects to be deleted.
* @description
* 	glDeleteQueries deletes n query objects named by the elements of the array ids. After a query object is deleted, it has
* no contents, and its name is free for reuse (for example by glGenQueries).<br>
* 	glDeleteQueries silently ignores 0's and names that do not correspond to existing query objects.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteQueries glad_glDeleteQueries
GLAD_API_CALL PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
/**
* @name glDeleteRenderbuffers - delete renderbuffer objects
* @usage
* @code void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers); @endcode
* @param n Specifies the number of renderbuffer objects to be deleted.
* @param renderbuffers A pointer to an array containing <em class="parameter"><b>n</b></em> renderbuffer objects to be deleted.
* @description
* 	glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array addressed by renderbuffers.
* The name zero is reserved by the GL and is silently ignored, should it occur in renderbuffers, as are other unused names.
* Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently
* bound to the target GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer had been executed with a target
* of GL_RENDERBUFFER and a name of zero.<br>
* 	If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if
* glFramebufferRenderbuffer had been called, with a renderbuffer of zero for each attachment point to which this image was
* attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment
* ponits in the currently bound framebuffer. Note that the renderbuffer image is specifically not detached from any
* non-bound framebuffers.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteRenderbuffers glad_glDeleteRenderbuffers
GLAD_API_CALL PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
/**
* @name glDeleteSamplers - delete named sampler objects
* @usage
* @code void glDeleteSamplers(GLsizei n, const GLuint * samplers); @endcode
* @param n Specifies the number of sampler objects to be deleted.
* @param samplers Specifies an array of sampler objects to be deleted.
* @description
* 	glDeleteSamplers deletes n sampler objects named by the elements of the array samplers. After a sampler object is deleted,
* its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as though
* glBindSampler is called with unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are
* silently ignored, as is the reserved name zero.<br>
*
* @note glDeleteSamplers is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteSamplers glad_glDeleteSamplers
GLAD_API_CALL PFNGLDELETESHADERPROC glad_glDeleteShader;
/**
* @name glDeleteShader - Deletes a shader object
* @usage
* @code void glDeleteShader(GLuint shader); @endcode
* @param shader Specifies the shader object to be deleted.
* @description
* 	glDeleteShader frees the memory and invalidates the name associated with the shader object specified by shader. This command
* effectively undoes the effects of a call to glCreateShader.<br>
* 	If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted
* until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever
* it was attached before it will be deleted). A value of 0 for shader will be silently ignored.<br>
* 	To determine whether an object has been flagged for deletion, call glGetShader with arguments shader and GL_DELETE_STATUS.<br>
*
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
*
*/
#define glDeleteShader glad_glDeleteShader
GLAD_API_CALL PFNGLDELETESYNCPROC glad_glDeleteSync;
/**
* @name glDeleteSync - delete a sync object
* @usage
* @code void glDeleteSync(GLsync sync); @endcode
* @param sync The sync object to be deleted.
* @description
* 	glDeleteSync deletes the sync object specified by sync. If the fence command corresponding to the specified sync object
* has completed, or if no glWaitSync or glClientWaitSync commands are blocking on sync, the object is deleted immediately.
* Otherwise, sync is flagged for deletion and will be deleted when it is no longer associated with any fence command and
* is no longer blocking any glWaitSync or glClientWaitSync command. In either case, after glDeleteSync returns, the name
* sync is invalid and can no longer be used to refer to the sync object.<br>
* 	glDeleteSync will silently ignore a sync value of zero.<br>
*
* @note glSync is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is supported.
*
* @errors GL_INVALID_VALUE is generated if sync is neither zero or the name of a sync object.
*
*/
#define glDeleteSync glad_glDeleteSync
GLAD_API_CALL PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
/**
* @name glDeleteTextures - delete named textures
* @usage
* @code void glDeleteTextures(GLsizei n, const GLuint * textures); @endcode
* @param n Specifies the number of textures to be deleted.
* @param textures Specifies an array of textures to be deleted.
* @description
* 	glDeleteTextures deletes n textures named by the elements of the array textures. After a texture is deleted, it has no
* contents or dimensionality, and its name is free for reuse (for example by glGenTextures). If a texture that is currently
* bound is deleted, the binding reverts to 0 (the default texture).<br>
* 	glDeleteTextures silently ignores 0's and names that do not correspond to existing textures.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteTextures glad_glDeleteTextures
GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;
/**
* @name glDeleteTransformFeedbacks - delete transform feedback objects
* @usage
* @code void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids); @endcode
* @param n Specifies the number of transform feedback objects to delete.
* @param ids Specifies an array of names of transform feedback objects to delete.
* @description
* 	glDeleteTransformFeedbacks deletes the n transform feedback objects whose names are stored in the array ids. Unused names
* in ids are ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it
* has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but the underlying
* object is not deleted until it is no longer active.<br>
*
*
*
*/
#define glDeleteTransformFeedbacks glad_glDeleteTransformFeedbacks
GLAD_API_CALL PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
/**
* @name glDeleteVertexArrays - delete vertex array objects
* @usage
* @code void glDeleteVertexArrays(GLsizei n, const GLuint *arrays); @endcode
* @param n Specifies the number of vertex array objects to be deleted.
* @param arrays Specifies the address of an array containing the <em class="parameter"><b>n</b></em> names of the objects to be deleted.
* @description
* 	glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by arrays. Once a vertex
* array object is deleted it has no contents and its name is again unused. If a vertex array object that is currently
* bound is deleted, the binding for that object reverts to zero and the default vertex array becomes current. Unused names
* in arrays are silently ignored, as is the value zero.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteVertexArrays glad_glDeleteVertexArrays
GLAD_API_CALL PFNGLDEPTHFUNCPROC glad_glDepthFunc;
/**
* @name glDepthFunc - specify the value used for depth buffer comparisons
* @usage
* @code void glDepthFunc(GLenum func); @endcode
* @param func Specifies the depth comparison function. Symbolic constants <b>GL_NEVER</b>, <b>GL_LESS</b>, <b>GL_EQUAL</b>, <b>GL_LEQUAL</b>,
*             <b>GL_GREATER</b>, <b>GL_NOTEQUAL</b>, <b>GL_GEQUAL</b>, and <b>GL_ALWAYS</b> are accepted. The initial value is
*             <b>GL_LESS</b>.
* @description
* 	glDepthFunc specifies the function used to compare each incoming pixel depth value with the depth value present in the
* depth buffer. The comparison is performed only if depth testing is enabled. (See glEnable and  glDisable of GL_DEPTH_TEST.)<br>
* 	func specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:<br>
* 	Never passes.<br>
* 	Passes if the incoming depth value is less than the stored depth value.<br>
* 	Passes if the incoming depth value is equal to the stored depth value.<br>
* 	Passes if the incoming depth value is less than or equal to the stored depth value.<br>
* 	Passes if the incoming depth value is greater than the stored depth value.<br>
* 	Passes if the incoming depth value is not equal to the stored depth value.<br>
* 	Passes if the incoming depth value is greater than or equal to the stored depth value.<br>
* 	Always passes.<br>
* 	The initial value of func is GL_LESS. Initially, depth testing is disabled.  If depth testing is disabled or if no depth
* buffer exists, it is as if the depth test always passes.<br>
*
* @note Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled.
*       In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS.
*
* @errors GL_INVALID_ENUM is generated if func is not an accepted value.
*
*/
#define glDepthFunc glad_glDepthFunc
GLAD_API_CALL PFNGLDEPTHMASKPROC glad_glDepthMask;
/**
* @name glDepthMask - enable or disable writing into the depth buffer
* @usage
* @code void glDepthMask(GLboolean flag); @endcode
* @param flag Specifies whether the depth buffer is enabled for writing. If <em class="parameter"><b>flag</b></em> is <b>GL_FALSE</b>,
*             depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
* @description
* 	glDepthMask specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled.
* Otherwise, it is enabled. Initially, depth buffer writing is enabled.<br>
*
* @note Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled.
*       In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS (see
*       glDepthFunc).
*
*
*/
#define glDepthMask glad_glDepthMask
GLAD_API_CALL PFNGLDEPTHRANGEPROC glad_glDepthRange;
/**
* @name glDepthRange - specify mapping of depth values from normalized device coordinates to window coordinates
* @usage
* @code void glDepthRange(GLdouble nearVal, GLdouble farVal); @endcode
* @code void glDepthRangef(GLfloat nearVal, GLfloat farVal); @endcode
* @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
* @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
* @description
* 	After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes.
* glDepthRange specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates.
* Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range
* from 0 through 1 (like color components). Thus, the values accepted by glDepthRange are both clamped to this range before
* they are accepted.<br>
* 	The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully
* utilized.<br>
*
* @note It is not necessary that nearVal be less than farVal. Reverse mappings such as nearVal=1 , and farVal=0 are acceptable.
* @note The type of the nearVal and farVal parameters was changed from GLclampf to GLfloat for glDepthRangef and from GLclampd to
*       GLdouble for glDepthRange. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glDepthRange glad_glDepthRange
GLAD_API_CALL PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;
// Unable to find the docs for this function!
#define glDepthRangeArrayv glad_glDepthRangeArrayv
GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;
/**
* @name glDepthRangeIndexed - specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
* @usage
* @code void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal); @endcode
* @param index Specifies the index of the viewport whose depth range to update.
* @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
* @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
* @description
* 	After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes.
* Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this
* range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values
* are treated as though they range from 0 through 1 (like color components). glDepthRangeIndexed specifies a linear mapping
* of the normalized depth coordinates in this range to window depth coordinates for a specified viewport. Thus, the values
* accepted by glDepthRangeIndexed are both clamped to this range before they are accepted.<br>
* 	The index parameter specifies the index of first viewport whose depth range to modify and must be less than the value of
* GL_MAX_VIEWPORTS. nearVal and farVal specify near and far values of the depth range for the specified viewport, respectively.<br>
* 	The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully
* utilized.<br>
*
* @note It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as nearVal=1
*       , and farVal=0 are acceptable.
* @note The type of the nearVal and farVal parameters was changed from GLclampd to GLdouble. This change is transparent to user
*       code and is described in detail on the removedTypes page.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS.
*
*/
#define glDepthRangeIndexed glad_glDepthRangeIndexed
GLAD_API_CALL PFNGLDEPTHRANGEFPROC glad_glDepthRangef;
/**
* @name glDepthRange - specify mapping of depth values from normalized device coordinates to window coordinates
* @usage
* @code void glDepthRange(GLdouble nearVal, GLdouble farVal); @endcode
* @code void glDepthRangef(GLfloat nearVal, GLfloat farVal); @endcode
* @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
* @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
* @description
* 	After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes.
* glDepthRange specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates.
* Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range
* from 0 through 1 (like color components). Thus, the values accepted by glDepthRange are both clamped to this range before
* they are accepted.<br>
* 	The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully
* utilized.<br>
*
* @note It is not necessary that nearVal be less than farVal. Reverse mappings such as nearVal=1 , and farVal=0 are acceptable.
* @note The type of the nearVal and farVal parameters was changed from GLclampf to GLfloat for glDepthRangef and from GLclampd to
*       GLdouble for glDepthRange. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glDepthRangef glad_glDepthRangef
GLAD_API_CALL PFNGLDETACHSHADERPROC glad_glDetachShader;
/**
* @name glDetachShader - Detaches a shader object from a program object to which it is attached
* @usage
* @code void glDetachShader(GLuint program, GLuint shader); @endcode
* @param program Specifies the program object from which to detach the shader object.
* @param shader Specifies the shader object to be detached.
* @description
* 	glDetachShader detaches the shader object specified by shader from the program object specified by program. This command
* can be used to undo the effect of the command glAttachShader.<br>
* 	If shader has already been flagged for deletion by a call to glDeleteShader and it is not attached to any other program
* object, it will be deleted after it has been detached.<br>
*
*
* @errors GL_INVALID_VALUE is generated if either program or shader is a value that was not generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_OPERATION is generated if shader is not attached to program.
*
glAttachShader
*/
#define glDetachShader glad_glDetachShader
GLAD_API_CALL PFNGLDISABLEPROC glad_glDisable;
// Unable to find the docs for this function!
#define glDisable glad_glDisable
GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
* @description
* 	glEnableVertexAttribArray and glEnableVertexArrayAttrib enable the generic vertex attribute array specified by index. glEnableVertexAttribArray
* uses currently bound vertex array object for the operation, whereas glEnableVertexArrayAttrib updates
* state of the vertex array object with ID vaobj.<br>
* 	glDisableVertexAttribArray and glDisableVertexArrayAttrib disable the generic vertex attribute array specified by index.
* glDisableVertexAttribArray uses currently bound vertex array object for the operation, whereas glDisableVertexArrayAttrib
* updates state of the vertex array object with ID vaobj.<br>
* 	By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values
* in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array
* commands such as glDrawArrays, glDrawElements, glDrawRangeElements, glMultiDrawElements, or glMultiDrawArrays.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glDisableVertexArrayAttrib glad_glDisableVertexArrayAttrib
GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
* @description
* 	glEnableVertexAttribArray and glEnableVertexArrayAttrib enable the generic vertex attribute array specified by index. glEnableVertexAttribArray
* uses currently bound vertex array object for the operation, whereas glEnableVertexArrayAttrib updates
* state of the vertex array object with ID vaobj.<br>
* 	glDisableVertexAttribArray and glDisableVertexArrayAttrib disable the generic vertex attribute array specified by index.
* glDisableVertexAttribArray uses currently bound vertex array object for the operation, whereas glDisableVertexArrayAttrib
* updates state of the vertex array object with ID vaobj.<br>
* 	By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values
* in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array
* commands such as glDrawArrays, glDrawElements, glDrawRangeElements, glMultiDrawElements, or glMultiDrawArrays.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glDisableVertexAttribArray glad_glDisableVertexAttribArray
GLAD_API_CALL PFNGLDISABLEIPROC glad_glDisablei;
// Unable to find the docs for this function!
#define glDisablei glad_glDisablei
GLAD_API_CALL PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;
/**
* @name glDispatchCompute - launch one or more compute work groups
* @usage
* @code void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z); @endcode
* @param num_groups_x The number of work groups to be launched in the X dimension.
* @param num_groups_y The number of work groups to be launched in the Y dimension.
* @param num_groups_z The number of work groups to be launched in the Z dimension.
* @description
* 	glDispatchCompute launches one or more compute work groups. Each work group is processed by the active program object for
* the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups
* are executed completely independently and in unspecified order. num_groups_x, num_groups_y and num_groups_z specify
* the number of local work groups that will be dispatched in the X, Y and Z dimensions, respectively.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage.
* @errors GL_INVALID_VALUE is generated if any of num_groups_x, num_groups_y, or num_groups_z is greater than or equal to the maximum
*         work-group count for the corresponding dimension.
*
*/
#define glDispatchCompute glad_glDispatchCompute
GLAD_API_CALL PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;
/**
* @name glDispatchComputeIndirect - launch one or more compute work groups using parameters stored in a buffer
* @usage
* @code void glDispatchComputeIndirect(GLintptr indirect); @endcode
* @param indirect The offset into the buffer object currently bound to the <b>GL_DISPATCH_INDIRECT_BUFFER</b> buffer target at which the dispatch
*                 parameters are stored.
* @description
* 	glDispatchComputeIndirect launches one or more compute work groups using parameters stored in the buffer object currently
* bound to the GL_DISPATCH_INDIRECT_BUFFER target. Each work group is processed by the active program object for the compute
* shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are
* executed completely independently and in unspecified order. indirect contains the offset into the data store of the buffer
* object bound to the GL_DISPATCH_INDIRECT_BUFFER target at which the parameters are stored.<br>
* 	The parameters addressed by indirect are packed a structure, which takes the form (in C):<br>
* 	A call to glDispatchComputeIndirect is equivalent, assuming no errors are generated, to:<br>
* 	Unlike glDispatchCompute, no error is generated if any of the num_groups_x, num_groups_y or num_groups_z members of the
* DispatchIndirectCommand is larger than the value of GL_MAX_COMPUTE_WORK_GROUP_COUNT for the corresponding dimension. In
* such circumstances, behavior is undefined and may lead to application termination.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage.
* @errors GL_INVALID_VALUE is generated if indirect is less than zero or not a multiple of four.
* @errors GL_INVALID_OPERATION is generated if no buffer is bound to the GL_DISPATCH_INDIRECT_BUFFER target or if the command would
*         source data beyond the end of the buffer object's data store.
*
*/
#define glDispatchComputeIndirect glad_glDispatchComputeIndirect
GLAD_API_CALL PFNGLDRAWARRAYSPROC glad_glDrawArrays;
/**
* @name glDrawArrays - render primitives from array data
* @usage
* @code void glDrawArrays(GLenum mode, GLint first, GLsizei count); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param first Specifies the starting index in the enabled arrays.
* @param count Specifies the number of indices to be rendered.
* @description
* 	glDrawArrays specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure
* to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices,
* normals, and colors and use them to construct a sequence of primitives with a single call to glDrawArrays.<br>
* 	When glDrawArrays is called, it uses count sequential elements from each enabled array to construct a sequence of geometric
* primitives, beginning with element first. mode specifies what kind of primitives are constructed and how the array
* elements construct those primitives.<br>
* 	Vertex attributes that are modified by glDrawArrays have an unspecified value after glDrawArrays returns. Attributes that
* aren't modified remain well defined.<br>
*
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
*
*/
#define glDrawArrays glad_glDrawArrays
GLAD_API_CALL PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;
/**
* @name glDrawArraysIndirect - render primitives from array data, taking parameters from memory
* @usage
* @code void glDrawArraysIndirect(GLenum mode, const void *indirect); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param indirect Specifies the address of a structure containing the draw parameters.
* @description
* 	glDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls. glDrawArraysIndirect behaves
* similarly to glDrawArraysInstancedBaseInstance, execept that the parameters to glDrawArraysInstancedBaseInstance are
* stored in memory at the address given by indirect.<br>
* 	The parameters addressed by indirect are packed into a structure that takes the form (in C):<br>
* 	If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time of a call to glDrawArraysIndirect, indirect is
* interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather
* than from client memory.<br>
* 	In contrast to glDrawArraysInstancedBaseInstance, the first member of the parameter structure is unsigned, and out-of-range
* indices do not generate an error.<br>
* 	Vertex attributes that are modified by glDrawArraysIndirect have an unspecified value after glDrawArraysIndirect returns.
* Attributes that aren't modified remain well defined.<br>
*
* @note The baseInstance member of the DrawArraysIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions
*       of the GL, behavior is undefined if it is non-zero.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glDrawArraysIndirect glad_glDrawArraysIndirect
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
/**
* @name glDrawArraysInstanced - draw multiple instances of a range of elements
* @usage
* @code void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>
<b>GL_LINES_ADJACENCY</b>, <b>GL_LINE_STRIP_ADJACENCY</b>,
*             <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b> are
*             accepted.
* @param first Specifies the starting index in the enabled arrays.
* @param count Specifies the number of indices to be rendered.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @description
* 	glDrawArraysInstanced behaves identically to glDrawArrays except that instancecount instances of the range of elements
* are executed and the value of the internal counter instanceID advances for each iteration. instanceID is an internal 32-bit
* integer counter that may be read by a vertex shader as gl_InstanceID.<br>
* 	glDrawArraysInstanced has the same effect as:<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the accepted values.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawArraysInstanced glad_glDrawArraysInstanced
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;
/**
* @name glDrawArraysInstancedBaseInstance - draw multiple instances of a range of elements with offset applied to instanced attributes
* @usage
* @code void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>
<b>GL_LINES_ADJACENCY</b>, <b>GL_LINE_STRIP_ADJACENCY</b>,
*             <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b> are
*             accepted.
* @param first Specifies the starting index in the enabled arrays.
* @param count Specifies the number of indices to be rendered.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.
* @description
* 	glDrawArraysInstancedBaseInstance behaves identically to glDrawArrays except that instancecount instances of the range
* of elements are executed and the value of the internal counter instanceID advances for each iteration. instanceID is an
* internal 32-bit integer counter that may be read by a vertex shader as gl_InstanceID.<br>
* 	glDrawArraysInstancedBaseInstance has the same effect as:<br>
* 	Specific vertex attributes may be classified as instanced through the use of glVertexAttribDivisor. Instanced vertex attributes
* supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced
* vertex attribute arrays is calculated as: gl_InstanceID divisor +baseInstance . Note that baseinstance does not affect
* the shader-visible value of gl_InstanceID.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the accepted values.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawArraysInstancedBaseInstance glad_glDrawArraysInstancedBaseInstance
GLAD_API_CALL PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
/**
* @name glDrawBuffer, glNamedFramebufferDrawBuffer - specify which color buffers are to be drawn into
* @usage
* @code void glDrawBuffer(GLenum buf); @endcode
* @code void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffer</b> function. Must be zero or the name
*                    of a framebuffer object.
* @param buf For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants <b>GL_NONE</b>,
*            <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>, <b>GL_FRONT</b>, <b>GL_BACK</b>,
*            <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and <b>GL_FRONT_AND_BACK</b> are accepted. The initial value is <b>GL_FRONT</b>
*            for single-buffered contexts, and <b>GL_BACK</b> for double-buffered contexts. For framebuffer objects, <b>GL_COLOR_ATTACHMENT$m$</b>
*            and <b>GL_NONE</b> enums are accepted, where <b>$m$</b> is a value between 0 and <b>GL_MAX_COLOR_ATTACHMENTS</b>.
* @description
* 	When colors are written to the frame buffer, they are written into the color buffers specified by glDrawBuffer. One of
* the following values can be used for default framebuffer:<br>
* 	No color buffers are written.<br>
* 	Only the front left color buffer is written.<br>
* 	Only the front right color buffer is written.<br>
* 	Only the back left color buffer is written.<br>
* 	Only the back right color buffer is written.<br>
* 	Only the front left and front right color buffers are written. If there is no front right color buffer, only the front
* left color buffer is written.<br>
* 	Only the back left and back right color buffers are written. If there is no back right color buffer, only the back left
* color buffer is written.<br>
* 	Only the front left and back left color buffers are written. If there is no back left color buffer, only the front left
* color buffer is written.<br>
* 	Only the front right and back right color buffers are written. If there is no back right color buffer, only the front right
* color buffer is written.<br>
* 	All the front and back color buffers (front left, front right, back left, back right) are written. If there are no back
* color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only
* the front left and back left color buffers are written. If there are no right or back color buffers, only the front left
* color buffer is written.<br>
* 	If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently
* for each color buffer and can produce different results in each buffer.<br>
* 	Monoscopic contexts include only left buffers, and stereoscopic contexts include both left and right buffers. Likewise,
* single-buffered contexts include only front buffers, and double-buffered contexts include both front and back buffers.
* The context is selected at GL initialization.<br>
* 	For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
* glDrawBuffer will set the draw buffer for fragment colors other than zero to GL_NONE.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if buf is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if the default framebuffer is affected and none of the buffers indicated by buf exists.
* @errors GL_INVALID_OPERATION is generated if a framebuffer object is affected and buf is not equal to GL_NONE or GL_COLOR_ATTACHMENT$m$,
*         where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glDrawBuffer glad_glDrawBuffer
GLAD_API_CALL PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
/**
* @name glDrawBuffers, glNamedFramebufferDrawBuffers - Specifies a list of color buffers to be drawn
into
* @usage
* @code void glDrawBuffers(GLsizei n, const GLenum *bufs); @endcode
* @code void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffers</b>.
* @param n Specifies the number of buffers in <em class="parameter"><b>bufs</b></em>.
* @param bufs Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
* @description
* 	glDrawBuffers and glNamedFramebufferDrawBuffers define an array of buffers into which outputs from the fragment shader
* data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of
* each variable will be written into the buffer specified at a location within bufs corresponding to the location assigned
* to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal
* to n is implicitly set to GL_NONE and any data written to such an output is discarded.<br>
* 	For glDrawBuffers, the framebuffer object that is bound to the GL_DRAW_FRAMEBUFFER binding will be used. For glNamedFramebufferDrawBuffers,
* framebuffer is the name of the framebuffer object. If framebuffer is zero, then the default framebuffer
* is affected.<br>
* 	The symbolic constants contained in bufs may be any of the following:<br>
* 	The fragment shader output value is not written into any color buffer.<br>
* 	The fragment shader output value is written into the front left color buffer.<br>
* 	The fragment shader output value is written into the front right color buffer.<br>
* 	The fragment shader output value is written into the back left color buffer.<br>
* 	The fragment shader output value is written into the back right color buffer.<br>
* 	The fragment shader output value is written into the nth color attachment of the current framebuffer. n may range from
* zero to the value of GL_MAX_COLOR_ATTACHMENTS.<br>
* 	Except for GL_NONE, the preceding symbolic constants may not appear more than once in bufs. The maximum number of draw
* buffers supported is implementation dependent and can be queried by calling glGet with the argument GL_MAX_DRAW_BUFFERS.<br>
*
* @note The symbolic constants GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are not allowed in the bufs array since
*       they may refer to multiple buffers.
* @note If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader
*       execution are undefined. For each fragment generated in this situation, a different value may be written into each of
*       the buffers specified by bufs.
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffers if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if one of the values in bufs is not an accepted value.
* @errors GL_INVALID_ENUM is generated if the API call refers to the default framebuffer and one or more of the values in bufs is
*         one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if the API call refers to a framebuffer object and one or more of the values in bufs is anything
*         other than GL_NONE or one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if n is less than 0.
* @errors GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
* @errors GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does
*         not exist in the current GL context.
* @errors GL_INVALID_OPERATION is generated if any value in bufs is GL_BACK, and n is not one.
* @errors GL_INVALID_VALUE is generated if n is greater than GL_MAX_DRAW_BUFFERS.
*
*/
#define glDrawBuffers glad_glDrawBuffers
GLAD_API_CALL PFNGLDRAWELEMENTSPROC glad_glDrawElements;
/**
* @name glDrawElements - render primitives from array data
* @usage
* @code void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @description
* 	glDrawElements specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function
* to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of
* vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to glDrawElements.<br>
* 	When glDrawElements is called, it uses count sequential elements from an enabled array, starting at indices to construct
* a sequence of geometric primitives. mode specifies what kind of primitives are constructed and how the array elements
* construct these primitives. If more than one array is enabled, each is used.<br>
* 	Vertex attributes that are modified by glDrawElements have an unspecified value after glDrawElements returns.  Attributes
* that aren't modified maintain their previous values.<br>
*
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElements glad_glDrawElements
GLAD_API_CALL PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
/**
* @name glDrawElementsBaseVertex - render primitives from array data with a per-element offset
* @usage
* @code void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @description
* 	glDrawElementsBaseVertex behaves identically to glDrawElements except that the ith element transferred by the corresponding
* draw call will be taken from element indices[i] + basevertex of each enabled array. If the resulting value is larger
* than the maximum value representable by type, it is as if the calculation were upconverted to 32-bit unsigned integers
* (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.<br>
*
* @note glDrawElementsBaseVertex is only supported if the GL version is 3.2 or greater, or if the ARB_draw_elements_base_vertex
*       extension is supported.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElementsBaseVertex glad_glDrawElementsBaseVertex
GLAD_API_CALL PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;
/**
* @name glDrawElementsIndirect - render indexed primitives from array data, taking parameters from memory
* @usage
* @code void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param type Specifies the type of data in the buffer bound to the <b>GL_ELEMENT_ARRAY_BUFFER</b> binding.
* @param indirect Specifies the address of a structure containing the draw parameters.
* @description
* 	glDrawElementsIndirect specifies multiple indexed geometric primitives with very few subroutine calls. glDrawElementsIndirect
* behaves similarly to glDrawElementsInstancedBaseVertexBaseInstance, execpt that the parameters to glDrawElementsInstancedBaseVertexBaseInstance
* are stored in memory at the address given by indirect.<br>
* 	The parameters addressed by indirect are packed into a structure that takes the form (in C):<br>
* 	glDrawElementsIndirect is equivalent to:<br>
* 	If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time of a call to glDrawElementsIndirect, indirect is
* interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather
* than from client memory.<br>
* 	Note that indices stored in client memory are not supported. If no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding,
* an error will be generated.<br>
* 	The results of the operation are undefined if the reservedMustBeZero member of the parameter structure is non-zero. However,
* no error is generated in this case.<br>
* 	Vertex attributes that are modified by glDrawElementsIndirect have an unspecified value after glDrawElementsIndirect returns.
* Attributes that aren't modified remain well defined.<br>
*
* @note The baseInstance member of the DrawElementsIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier
*       versions of the GL, behavior is undefined if it is non-zero.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glDrawElementsIndirect glad_glDrawElementsIndirect
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
/**
* @name glDrawElementsInstanced - draw multiple instances of a set of elements
* @usage
* @code void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @description
* 	glDrawElementsInstanced behaves identically to glDrawElements except that instancecount instances of the set of elements
* are executed and the value of the internal counter instanceID advances for each iteration. instanceID is an internal 32-bit
* integer counter that may be read by a vertex shader as gl_InstanceID.<br>
* 	glDrawElementsInstanced has the same effect as:<br>
*
* @note glDrawElementsInstanced is available only if the GL version is 3.1 or greater.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP,
*         GL_TRIANGLE_FAN, or GL_TRIANGLES.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawElementsInstanced glad_glDrawElementsInstanced
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;
/**
* @name glDrawElementsInstancedBaseInstance - draw multiple instances of a set of elements with offset applied to instanced attributes
* @usage
* @code void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.
* @description
* 	glDrawElementsInstancedBaseInstance behaves identically to glDrawElements except that instancecount instances of the set
* of elements are executed and the value of the internal counter instanceID advances for each iteration. instanceID is an
* internal 32-bit integer counter that may be read by a vertex shader as gl_InstanceID.<br>
* 	glDrawElementsInstancedBaseInstance has the same effect as:<br>
* 	Specific vertex attributes may be classified as instanced through the use of glVertexAttribDivisor. Instanced vertex attributes
* supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced
* vertex attribute arrays is calculated as gl_InstanceID divisor +baseInstance . Note that baseinstance does not affect
* the shader-visible value of gl_InstanceID.<br>
*
* @note glDrawElementsInstancedBaseInstance is available only if the GL version is 4.2 or greater.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP,
*         GL_TRIANGLE_FAN, or GL_TRIANGLES.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawElementsInstancedBaseInstance glad_glDrawElementsInstancedBaseInstance
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
/**
* @name glDrawElementsInstancedBaseVertex - render multiple instances of a set of primitives from array data with a per-element offset
* @usage
* @code void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the indexed geometry that should be drawn.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @description
* 	glDrawElementsInstancedBaseVertex behaves identically to glDrawElementsInstanced except that the ith element transferred
* by the corresponding draw call will be taken from element indices[i] + basevertex of each enabled array. If the resulting
* value is larger than the maximum value representable by type, it is as if the calculation were upconverted to 32-bit
* unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.<br>
*
* @note glDrawElementsInstancedBaseVertex is only supported if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElementsInstancedBaseVertex glad_glDrawElementsInstancedBaseVertex
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;
/**
* @name glDrawElementsInstancedBaseVertexBaseInstance - render multiple instances of a set of primitives from array data with a per-element offset
* @usage
* @code void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the indexed geometry that should be drawn.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.
* @description
* 	glDrawElementsInstancedBaseVertexBaseInstance behaves identically to glDrawElementsInstanced except that the ith element
* transferred by the corresponding draw call will be taken from element indices[i] + basevertex of each enabled array. If
* the resulting value is larger than the maximum value representable by type, it is as if the calculation were upconverted
* to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.<br>
* 	Specific vertex attributes may be classified as instanced through the use of glVertexAttribDivisor. Instanced vertex attributes
* supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced
* vertex attribute arrays is calculated as gl_InstanceID divisor +baseInstance . Note that baseinstance does not affect
* the shader-visible value of gl_InstanceID.<br>
*
* @note glDrawElementsInstancedBaseVertex is only supported if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElementsInstancedBaseVertexBaseInstance glad_glDrawElementsInstancedBaseVertexBaseInstance
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
/**
* @name glDrawRangeElements - render primitives from array data
* @usage
* @code void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param start Specifies the minimum array index contained in <em class="parameter"><b>indices</b></em>.
* @param end Specifies the maximum array index contained in <em class="parameter"><b>indices</b></em>.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @description
* 	glDrawRangeElements is a restricted form of glDrawElements. mode, and count match the corresponding arguments to glDrawElements,
* with the additional constraint that all values in the arrays count must lie between start and end, inclusive.<br>
* 	Implementations denote recommended maximum amounts of vertex and index data, which may be queried by calling glGet with
* argument GL_MAX_ELEMENTS_VERTICES and GL_MAX_ELEMENTS_INDICES. If end-start+1 is greater than the value of GL_MAX_ELEMENTS_VERTICES,
* or if count is greater than the value of GL_MAX_ELEMENTS_INDICES, then the call may operate at reduced performance.
*  There is no requirement that all vertices in the range startend be referenced.  However, the implementation may
* partially process unused vertices, reducing performance from what could be achieved with an optimal index set.<br>
* 	When glDrawRangeElements is called, it uses count sequential elements from an enabled array, starting at start to construct
* a sequence of geometric primitives. mode specifies what kind of primitives are constructed, and how the array elements
* construct these primitives. If more than one array is enabled, each is used.<br>
* 	Vertex attributes that are modified by glDrawRangeElements have an unspecified value after glDrawRangeElements returns.
* Attributes that aren't modified maintain their previous values.<br>
*
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors It is an error for indices to lie outside the range startend , but implementations may not check for this situation. Such
*         indices cause implementation-dependent behavior.
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_VALUE is generated if end<start .
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawRangeElements glad_glDrawRangeElements
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
/**
* @name glDrawRangeElementsBaseVertex - render primitives from array data with a per-element offset
* @usage
* @code void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param start Specifies the minimum array index contained in <em class="parameter"><b>indices</b></em>.
* @param end Specifies the maximum array index contained in <em class="parameter"><b>indices</b></em>.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @description
* 	glDrawRangeElementsBaseVertex is a restricted form of glDrawElementsBaseVertex. mode, count and basevertex match the corresponding
* arguments to glDrawElementsBaseVertex, with the additional constraint that all values in the array indices must
* lie between start and end, inclusive, prior to adding basevertex. Index values lying outside the range [start, end]
* are treated in the same way as glDrawElementsBaseVertex. The ith element transferred by the corresponding draw call will
* be taken from element indices[i] + basevertex of each enabled array. If the resulting value is larger than the maximum
* value representable by type, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on
* overflow conditions). The operation is undefined if the sum would be negative.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_VALUE is generated if end < start.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawRangeElementsBaseVertex glad_glDrawRangeElementsBaseVertex
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;
/**
* @name glDrawTransformFeedback - render primitives using a count derived from a transform feedback object
* @usage
* @code void glDrawTransformFeedback(GLenum mode, GLuint id); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @description
* 	glDrawTransformFeedback draws primitives of a type specified by mode using a count retrieved from the transform feedback
* specified by id. Calling glDrawTransformFeedback is equivalent to calling glDrawArrays with mode as specified, first set
* to zero, and count set to the number of vertices captured on vertex stream zero the last time transform feedback was
* active on the transform feedback object named by id.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedback glad_glDrawTransformFeedback
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;
/**
* @name glDrawTransformFeedbackInstanced - render multiple instances of primitives using a count derived from a transform feedback object
* @usage
* @code void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @param instancecount Specifies the number of instances of the geometry to render.
* @description
* 	glDrawTransformFeedbackInstanced draws multiple copies of a range of primitives of a type specified by mode using a count
* retrieved from the transform feedback stream specified by stream of the transform feedback object specified by id. Calling
* glDrawTransformFeedbackInstanced is equivalent to calling glDrawArraysInstanced with mode and instancecount as specified,
* first set to zero, and count set to the number of vertices captured on vertex stream zero the last time transform
* feedback was active on the transform feedback object named by id.<br>
* 	Calling glDrawTransformFeedbackInstanced is equivalent to calling glDrawTransformFeedbackStreamInstanced with stream set
* to zero.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedbackInstanced glad_glDrawTransformFeedbackInstanced
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;
/**
* @name glDrawTransformFeedbackStream - render primitives using a count derived from a specifed stream of a transform feedback object
* @usage
* @code void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @param stream Specifies the index of the transform feedback stream from which to retrieve a primitive count.
* @description
* 	glDrawTransformFeedbackStream draws primitives of a type specified by mode using a count retrieved from the transform feedback
* stream specified by stream of the transform feedback object specified by id. Calling glDrawTransformFeedbackStream
* is equivalent to calling glDrawArrays with mode as specified, first set to zero, and count set to the number of vertices
* captured on vertex stream stream the last time transform feedback was active on the transform feedback object named
* by id.<br>
* 	Calling glDrawTransformFeedback is equivalent to calling glDrawTransformFeedbackStream with stream set to zero.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedbackStream glad_glDrawTransformFeedbackStream
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;
/**
* @name glDrawTransformFeedbackStreamInstanced - render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
* @usage
* @code void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @param stream Specifies the index of the transform feedback stream from which to retrieve a primitive count.
* @param instancecount Specifies the number of instances of the geometry to render.
* @description
* 	glDrawTransformFeedbackStreamInstanced draws multiple copies of a range of primitives of a type specified by mode using
* a count retrieved from the transform feedback stream specified by stream of the transform feedback object specified by
* id. Calling glDrawTransformFeedbackStreamInstanced is equivalent to calling glDrawArraysInstanced with mode and instancecount
* as specified, first set to zero, and count set to the number of vertices captured on vertex stream stream the last
* time transform feedback was active on the transform feedback object named by id.<br>
* 	Calling glDrawTransformFeedbackInstanced is equivalent to calling glDrawTransformFeedbackStreamInstanced with stream set
* to zero.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedbackStreamInstanced glad_glDrawTransformFeedbackStreamInstanced
GLAD_API_CALL PFNGLENABLEPROC glad_glEnable;
/**
* @name glEnable - enable or disable server-side GL capabilities
* @usage
* @code void glEnable(GLenum cap); @endcode
* @param cap Specifies a symbolic constant indicating a GL capability.
* @param index Specifies the index of the switch to disable (for <b>glEnablei</b> and <b>glDisablei</b> only).
* @description
* 	glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to determine the current setting
* of any capability. The initial value for each capability with the exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE.
* The initial value for GL_DITHER and GL_MULTISAMPLE is GL_TRUE.<br>
* 	Both glEnable and glDisable take a single argument, cap, which can assume one of the following values:<br>
* 	Some of the GL's capabilities are indexed. glEnablei and glDisablei enable and disable indexed capabilities.<br>
* 	If enabled, blend the computed fragment color values with the values in the color buffers. See glBlendFunc.<br>
* 	If enabled, clip geometry against user-defined half space i.<br>
* 	If enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See
* glLogicOp.<br>
* 	If enabled, cull polygons based on their winding in window coordinates. See glCullFace.<br>
* 	If enabled, debug messages are produced by a debug context. When disabled, the debug message log is silenced. Note that
* in a non-debug context, very few, if any messages might be produced, even when GL_DEBUG_OUTPUT is enabled.<br>
* 	If enabled, debug messages are produced synchronously by a debug context. If disabled, debug messages may be produced asynchronously.
* In particular, they may be delayed relative to the execution of GL commands, and the debug callback function
* may be called from a thread other than that in which the commands are executed. See glDebugMessageCallback.<br>
* 	If enabled, the -wc≤zc≤wc plane equation is ignored by view volume clipping (effectively, there is no near or far plane
* clipping). See glDepthRange.<br>
* 	If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask
* is non-zero, the depth buffer is not updated if the depth test is disabled. See glDepthFunc and glDepthRange.<br>
* 	If enabled, dither color components or indices before they are written to the color buffer.<br>
* 	If enabled and the value of GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding to the
* destination buffer is GL_SRGB, the R, G, and B destination color values (after conversion from fixed-point to floating-point)
* are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.<br>
* 	If enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See glLineWidth.<br>
* 	If enabled, use multiple fragment samples in computing the final color of a pixel. See glSampleCoverage.<br>
* 	If enabled, and if the polygon is rendered in GL_FILL mode, an offset is added to depth values of a polygon's fragments
* before the depth comparison is performed. See glPolygonOffset.<br>
* 	If enabled, and if the polygon is rendered in GL_LINE mode, an offset is added to depth values of a polygon's fragments
* before the depth comparison is performed. See glPolygonOffset.<br>
* 	If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the
* polygon is rendered in GL_POINT mode. See glPolygonOffset.<br>
* 	If enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an
* alpha buffer is needed and the polygons must be sorted front to back.<br>
* 	Enables primitive restarting.  If enabled, any one of the draw commands which transfers a set of generic attribute array
* elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See
* glPrimitiveRestartIndex.<br>
* 	Enables primitive restarting with a fixed index. If enabled, any one of the draw commands which transfers a set of generic
* attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the fixed primitive
* index for the specified index type. The fixed index is equal to 2n−1 where n is equal to 8 for GL_UNSIGNED_BYTE,
* 16 for GL_UNSIGNED_SHORT and 32 for GL_UNSIGNED_INT.<br>
* 	If enabled, primitives are discarded after the optional transform feedback stage, but before rasterization. Furthermore,
* when enabled, glClear, glClearBufferData, glClearBufferSubData, glClearTexImage, and glClearTexSubImage are ignored.<br>
* 	If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample
* location.  The temporary coverage value is then ANDed with the fragment coverage value.<br>
* 	If enabled, each sample alpha value is replaced by the maximum representable alpha value.<br>
* 	If enabled, the fragment's coverage is ANDed with the temporary coverage value.  If GL_SAMPLE_COVERAGE_INVERT is set to
* GL_TRUE, invert the coverage value. See glSampleCoverage.<br>
* 	If enabled, the active fragment shader is run once for each covered sample, or at fraction of this rate as determined by
* the current value of GL_MIN_SAMPLE_SHADING_VALUE. See glMinSampleShading.<br>
* 	If enabled, the sample coverage mask generated for a fragment during rasterization will be ANDed with the value of GL_SAMPLE_MASK_VALUE
* before shading occurs. See glSampleMaski.<br>
* 	If enabled, discard fragments that are outside the scissor rectangle. See glScissor.<br>
* 	If enabled, do stencil testing and update the stencil buffer. See glStencilFunc and glStencilOp.<br>
* 	If enabled, cubemap textures are sampled such that when linearly sampling from the border between two adjacent faces, texels
* from both faces are used to generate the final sample value. When disabled, texels from only a single face are used
* to construct the final sample value.<br>
* 	If enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped)
* shader builtin gl_PointSize and clamped to the implementation-dependent point size range.<br>
*
* @note GL_PRIMITIVE_RESTART is available only if the GL version is 3.1 or greater.
* @note GL_TEXTURE_CUBE_MAP_SEAMLESS is available only if the GL version is 3.2 or greater.
* @note GL_PRIMITIVE_RESTART_FIXED_INDEX is available only if the GL version is 4.3 or greater.
* @note GL_DEBUG_OUTPUT and GL_DEBUG_OUTPUT_SYNCHRONOUS are available only if the GL version is 4.3 or greater.
* @note Any token accepted by glEnable or glDisable is also accepted by glEnablei and glDisablei, but if the capability is not indexed,
*       the maximum value that index may take is zero.
* @note In general, passing an indexed capability to glEnable or glDisable will enable or disable that capability for all indices,
*       resepectively.
*
* @errors GL_INVALID_ENUM is generated if cap is not one of the values listed previously.
* @errors GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities
*         for cap.
*
*/
#define glEnable glad_glEnable
GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
* @description
* 	glEnableVertexAttribArray and glEnableVertexArrayAttrib enable the generic vertex attribute array specified by index. glEnableVertexAttribArray
* uses currently bound vertex array object for the operation, whereas glEnableVertexArrayAttrib updates
* state of the vertex array object with ID vaobj.<br>
* 	glDisableVertexAttribArray and glDisableVertexArrayAttrib disable the generic vertex attribute array specified by index.
* glDisableVertexAttribArray uses currently bound vertex array object for the operation, whereas glDisableVertexArrayAttrib
* updates state of the vertex array object with ID vaobj.<br>
* 	By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values
* in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array
* commands such as glDrawArrays, glDrawElements, glDrawRangeElements, glMultiDrawElements, or glMultiDrawArrays.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glEnableVertexArrayAttrib glad_glEnableVertexArrayAttrib
GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
* @description
* 	glEnableVertexAttribArray and glEnableVertexArrayAttrib enable the generic vertex attribute array specified by index. glEnableVertexAttribArray
* uses currently bound vertex array object for the operation, whereas glEnableVertexArrayAttrib updates
* state of the vertex array object with ID vaobj.<br>
* 	glDisableVertexAttribArray and glDisableVertexArrayAttrib disable the generic vertex attribute array specified by index.
* glDisableVertexAttribArray uses currently bound vertex array object for the operation, whereas glDisableVertexArrayAttrib
* updates state of the vertex array object with ID vaobj.<br>
* 	By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values
* in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array
* commands such as glDrawArrays, glDrawElements, glDrawRangeElements, glMultiDrawElements, or glMultiDrawArrays.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glEnableVertexAttribArray glad_glEnableVertexAttribArray
GLAD_API_CALL PFNGLENABLEIPROC glad_glEnablei;
// Unable to find the docs for this function!
#define glEnablei glad_glEnablei
GLAD_API_CALL PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
// Unable to find the docs for this function!
#define glEndConditionalRender glad_glEndConditionalRender
GLAD_API_CALL PFNGLENDQUERYPROC glad_glEndQuery;
// Unable to find the docs for this function!
#define glEndQuery glad_glEndQuery
GLAD_API_CALL PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;
// Unable to find the docs for this function!
#define glEndQueryIndexed glad_glEndQueryIndexed
GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
// Unable to find the docs for this function!
#define glEndTransformFeedback glad_glEndTransformFeedback
GLAD_API_CALL PFNGLFENCESYNCPROC glad_glFenceSync;
/**
* @name glFenceSync - create a new sync object and insert it into the GL command stream
* @usage
* @code GLsync glFenceSync(GLenum condition, GLbitfield flags); @endcode
* @param condition Specifies the condition that must be met to set the sync object's state to signaled. <em class="parameter"><b>condition</b></em>
*                  must be <b>GL_SYNC_GPU_COMMANDS_COMPLETE</b>.
* @param flags Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for
*              this operation and <em class="parameter"><b>flags</b></em> must be zero. <a class="footnote" href="#ftn. id-1. 5. 2. 2.
*              2. 1. 2"><sup class="footnote" id="id-1. 5. 2. 2. 2. 1. 2">[1]</sup></a>
* @description
* 	glFenceSync creates a new fence sync object, inserts a fence command into the GL command stream and associates it with
* that sync object, and returns a non-zero name corresponding to the sync object.<br>
* 	When the specified condition of the sync object is satisfied by the fence command, the sync object is signaled by the GL,
* causing any glWaitSync, glClientWaitSync commands blocking in sync to unblock. No other state is affected by glFenceSync
* or by the execution of the associated fence command.<br>
* 	condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. This condition is satisfied by completion of the fence command corresponding
* to the sync object and all preceding commands in the same command stream. The sync object will not be signaled until
* all effects from these commands on GL client and server state and the framebuffer are fully realized. Note that completion
* of the fence command occurs once the state of the corresponding sync object has been changed, but commands waiting
* on that sync object may not be unblocked until after the fence command completes.<br>
*
* @note glFenceSync is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is supported.
*
* @errors GL_INVALID_ENUM is generated if condition is not GL_SYNC_GPU_COMMANDS_COMPLETE.
* @errors GL_INVALID_VALUE is generated if flags is not zero.
* @errors Additionally, if glFenceSync fails, it will return zero.
*
*/
#define glFenceSync glad_glFenceSync
GLAD_API_CALL PFNGLFINISHPROC glad_glFinish;
/**
* @name glFinish - block until all GL execution is complete
* @usage
* @code void glFinish( void); @endcode
* @description
* 	glFinish does not return until the effects of all previously called GL commands are complete. Such effects include all
* changes to GL state, all changes to connection state, and all changes to the frame buffer contents.<br>
*
* @note glFinish requires a round trip to the server.
*
*
*/
#define glFinish glad_glFinish
GLAD_API_CALL PFNGLFLUSHPROC glad_glFlush;
/**
* @name glFlush - force execution of GL commands in finite time
* @usage
* @code void glFlush( void); @endcode
* @description
* 	Different GL implementations buffer commands in several different locations, including network buffers and the graphics
* accelerator itself. glFlush empties all of these buffers, causing all issued commands to be executed as quickly as they
* are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period,
* it does complete in finite time.<br>
* 	Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should
* call glFlush whenever they count on having all of their previously issued commands completed. For example, call glFlush
* before waiting for user input that depends on the generated image.<br>
*
* @note glFlush can return at any time. It does not wait until the execution of all previously issued GL commands is complete.
*
*
*/
#define glFlush glad_glFlush
GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
/**
* @name glFlushMappedBufferRange, glFlushMappedNamedBufferRange - indicate modifications to a range of a mapped buffer
* @usage
* @code void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length); @endcode
* @code void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glFlushMappedBufferRange</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glFlushMappedNamedBufferRange</b>.
* @param offset Specifies the start of the buffer subrange, in basic machine units.
* @param length Specifies the length of the buffer subrange, in basic machine units.
* @description
* 	glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped buffer object. The buffer object
* must previously have been mapped with the GL_MAP_FLUSH_EXPLICIT_BIT flag.<br>
* 	offset and length indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush
* is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate
* distinct subranges of the mapping which require flushing.<br>
* 	If a buffer range is mapped with both GL_MAP_PERSISTENT_BIT and GL_MAP_FLUSH_EXPLICIT_BIT set, then these commands may
* be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written
* to a coherent store will always become visible to the server after an unspecified period of time.<br>
*
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glFlushMappedBufferRange if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedBufferRange if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedNamedBufferRange if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length exceeds the size of the mapping.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not mapped, or is mapped without the GL_MAP_FLUSH_EXPLICIT_BIT
*         flag.
*
*/
#define glFlushMappedBufferRange glad_glFlushMappedBufferRange
GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;
/**
* @name glFlushMappedBufferRange, glFlushMappedNamedBufferRange - indicate modifications to a range of a mapped buffer
* @usage
* @code void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length); @endcode
* @code void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glFlushMappedBufferRange</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glFlushMappedNamedBufferRange</b>.
* @param offset Specifies the start of the buffer subrange, in basic machine units.
* @param length Specifies the length of the buffer subrange, in basic machine units.
* @description
* 	glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped buffer object. The buffer object
* must previously have been mapped with the GL_MAP_FLUSH_EXPLICIT_BIT flag.<br>
* 	offset and length indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush
* is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate
* distinct subranges of the mapping which require flushing.<br>
* 	If a buffer range is mapped with both GL_MAP_PERSISTENT_BIT and GL_MAP_FLUSH_EXPLICIT_BIT set, then these commands may
* be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written
* to a coherent store will always become visible to the server after an unspecified period of time.<br>
*
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glFlushMappedBufferRange if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedBufferRange if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedNamedBufferRange if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length exceeds the size of the mapping.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not mapped, or is mapped without the GL_MAP_FLUSH_EXPLICIT_BIT
*         flag.
*
*/
#define glFlushMappedNamedBufferRange glad_glFlushMappedNamedBufferRange
GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;
/**
* @name glFramebufferParameteri, glNamedFramebufferParameteri - set a named parameter of a framebuffer object
* @usage
* @code void glFramebufferParameteri(GLenum target, GLenum pname, GLint param); @endcode
* @code void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferParameteri</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferParameteri</b>.
* @param pname Specifies the framebuffer parameter to be modified.
* @param param The new value for the parameter named <em class="parameter"><b>pname</b></em>.
* @description
* 	glFramebufferParameteri and glNamedFramebufferParameteri modify the value of the parameter named pname in the specified
* framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid
* targets of these commands.<br>
* 	For glFramebufferParameteri, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferParameteri, framebuffer is the name of the framebuffer object.<br>
* 	pname specifies the parameter to be modified. The following values are accepted:<br>
* 	param specifies the assumed with for a framebuffer object with no attachments. If a framebuffer has attachments then the
* width of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_WIDTH is used for the framebuffer. param
* must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_WIDTH.<br>
* 	param specifies the assumed height for a framebuffer object with no attachments. If a framebuffer has attachments then
* the height of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_HEIGHT is used for the framebuffer.
* param must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_HEIGHT.<br>
* 	param specifies the assumed number of layers for a framebuffer object with no attachments. If a framebuffer has attachments
* then the layer count of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_LAYERS is used for
* the framebuffer. param must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_LAYERS.<br>
* 	param specifies the assumed number of samples in a framebuffer object with no attachments. If a framebuffer has attachments
* then the sample count of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_SAMPLES is used for
* the framebuffer. param must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_SAMPLE.<br>
* 	param specifies whether the framebuffer should assume identical sample locations and the same number of samples for all
* texels in the virtual image. If param is zero, then the implementation may vary the position or the count of samples within
* the virtual image from pixel to pixel, otherwise it will use the same sample position and count for all pixels in the
* virtual image.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glFramebufferParameteri if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferParameteri if the default framebuffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferParameteri if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_WIDTH and param is less than zero or greater than the value
*         of GL_MAX_FRAMEBUFFER_WIDTH.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_HEIGHT and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_HEIGHT.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_LAYERS and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_LAYERS.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_SAMPLES and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_SAMPLES.
*
*/
#define glFramebufferParameteri glad_glFramebufferParameteri
GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
/**
* @name glFramebufferRenderbuffer, glNamedFramebufferRenderbuffer - attach a renderbuffer as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @code void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferRenderbuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferRenderbuffer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param renderbuffertarget Specifies the renderbuffer target. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of an existing renderbuffer object of type <em class="parameter"><b>renderbuffertarget</b></em> to attach.
* @description
* 	glFramebufferRenderbuffer and glNamedFramebufferRenderbuffer attaches a renderbuffer as one of the logical buffers of the
* specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are
* not valid targets of these commands.<br>
* 	For glFramebufferRenderbuffer, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferRenderbuffer, framebuffer is the name of the framebuffer object.<br>
* 	renderbuffertarget must be GL_RENDERBUFFER.<br>
* 	renderbuffer must be zero or the name of an existing renderbuffer object of type renderbuffertarget. If renderbuffer is
* not zero, then the specified renderbuffer will be used as the logical buffer identified by attachment of the specified
* framebuffer object. If renderbuffer is zero, then the value of renderbuffertarget is ignored.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS minus
* one. Setting attachment to the value GL_DEPTH_STENCIL_ATTACHMENT is a special case causing both the depth and stencil
* attachments of the specified framebuffer object to be set to renderbuffer, which should have the base internal format
* GL_DEPTH_STENCIL.<br>
* 	The value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the specified attachment point is set to GL_RENDERBUFFER and the
* value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to renderbuffer. All other state values of specified attachment point
* are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment
* to the attachment logical buffer of the specified framebuffer object is broken.<br>
* 	If renderbuffer is zero, these commands will detach the image, if any, identified by the specified attachment point of
* the specified framebuffer object. All state values of the attachment point are set to their default values.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glFramebufferRenderbuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferRenderbuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferRenderbuffer if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated if renderbuffertarget is not zero or the name of an existing renderbuffer object of type
*         GL_RENDERBUFFER.
*
*/
#define glFramebufferRenderbuffer glad_glFramebufferRenderbuffer
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @description
* 	These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified
* framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets
* of these commands.<br>
* 	For all commands exceptglNamedFramebufferTexture, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER,
* GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTexture, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, textarget specifies what type of texture
* is named by texture, and for cube map textures, specifies the face that is to be attached. If texture is not zero, it must
* be the name of an existing texture object with effective target textarget unless it is a cube map texture, in which
* case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If texture is non-zero, the specified level of the texture object named texture is attached to the framebuffer attachment
* point named by attachment. For glFramebufferTexture1D, glFramebufferTexture2D, and glFramebufferTexture3D, texture must
* be zero or the name of an existing texture with an effective target of textarget, or texture must be the name of an existing
* cube-map texture and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If textarget is GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then level must be
* zero.<br>
* 	If textarget is GL_TEXTURE_3D, then level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater
* than or equal to zero and less than or equal to $log_2$ of the value of GL_MAX_CUBE_MAP_TEXTURE_SIZE.<br>
* 	For all other values of textarget, level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_TEXTURE_SIZE.<br>
* 	layer specifies the layer of a 2-dimensional image within a 3-dimensional texture.<br>
* 	For glFramebufferTexture1D, if texture is not zero, then textarget must be GL_TEXTURE_1D. For glFramebufferTexture2D, if
* texture is not zero, textarget must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D, if texture is not zero, then
* textarget must be GL_TEXTURE_3D.<br>
* 	For glFramebufferTexture and glNamedFramebufferTexture, if texture is the name of a three-dimensional, cube map array,
* cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an
* array of images, and the framebuffer attachment is considered to be layered.<br>
*
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture glad_glFramebufferTexture
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @description
* 	These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified
* framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets
* of these commands.<br>
* 	For all commands exceptglNamedFramebufferTexture, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER,
* GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTexture, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, textarget specifies what type of texture
* is named by texture, and for cube map textures, specifies the face that is to be attached. If texture is not zero, it must
* be the name of an existing texture object with effective target textarget unless it is a cube map texture, in which
* case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If texture is non-zero, the specified level of the texture object named texture is attached to the framebuffer attachment
* point named by attachment. For glFramebufferTexture1D, glFramebufferTexture2D, and glFramebufferTexture3D, texture must
* be zero or the name of an existing texture with an effective target of textarget, or texture must be the name of an existing
* cube-map texture and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If textarget is GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then level must be
* zero.<br>
* 	If textarget is GL_TEXTURE_3D, then level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater
* than or equal to zero and less than or equal to $log_2$ of the value of GL_MAX_CUBE_MAP_TEXTURE_SIZE.<br>
* 	For all other values of textarget, level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_TEXTURE_SIZE.<br>
* 	layer specifies the layer of a 2-dimensional image within a 3-dimensional texture.<br>
* 	For glFramebufferTexture1D, if texture is not zero, then textarget must be GL_TEXTURE_1D. For glFramebufferTexture2D, if
* texture is not zero, textarget must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D, if texture is not zero, then
* textarget must be GL_TEXTURE_3D.<br>
* 	For glFramebufferTexture and glNamedFramebufferTexture, if texture is the name of a three-dimensional, cube map array,
* cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an
* array of images, and the framebuffer attachment is considered to be layered.<br>
*
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture1D glad_glFramebufferTexture1D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @description
* 	These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified
* framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets
* of these commands.<br>
* 	For all commands exceptglNamedFramebufferTexture, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER,
* GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTexture, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, textarget specifies what type of texture
* is named by texture, and for cube map textures, specifies the face that is to be attached. If texture is not zero, it must
* be the name of an existing texture object with effective target textarget unless it is a cube map texture, in which
* case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If texture is non-zero, the specified level of the texture object named texture is attached to the framebuffer attachment
* point named by attachment. For glFramebufferTexture1D, glFramebufferTexture2D, and glFramebufferTexture3D, texture must
* be zero or the name of an existing texture with an effective target of textarget, or texture must be the name of an existing
* cube-map texture and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If textarget is GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then level must be
* zero.<br>
* 	If textarget is GL_TEXTURE_3D, then level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater
* than or equal to zero and less than or equal to $log_2$ of the value of GL_MAX_CUBE_MAP_TEXTURE_SIZE.<br>
* 	For all other values of textarget, level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_TEXTURE_SIZE.<br>
* 	layer specifies the layer of a 2-dimensional image within a 3-dimensional texture.<br>
* 	For glFramebufferTexture1D, if texture is not zero, then textarget must be GL_TEXTURE_1D. For glFramebufferTexture2D, if
* texture is not zero, textarget must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D, if texture is not zero, then
* textarget must be GL_TEXTURE_3D.<br>
* 	For glFramebufferTexture and glNamedFramebufferTexture, if texture is the name of a three-dimensional, cube map array,
* cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an
* array of images, and the framebuffer attachment is considered to be layered.<br>
*
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture2D glad_glFramebufferTexture2D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @description
* 	These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified
* framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets
* of these commands.<br>
* 	For all commands exceptglNamedFramebufferTexture, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER,
* GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTexture, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, textarget specifies what type of texture
* is named by texture, and for cube map textures, specifies the face that is to be attached. If texture is not zero, it must
* be the name of an existing texture object with effective target textarget unless it is a cube map texture, in which
* case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If texture is non-zero, the specified level of the texture object named texture is attached to the framebuffer attachment
* point named by attachment. For glFramebufferTexture1D, glFramebufferTexture2D, and glFramebufferTexture3D, texture must
* be zero or the name of an existing texture with an effective target of textarget, or texture must be the name of an existing
* cube-map texture and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If textarget is GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then level must be
* zero.<br>
* 	If textarget is GL_TEXTURE_3D, then level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater
* than or equal to zero and less than or equal to $log_2$ of the value of GL_MAX_CUBE_MAP_TEXTURE_SIZE.<br>
* 	For all other values of textarget, level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_TEXTURE_SIZE.<br>
* 	layer specifies the layer of a 2-dimensional image within a 3-dimensional texture.<br>
* 	For glFramebufferTexture1D, if texture is not zero, then textarget must be GL_TEXTURE_1D. For glFramebufferTexture2D, if
* texture is not zero, textarget must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D, if texture is not zero, then
* textarget must be GL_TEXTURE_3D.<br>
* 	For glFramebufferTexture and glNamedFramebufferTexture, if texture is the name of a three-dimensional, cube map array,
* cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an
* array of images, and the framebuffer attachment is considered to be layered.<br>
*
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture3D glad_glFramebufferTexture3D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
/**
* @name glFramebufferTextureLayer, glNamedFramebufferTextureLayer - attach a single layer of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferTextureLayer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTextureLayer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @param layer Specifies the layer of the texture object to attach.
* @description
* 	glFramebufferTextureLayer and glNamedFramebufferTextureLayer attach a single layer of a three-dimensional or array texture
* object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default
* draw and read framebuffer, so they are not valid targets of these commands.<br>
* 	For glFramebufferTextureLayer, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER,
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTextureLayer, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	If texture is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional
* array, or cube map array texture.<br>
* 	If texture is a three-dimensional texture, then level must be greater than or equal to zero and less than or equal to $log_2$
* of the value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If texture is a two-dimensional array texture, then level must be greater than or equal to zero and less than or equal
* to $log_2$ of the value of GL_MAX_TEXTURE_SIZE.<br>
* 	For cube map textures, layer is translated into a cube map face according to $$ face = k \bmod 6. $$ For cube map array
* textures, layer is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$
* and $$ face = k \bmod 6. $$<br>
*
*
* @errors GL_INVALID_ENUM is generated by glFramebufferTexture if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferTexture if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_OPERATION is generated if texture is not zero and is not the name of an existing three-dimensional, two-dimensional
*         multisample array, one- or two-dimensional array, cube map, or cube map array texture.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture, as described
*         above.
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE minus
*         one (for three-dimensional texture objects), or larger than the value of GL_MAX_ARRAY_TEXTURE_LAYERS minus one (for array
*         texture objects).
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is negative.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTextureLayer glad_glFramebufferTextureLayer
GLAD_API_CALL PFNGLFRONTFACEPROC glad_glFrontFace;
/**
* @name glFrontFace - define front- and back-facing polygons
* @usage
* @code void glFrontFace(GLenum mode); @endcode
* @param mode Specifies the orientation of front-facing polygons. <b>GL_CW</b> and <b>GL_CCW</b> are accepted. The initial value is <b>GL_CCW</b>.
* @description
* 	In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible
* polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing
* polygons, call glEnable and  glDisable with argument GL_CULL_FACE.<br>
* 	The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the
* path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves
* in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if
* the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. glFrontFace
* specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window
* coordinates, are taken to be front-facing. Passing GL_CCW to mode selects counterclockwise polygons as front-facing; GL_CW
* selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
*
*/
#define glFrontFace glad_glFrontFace
GLAD_API_CALL PFNGLGENBUFFERSPROC glad_glGenBuffers;
/**
* @name glGenBuffers - generate buffer object names
* @usage
* @code void glGenBuffers(GLsizei n, GLuint * buffers); @endcode
* @param n Specifies the number of buffer object names to be generated.
* @param buffers Specifies an array in which the generated buffer object names are stored.
* @description
* 	glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a contiguous set of integers;
* however, it is guaranteed that none of the returned names was in use immediately before the call to glGenBuffers.<br>
* 	Buffer object names returned by a call to glGenBuffers are not returned by subsequent calls, unless they are first deleted
* with glDeleteBuffers.<br>
* 	No buffer objects are associated with the returned buffer object names until they are first bound by calling glBindBuffer.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenBuffers glad_glGenBuffers
GLAD_API_CALL PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
/**
* @name glGenFramebuffers - generate framebuffer object names
* @usage
* @code void glGenFramebuffers(GLsizei n, GLuint *ids); @endcode
* @param n Specifies the number of framebuffer object names to generate.
* @param ids Specifies an array in which the generated framebuffer object names are stored.
* @description
* 	glGenFramebuffers returns n framebuffer object names in ids. There is no guarantee that the names form a contiguous set
* of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenFramebuffers.<br>
* 	Framebuffer object names returned by a call to glGenFramebuffers are not returned by subsequent calls, unless they are
* first deleted with glDeleteFramebuffers.<br>
* 	The names returned in ids are marked as used, for the purposes of glGenFramebuffers only, but they acquire state and type
* only when they are first bound.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenFramebuffers glad_glGenFramebuffers
GLAD_API_CALL PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;
/**
* @name glGenProgramPipelines - reserve program pipeline object names
* @usage
* @code void glGenProgramPipelines(GLsizei n, GLuint *pipelines); @endcode
* @param n Specifies the number of program pipeline object names to reserve.
* @param pipelines Specifies an array of into which the reserved names will be written.
* @description
* 	glGenProgramPipelines returns n previously unused program pipeline object names in pipelines. These names are marked as
* used, for the purposes of glGenProgramPipelines only, but they acquire program pipeline state only when they are first
* bound.<br>
*
*
*
*/
#define glGenProgramPipelines glad_glGenProgramPipelines
GLAD_API_CALL PFNGLGENQUERIESPROC glad_glGenQueries;
/**
* @name glGenQueries - generate query object names
* @usage
* @code void glGenQueries(GLsizei n, GLuint * ids); @endcode
* @param n Specifies the number of query object names to be generated.
* @param ids Specifies an array in which the generated query object names are stored.
* @description
* 	glGenQueries returns n query object names in ids. There is no guarantee that the names form a contiguous set of integers;
* however, it is guaranteed that none of the returned names was in use immediately before the call to glGenQueries.<br>
* 	Query object names returned by a call to glGenQueries are not returned by subsequent calls, unless they are first deleted
* with glDeleteQueries.<br>
* 	No query objects are associated with the returned query object names until they are first used by calling glBeginQuery.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenQueries glad_glGenQueries
GLAD_API_CALL PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
/**
* @name glGenRenderbuffers - generate renderbuffer object names
* @usage
* @code void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers); @endcode
* @param n Specifies the number of renderbuffer object names to generate.
* @param renderbuffers Specifies an array in which the generated renderbuffer object names are stored.
* @description
* 	glGenRenderbuffers returns n renderbuffer object names in renderbuffers. There is no guarantee that the names form a contiguous
* set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call
* to glGenRenderbuffers.<br>
* 	Renderbuffer object names returned by a call to glGenRenderbuffers are not returned by subsequent calls, unless they are
* first deleted with glDeleteRenderbuffers.<br>
* 	The names returned in renderbuffers are marked as used, for the purposes of glGenRenderbuffers only, but they acquire state
* and type only when they are first bound.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenRenderbuffers glad_glGenRenderbuffers
GLAD_API_CALL PFNGLGENSAMPLERSPROC glad_glGenSamplers;
/**
* @name glGenSamplers - generate sampler object names
* @usage
* @code void glGenSamplers(GLsizei n, GLuint *samplers); @endcode
* @param n Specifies the number of sampler object names to generate.
* @param samplers Specifies an array in which the generated sampler object names are stored.
* @description
* 	glGenSamplers returns n sampler object names in samplers. There is no guarantee that the names form a contiguous set of
* integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenSamplers.<br>
* 	Sampler object names returned by a call to glGenSamplers are not returned by subsequent calls, unless they are first deleted
* with glDeleteSamplers.<br>
* 	The names returned in samplers are marked as used, for the purposes of glGenSamplers only, but they acquire state and type
* only when they are first bound.<br>
*
* @note glGenSamplers is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenSamplers glad_glGenSamplers
GLAD_API_CALL PFNGLGENTEXTURESPROC glad_glGenTextures;
/**
* @name glGenTextures - generate texture names
* @usage
* @code void glGenTextures(GLsizei n, GLuint * textures); @endcode
* @param n Specifies the number of texture names to be generated.
* @param textures Specifies an array in which the generated texture names are stored.
* @description
* 	glGenTextures returns n texture names in textures. There is no guarantee that the names form a contiguous set of integers;
* however, it is guaranteed that none of the returned names was in use immediately before the call to glGenTextures.<br>
* 	The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first
* bound (see glBindTexture).<br>
* 	Texture names returned by a call to glGenTextures are not returned by subsequent calls, unless they are first deleted with
* glDeleteTextures.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenTextures glad_glGenTextures
GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;
/**
* @name glGenTransformFeedbacks - reserve transform feedback object names
* @usage
* @code void glGenTransformFeedbacks(GLsizei n, GLuint *ids); @endcode
* @param n Specifies the number of transform feedback object names to reserve.
* @param ids Specifies an array of into which the reserved names will be written.
* @description
* 	glGenTransformFeedbacks returns n previously unused transform feedback object names in ids. These names are marked as used,
* for the purposes of glGenTransformFeedbacks only, but they acquire transform feedback state only when they are first
* bound.<br>
*
*
*
*/
#define glGenTransformFeedbacks glad_glGenTransformFeedbacks
GLAD_API_CALL PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
/**
* @name glGenVertexArrays - generate vertex array object names
* @usage
* @code void glGenVertexArrays(GLsizei n, GLuint *arrays); @endcode
* @param n Specifies the number of vertex array object names to generate.
* @param arrays Specifies an array in which the generated vertex array object names are stored.
* @description
* 	glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the names form a contiguous
* set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenVertexArrays.<br>
* 	Vertex array object names returned by a call to glGenVertexArrays are not returned by subsequent calls, unless they are
* first deleted with glDeleteVertexArrays.<br>
* 	The names returned in arrays are marked as used, for the purposes of glGenVertexArrays only, but they acquire state and
* type only when they are first bound.<br>
*
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenVertexArrays glad_glGenVertexArrays
GLAD_API_CALL PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
/**
* @name glGenerateMipmap, glGenerateTextureMipmap - generate mipmaps for a specified texture object
* @usage
* @code void glGenerateMipmap(GLenum target); @endcode
* @code void glGenerateTextureMipmap(GLuint texture); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glGenerateMipmap</b>. Must be one of <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP</b>,
*               or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glGenerateTextureMipmap</b>.
* @description
* 	glGenerateMipmap and glGenerateTextureMipmap generates mipmaps for the specified texture object. For glGenerateMipmap,
* the texture object that is bound to target. For glGenerateTextureMipmap, texture is the name of the texture object.<br>
* 	For cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively.<br>
* 	Mipmap generation replaces texel image levels $level_{base} + 1$ through $q$ with images derived from the $level_{base}$
* image, regardless of their previous contents. All other mimap images, including the $level_{base}$ image, are left unchanged
* by this computation.<br>
* 	The internal formats of the derived mipmap images all match those of the $level_{base}$ image. The contents of the derived
* images are computed by repeated, filtered reduction of the $level_{base}$ image. For one- and two-dimensional array
* and cube map array textures, each layer is filtered independently.<br>
*
* @note Cube map array textures are accepted only if the GL version is 4.0 or higher.
*
* @errors GL_INVALID_ENUM is generated by glGenerateMipmap if target is not one of the accepted texture targets.
* @errors GL_INVALID_OPERATION is generated by glGenerateTextureMipmap if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_CUBE_MAP or GL_TEXTURE_CUBE_MAP_ARRAY, and the specified texture
*         object is not cube complete or cube array complete, respectively.
*
*/
#define glGenerateMipmap glad_glGenerateMipmap
GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;
/**
* @name glGenerateMipmap, glGenerateTextureMipmap - generate mipmaps for a specified texture object
* @usage
* @code void glGenerateMipmap(GLenum target); @endcode
* @code void glGenerateTextureMipmap(GLuint texture); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glGenerateMipmap</b>. Must be one of <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP</b>,
*               or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glGenerateTextureMipmap</b>.
* @description
* 	glGenerateMipmap and glGenerateTextureMipmap generates mipmaps for the specified texture object. For glGenerateMipmap,
* the texture object that is bound to target. For glGenerateTextureMipmap, texture is the name of the texture object.<br>
* 	For cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively.<br>
* 	Mipmap generation replaces texel image levels $level_{base} + 1$ through $q$ with images derived from the $level_{base}$
* image, regardless of their previous contents. All other mimap images, including the $level_{base}$ image, are left unchanged
* by this computation.<br>
* 	The internal formats of the derived mipmap images all match those of the $level_{base}$ image. The contents of the derived
* images are computed by repeated, filtered reduction of the $level_{base}$ image. For one- and two-dimensional array
* and cube map array textures, each layer is filtered independently.<br>
*
* @note Cube map array textures are accepted only if the GL version is 4.0 or higher.
*
* @errors GL_INVALID_ENUM is generated by glGenerateMipmap if target is not one of the accepted texture targets.
* @errors GL_INVALID_OPERATION is generated by glGenerateTextureMipmap if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_CUBE_MAP or GL_TEXTURE_CUBE_MAP_ARRAY, and the specified texture
*         object is not cube complete or cube array complete, respectively.
*
*/
#define glGenerateTextureMipmap glad_glGenerateTextureMipmap
GLAD_API_CALL PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;
/**
* @name glGetActiveAtomicCounterBufferiv - retrieve information about the set of active atomic counter buffers for a program
* @usage
* @code void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params); @endcode
* @param program The name of a program object from which to retrieve information.
* @param bufferIndex Specifies index of an active atomic counter buffer.
* @param pname Specifies which parameter of the atomic counter buffer to retrieve.
* @param params Specifies the address of a variable into which to write the retrieved information.
* @description
* 	glGetActiveAtomicCounterBufferiv retrieves information about the set of active atomic counter buffers for a program object.
* program is the name of a program object for which the command glLinkProgram has been issued in the past. It is not
* necessary for program to have been linked successfully. The link may have failed because the number of active atomic counters
* exceeded the limits.<br>
* 	bufferIndex specifies the index of an active atomic counter buffer and must be in the range zero to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS
* minus one. The value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program indicates the number of
* active atomic counter buffer and can be queried with glGetProgram.<br>
* 	If no error occurs, the parameter(s) specified by pname are returned in params. If an error is generated, the contents
* of params are not modified.<br>
* 	If pname is GL_ATOMIC_COUNTER_BUFFER_BINDING, then the index of the counter buffer binding point associated with the active
* atomic counter buffer bufferIndex for program is returned.<br>
* 	If pname is GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE, then the implementation-dependent minimum total buffer object size, in
* baseic machine units, required to hold all active atomic counters in the atomic counter binding point identified by bufferIndex
* is returned.<br>
* 	If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS, then the number of active atomic counters for the atomic counter
* buffer identified by bufferIndex is returned.<br>
* 	If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES, then a list of the active atomic counter indices for
* the atomic counter buffer identified by bufferIndex is returned. The number of elements that will be written into params
* is the value of GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS for bufferIndex.<br>
* 	If pname is GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER, GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER,
* GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER, GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER,
* GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER, GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER then
* a boolean value indicating whether the atomic counter buffer identified by bufferIndex is referenced by the vertex, tessellation
* control, tessellation evaluation, geometry, fragment or compute processing stages of program, respectively, is
* returned.<br>
*
* @note glGetActiveAtomicCounterBufferiv is available only if the GL version is 4.2 or higher.
* @note GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER is available only of the GL version is 4.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been called in
*         the past.
* @errors GL_INVALID_VALUE is generated if bufferIndex is greater than or equal to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for
*         program.
* @errors GL_INVALID_ENUM is generated if pname is not one of the accepted tokens.
*
*/
#define glGetActiveAtomicCounterBufferiv glad_glGetActiveAtomicCounterBufferiv
GLAD_API_CALL PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
/**
* @name glGetActiveAttrib - Returns information about an active attribute variable for the specified program object
* @usage
* @code void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param index Specifies the index of the attribute variable to be queried.
* @param bufSize Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <em class="parameter"><b>name</b></em>.
* @param length Returns the number of characters actually written by OpenGL in the string indicated by <em class="parameter"><b>name</b></em>
*               (excluding the null terminator) if a value other than <b>NULL</b> is passed.
* @param size Returns the size of the attribute variable.
* @param type Returns the data type of the attribute variable.
* @param name Returns a null terminated string containing the name of the attribute variable.
* @description
* 	glGetActiveAttrib returns information about an active attribute variable in the program object specified by program. The
* number of active attributes can be obtained by calling glGetProgram with the value GL_ACTIVE_ATTRIBUTES. A value of 0
* for index selects the first active attribute variable. Permissible values for index range from zero to the number of active
* attribute variables minus one.<br>
* 	A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute
* variables have a prefix of "gl_" and reference conventional OpenGL vertex attribtes (e.g., gl_Vertex, gl_Normal, etc.,
* see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names
* and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined)
* is considered active if it is determined during the link operation that it may be accessed during program execution.
* Therefore, program should have previously been the target of a call to glLinkProgram, but it is not necessary for
* it to have been linked successfully.<br>
* 	The size of the character buffer required to store the longest attribute variable name in program can be obtained by calling
* glGetProgram with the value GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value should be used to allocate a buffer of sufficient
* size to store the returned attribute name. The size of this character buffer is passed in bufSize, and a pointer
* to this character buffer is passed in name.<br>
* 	glGetActiveAttrib returns the name of the attribute variable indicated by index, storing it in the character buffer specified
* by name. The string returned will be null terminated. The actual number of characters written into this buffer is
* returned in length, and this count does not include the null termination character. If the length of the returned string
* is not required, a value of NULL can be passed in the length argument.<br>
* 	The type argument specifies a pointer to a variable into which the attribute variable's data type will be written. The
* symbolic constants GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_FLOAT_MAT2, GL_FLOAT_MAT3, GL_FLOAT_MAT4, GL_FLOAT_MAT2x3,
* GL_FLOAT_MAT2x4, GL_FLOAT_MAT3x2, GL_FLOAT_MAT3x4, GL_FLOAT_MAT4x2, GL_FLOAT_MAT4x3, GL_INT, GL_INT_VEC2,
* GL_INT_VEC3, GL_INT_VEC4, GL_UNSIGNED_INT, GL_UNSIGNED_INT_VEC2, GL_UNSIGNED_INT_VEC3, GL_UNSIGNED_INT_VEC4, GL_DOUBLE,
* GL_DOUBLE_VEC2, GL_DOUBLE_VEC3, GL_DOUBLE_VEC4, GL_DOUBLE_MAT2, GL_DOUBLE_MAT3, GL_DOUBLE_MAT4, GL_DOUBLE_MAT2x3, GL_DOUBLE_MAT2x4,
* GL_DOUBLE_MAT3x2, GL_DOUBLE_MAT3x4, GL_DOUBLE_MAT4x2, or GL_DOUBLE_MAT4x3 may be returned. The size argument
* will return the size of the attribute, in units of the type returned in type.<br>
* 	The list of active attribute variables may include both built-in attribute variables (which begin with the prefix "gl_")
* as well as user-defined attribute variable names.<br>
* 	This function will return as much information as it can about the specified active attribute variable. If no information
* is available, length will be 0, and name will be an empty string. This situation could occur if this function is called
* after a link operation that failed. If an error occurs, the return values length, size, type, and name will be unmodified.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of active attribute variables in program.
* @errors GL_INVALID_VALUE is generated if bufSize is less than 0.
*
*/
#define glGetActiveAttrib glad_glGetActiveAttrib
GLAD_API_CALL PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;
/**
* @name glGetActiveSubroutineName - query the name of an active shader subroutine
* @usage
* @code void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name); @endcode
* @param program Specifies the name of the program containing the subroutine.
* @param shadertype Specifies the shader stage from which to query the subroutine name.
* @param index Specifies the index of the shader subroutine uniform.
* @param bufSize Specifies the size of the buffer whose address is given in <em class="parameter"><b>name</b></em>.
* @param length Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.
* @param name Specifies the address of an array into which the name of the shader subroutine uniform will be written.
* @description
* 	glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the program object given in program.
* index specifies the index of the shader subroutine uniform within the shader stage given by stage, and must between
* zero and the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.<br>
* 	The name of the selected subroutine is returned as a null-terminated string in name. The actual number of characters written
* into name, not including the null-terminator, is returned in length. If length is NULL, no length is returned. The
* maximum number of characters that may be written into name, including the null-terminator, is given in bufSize.<br>
*
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetActiveSubroutineName glad_glGetActiveSubroutineName
GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;
/**
* @name glGetActiveSubroutineUniformName - query the name of an active shader subroutine uniform
* @usage
* @code void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name); @endcode
* @param program Specifies the name of the program containing the subroutine.
* @param shadertype Specifies the shader stage from which to query for the subroutine parameter. <em class="parameter"><b>shadertype</b></em>
*                   must be one of <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>, <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param index Specifies the index of the shader subroutine uniform.
* @param bufSize Specifies the size of the buffer whose address is given in <em class="parameter"><b>name</b></em>.
* @param length Specifies the address of a variable into which is written the number of characters copied into <em class="parameter"><b>name</b></em>.
* @param name Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.
* @description
* 	glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform. program contains the name of
* the program containing the uniform. shadertype specifies the stage for which the uniform location, given by index, is
* valid. index must be between zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage.<br>
* 	The uniform name is returned as a null-terminated string in name. The actual number of characters written into name, excluding
* the null terminator is returned in length. If length is NULL, no length is returned. The maximum number of characters
* that may be written into name, including the null terminator, is specified by bufSize. The length of the longest subroutine
* uniform name in program and shadertype is given by the value of GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, which
* can be queried with glGetProgramStage.<br>
*
*
* @errors GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORMS.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetActiveSubroutineUniformName glad_glGetActiveSubroutineUniformName
GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;
// Unable to find the docs for this function!
#define glGetActiveSubroutineUniformiv glad_glGetActiveSubroutineUniformiv
GLAD_API_CALL PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
/**
* @name glGetActiveUniform - Returns information about an active uniform variable for the specified program object
* @usage
* @code void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param index Specifies the index of the uniform variable to be queried.
* @param bufSize Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <em class="parameter"><b>name</b></em>.
* @param length Returns the number of characters actually written by OpenGL in the string indicated by <em class="parameter"><b>name</b></em>
*               (excluding the null terminator) if a value other than <b>NULL</b> is passed.
* @param size Returns the size of the uniform variable.
* @param type Returns the data type of the uniform variable.
* @param name Returns a null terminated string containing the name of the uniform variable.
* @description
* 	glGetActiveUniform returns information about an active uniform variable in the program object specified by program. The
* number of active uniform variables can be obtained by calling glGetProgram with the value GL_ACTIVE_UNIFORMS. A value of
* 0 for index selects the first active uniform variable. Permissible values for index range from zero to the number of active
* uniform variables minus one.<br>
* 	Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables
* have a prefix of "gl_" and reference existing OpenGL state or values derived from such state (e.g., gl_DepthRangeParameters,
* see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names
* and obtain their values from the application through calls to glUniform. A uniform variable (either built-in or user-defined)
* is considered active if it is determined during the link operation that it may be accessed during program execution.
* Therefore, program should have previously been the target of a call to glLinkProgram, but it is not necessary for
* it to have been linked successfully.<br>
* 	The size of the character buffer required to store the longest uniform variable name in program can be obtained by calling
* glGetProgram with the value GL_ACTIVE_UNIFORM_MAX_LENGTH. This value should be used to allocate a buffer of sufficient
* size to store the returned uniform variable name. The size of this character buffer is passed in bufSize, and a pointer
* to this character buffer is passed in name.<br>
* 	glGetActiveUniform returns the name of the uniform variable indicated by index, storing it in the character buffer specified
* by name. The string returned will be null terminated. The actual number of characters written into this buffer is
* returned in length, and this count does not include the null termination character. If the length of the returned string
* is not required, a value of NULL can be passed in the length argument.<br>
* 	The type argument will return a pointer to the uniform variable's data type. The symbolic constants returned for uniform
* types are shown in the table below.<br>
* 	If one or more elements of an array are active, the name of the array is returned in name, the type is returned in type,
* and the size parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker.
* Only one active uniform variable will be reported for a uniform array.<br>
* 	Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function.
* Instead, each of these uniform variables will be reduced to its fundamental components containing the "." and "[]" operators
* such that each of the names is valid as an argument to glGetUniformLocation. Each of these reduced uniform variables
* is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of
* structures, or a subcomponent of a vector or matrix.<br>
* 	The size of the uniform variable will be returned in size. Uniform variables other than arrays will have a size of 1. Structures
* and arrays of structures will be reduced as described earlier, such that each of the names returned will be a
* data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform
* arrays; otherwise, the size returned will be 1.<br>
* 	The list of active uniform variables may include both built-in uniform variables (which begin with the prefix "gl_") as
* well as user-defined uniform variable names.<br>
* 	This function will return as much information as it can about the specified active uniform variable. If no information
* is available, length will be 0, and name will be an empty string. This situation could occur if this function is called
* after a link operation that failed. If an error occurs, the return values length, size, type, and name will be unmodified.<br>
*
* @note The double types, GL_DOUBLE, GL_DOUBLE_VEC2, GL_DOUBLE_VEC3, GL_DOUBLE_VEC4, GL_DOUBLE_MAT2, GL_DOUBLE_MAT3, GL_DOUBLE_MAT4,
*       GL_DOUBLE_MAT2x3, GL_DOUBLE_MAT2x4, GL_DOUBLE_MAT3x2, GL_DOUBLE_MAT3x4, GL_DOUBLE_MAT4x2, and GL_DOUBLE_MAT4x3 are
*       only available if the GL version is 4.1 or higher.
* @note The image types, GL_IMAGE_1D, GL_IMAGE_2D, GL_IMAGE_3D, GL_IMAGE_2D_RECT, GL_IMAGE_CUBE, GL_IMAGE_BUFFER, GL_IMAGE_1D_ARRAY,
*       GL_IMAGE_2D_ARRAY, GL_IMAGE_2D_MULTISAMPLE, GL_IMAGE_2D_MULTISAMPLE_ARRAY, GL_INT_IMAGE_1D, GL_INT_IMAGE_2D, GL_INT_IMAGE_3D,
*       GL_INT_IMAGE_2D_RECT, GL_INT_IMAGE_CUBE, GL_INT_IMAGE_BUFFER, GL_INT_IMAGE_1D_ARRAY, GL_INT_IMAGE_2D_ARRAY, GL_INT_IMAGE_2D_MULTISAMPLE,
*       GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY, GL_UNSIGNED_INT_IMAGE_1D, GL_UNSIGNED_INT_IMAGE_2D, GL_UNSIGNED_INT_IMAGE_3D,
*       GL_UNSIGNED_INT_IMAGE_2D_RECT, GL_UNSIGNED_INT_IMAGE_CUBE, GL_UNSIGNED_INT_IMAGE_BUFFER, GL_UNSIGNED_INT_IMAGE_1D_ARRAY,
*       GL_UNSIGNED_INT_IMAGE_2D_ARRAY, GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE, GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY,
*       and the atomic counter type, GL_UNSIGNED_INT_ATOMIC_COUNTER are only available if the GL version is 4.2
*       or higher.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of active uniform variables in program.
* @errors GL_INVALID_VALUE is generated if bufSize is less than 0.
*
*/
#define glGetActiveUniform glad_glGetActiveUniform
GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
/**
* @name glGetActiveUniformBlockName - retrieve the name of an active uniform block
* @usage
* @code void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName); @endcode
* @param program Specifies the name of a program containing the uniform block.
* @param uniformBlockIndex Specifies the index of the uniform block within <em class="parameter"><b>program</b></em>.
* @param bufSize Specifies the size of the buffer addressed by <em class="parameter"><b>uniformBlockName</b></em>.
* @param length Specifies the address of a variable to receive the number of characters that were written to <em class="parameter"><b>uniformBlockName</b></em>.
* @param uniformBlockName Specifies the address an array of characters to receive the name of the uniform block at <em class="parameter"><b>uniformBlockIndex</b></em>.
* @description
* 	glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex within program.<br>
* 	program must be the name of a program object for which the command glLinkProgram must have been called in the past, although
* it is not required that glLinkProgram must have succeeded. The link could have failed because the number of active
* uniforms exceeded the limit.<br>
* 	uniformBlockIndex is an active uniform block index of program, and must be less than the value of GL_ACTIVE_UNIFORM_BLOCKS.<br>
* 	Upon success, the name of the uniform block identified by unifomBlockIndex is returned into uniformBlockName. The name
* is nul-terminated. The actual number of characters written into uniformBlockName, excluding the nul terminator, is returned
* in length. If length is NULL, no length is returned.<br>
* 	bufSize contains the maximum number of characters (including the nul terminator) that will be written into uniformBlockName.<br>
* 	If an error occurs, nothing will be written to uniformBlockName or length.<br>
*
* @note glGetActiveUniformBlockName is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called
*         in the past.
* @errors GL_INVALID_VALUE is generated if uniformBlockIndex is greater than or equal to the value of GL_ACTIVE_UNIFORM_BLOCKS or
*         is not the index of an active uniform block in program.
*
*/
#define glGetActiveUniformBlockName glad_glGetActiveUniformBlockName
GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
// Unable to find the docs for this function!
#define glGetActiveUniformBlockiv glad_glGetActiveUniformBlockiv
GLAD_API_CALL PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
/**
* @name glGetActiveUniformName - query the name of an active uniform
* @usage
* @code void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName); @endcode
* @param program Specifies the program containing the active uniform index <em class="parameter"><b>uniformIndex</b></em>.
* @param uniformIndex Specifies the index of the active uniform whose name to query.
* @param bufSize Specifies the size of the buffer, in units of <b>GLchar</b>, of the buffer whose address is specified in <em class="parameter"><b>uniformName</b></em>.
* @param length Specifies the address of a variable that will receive the number of characters that were or would have been written to the
*               buffer addressed by <em class="parameter"><b>uniformName</b></em>.
* @param uniformName Specifies the address of a buffer into which the GL will place the name of the active uniform at <em class="parameter"><b>uniformIndex</b></em>
*                    within <em class="parameter"><b>program</b></em>.
* @description
* 	glGetActiveUniformName returns the name of the active uniform at uniformIndex within program. If uniformName is not NULL,
* up to bufSize characters (including a nul-terminator) will be written into the array whose address is specified by uniformName.
* If length is not NULL, the number of characters that were (or would have been) written into uniformName (not
* including the nul-terminator) will be placed in the variable whose address is specified in length. If length is NULL, no
* length is returned. The length of the longest uniform name in program is given by the value of GL_ACTIVE_UNIFORM_MAX_LENGTH,
* which can be queried with glGetProgram.<br>
* 	If glGetActiveUniformName is not successful, nothing is written to length or uniformName.<br>
* 	program must be the name of a program for which the command glLinkProgram has been issued in the past. It is not necessary
* for program to have been linked successfully. The link could have failed because the number of active uniforms exceeded
* the limit.<br>
* 	uniformIndex must be an active uniform index of the program program, in the range zero to the value of GL_ACTIVE_UNIFORMS
* minus one. The value of GL_ACTIVE_UNIFORMS can be queried with glGetProgram.<br>
*
*
* @errors GL_INVALID_VALUE is generated if uniformIndex is greater than or equal to the value of GL_ACTIVE_UNIFORMS.
* @errors GL_INVALID_VALUE is generated if bufSize is negative.
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been issued.
*
*/
#define glGetActiveUniformName glad_glGetActiveUniformName
GLAD_API_CALL PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
/**
* @name glGetActiveUniformsiv - Returns information about several active uniform variables for the specified program object
* @usage
* @code void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params); @endcode
* @param program Specifies the program object to be queried.
* @param uniformCount Specifies both the number of elements in the array of indices <em class="parameter"><b>uniformIndices</b></em> and the number
*                     of parameters written to <em class="parameter"><b>params</b></em> upon successful return.
* @param uniformIndices Specifies the address of an array of <em class="parameter"><b>uniformCount</b></em> integers containing the indices of uniforms
*                       within <em class="parameter"><b>program</b></em> whose parameter <em class="parameter"><b>pname</b></em> should
*                       be queried.
* @param pname Specifies the property of each uniform in <em class="parameter"><b>uniformIndices</b></em> that should be written into the
*              corresponding element of <em class="parameter"><b>params</b></em>.
* @param params Specifies the address of an array of <em class="parameter"><b>uniformCount</b></em> integers which are to receive the value
*               of <em class="parameter"><b>pname</b></em> for each uniform in <em class="parameter"><b>uniformIndices</b></em>.
* @description
* 	glGetActiveUniformsiv queries the value of the parameter named pname for each of the uniforms within program whose indices
* are specified in the array of uniformCount unsigned integers uniformIndices. Upon success, the value of the parameter
* for each uniform is written into the corresponding entry in the array whose address is given in params. If an error is
* generated, nothing is written into params.<br>
* 	If pname is GL_UNIFORM_TYPE, then an array identifying the types of uniforms specified by the corresponding array of uniformIndices
* is returned. The returned types can be any of the values from the following table:<br>
* 	If pname is GL_UNIFORM_SIZE, then an array identifying the size of the uniforms specified by the corresponding array of
* uniformIndices is returned. The sizes returned are in units of the type returned by a query of GL_UNIFORM_TYPE. For active
* uniforms that are arrays, the size is the number of active elements in the array; for all other uniforms, the size is
* one.<br>
* 	If pname is GL_UNIFORM_NAME_LENGTH, then an array identifying the length, including the terminating null character, of
* the uniform name strings specified by the corresponding array of uniformIndices is returned.<br>
* 	If pname is GL_UNIFORM_BLOCK_INDEX, then an array identifying the uniform block index of each of the uniforms specified
* by the corresponding array of uniformIndices is returned. The uniform block index of a uniform associated with the default
* uniform block is -1.<br>
* 	If pname is GL_UNIFORM_OFFSET, then an array of uniform buffer offsets is returned. For uniforms in a named uniform block,
* the returned value will be its offset, in basic machine units, relative to the beginning of the uniform block in the
* buffer object data store. For atomic counter uniforms, the returned value will be its offset relative to the beginning
* of its active atomic counter buffer. For all other uniforms, -1 will be returned.<br>
* 	If pname is GL_UNIFORM_ARRAY_STRIDE, then an array identifying the stride between elements of each of the uniforms specified
* by the corresponding array of uniformIndices is returned. For uniforms in named uniform blocks and for uniforms declared
* as atomic counters, the stride is the difference, in basic machine units, of consecutive elements in an array, or
* zero for uniforms not declared as an array. For all other uniforms, a stride of -1 will be returned.<br>
* 	If pname is GL_UNIFORM_MATRIX_STRIDE, then an array identifying the stride between columns of a column-major matrix or
* rows of a row-major matrix, in basic machine units, of each of the uniforms specified by the corresponding array of uniformIndices
* is returned. The matrix stride of a uniform associated with the default uniform block is -1. Note that this information
* only makes sense for uniforms that are matrices. For uniforms that are not matrices, but are declared in a named
* uniform block, a matrix stride of zero is returned.<br>
* 	If pname is GL_UNIFORM_IS_ROW_MAJOR, then an array identifying whether each of the uniforms specified by the corresponding
* array of uniformIndices is a row-major matrix or not is returned. A value of one indicates a row-major matrix, and a
* value of zero indicates a column-major matrix, a matrix in the default uniform block, or a non-matrix.<br>
* 	If pname is GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX, then an array identifying the active atomic counter buffer index of
* each of the uniforms specified by the corresponding array of uniformIndices is returned. For uniforms other than atomic
* counters, the returned buffer index is -1. The returned indices may be passed to glGetActiveAtomicCounterBufferiv to query
* the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.<br>
*
* @note The double types, GL_DOUBLE, GL_DOUBLE_VEC2, GL_DOUBLE_VEC3, GL_DOUBLE_VEC4, GL_DOUBLE_MAT2, GL_DOUBLE_MAT3, GL_DOUBLE_MAT4,
*       GL_DOUBLE_MAT2x3, GL_DOUBLE_MAT2x4, GL_DOUBLE_MAT3x2, GL_DOUBLE_MAT3x4, GL_DOUBLE_MAT4x2, and GL_DOUBLE_MAT4x3 are
*       only available if the GL version is 4.1 or higher.
* @note GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX is only accepted by pname if the GL version is 4.2 or higher.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if uniformCount is greater than or equal to the value of GL_ACTIVE_UNIFORMS for program.
* @errors GL_INVALID_ENUM is generated if pname is not an accepted token.
*
*/
#define glGetActiveUniformsiv glad_glGetActiveUniformsiv
GLAD_API_CALL PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
/**
* @name glGetAttachedShaders - Returns the handles of the shader objects attached to a program object
* @usage
* @code void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders); @endcode
* @param program Specifies the program object to be queried.
* @param maxCount Specifies the size of the array for storing the returned object names.
* @param count Returns the number of names actually returned in <em class="parameter"><b>shaders</b></em>.
* @param shaders Specifies an array that is used to return the names of attached shader objects.
* @description
* 	glGetAttachedShaders returns the names of the shader objects attached to program. The names of shader objects that are
* attached to program will be returned in shaders. The actual number of shader names written into shaders is returned in count.
* If no shader objects are attached to program, count is set to 0. The maximum number of shader names that may be returned
* in shaders is specified by maxCount.<br>
* 	If the number of names actually returned is not required (for instance, if it has just been obtained by calling glGetProgram),
* a value of NULL may be passed for count. If no shader objects are attached to program, a value of 0 will be returned
* in count. The actual number of attached shaders can be obtained by calling glGetProgram with the value GL_ATTACHED_SHADERS.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if maxCount is less than 0.
*
*/
#define glGetAttachedShaders glad_glGetAttachedShaders
GLAD_API_CALL PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
/**
* @name glGetAttribLocation - Returns the location of an attribute variable
* @usage
* @code GLint glGetAttribLocation(GLuint program, const GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param name Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
* @description
* 	glGetAttribLocation queries the previously linked program object specified by program for the attribute variable specified
* by name and returns the index of the generic vertex attribute that is bound to that attribute variable. If name is a
* matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is
* not an active attribute in the specified program object or if name starts with the reserved prefix "gl_", a value of -1
* is returned.<br>
* 	The association between an attribute variable name and a generic attribute index can be specified at any time by calling
* glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program object has
* been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The
* attribute values can only be queried after a link if the link was successful. glGetAttribLocation returns the binding
* that actually went into effect the last time glLinkProgram was called for the specified program object. Attribute bindings
* that have been specified since the last link operation are not returned by glGetAttribLocation.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program has not been successfully linked.
*
*/
#define glGetAttribLocation glad_glGetAttribLocation
GLAD_API_CALL PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
// Unable to find the docs for this function!
#define glGetBooleani_v glad_glGetBooleani_v
GLAD_API_CALL PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
// Unable to find the docs for this function!
#define glGetBooleanv glad_glGetBooleanv
GLAD_API_CALL PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
// Unable to find the docs for this function!
#define glGetBufferParameteri64v glad_glGetBufferParameteri64v
GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
// Unable to find the docs for this function!
#define glGetBufferParameteriv glad_glGetBufferParameteriv
GLAD_API_CALL PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
/**
* @name glGetBufferPointerv, glGetNamedBufferPointerv - return the pointer to a mapped buffer object's data store
* @usage
* @code void glGetBufferPointerv(GLenum target, GLenum pname, void ** params); @endcode
* @code void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferPointerv</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferPointerv</b>.
* @param pname Specifies the name of the pointer to be returned. Must be <b>GL_BUFFER_MAP_POINTER</b>.
* @param params Returns the pointer value specified by <em class="parameter"><b>pname</b></em>.
* @description
* 	glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be GL_BUFFER_MAP_POINTER.
* The single buffer map pointer is returned in params. A NULL pointer is returned if the buffer object's data store is not
* currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable
* to support mappings on multiple clients.<br>
*
* @note If an error is generated, no change is made to the contents of params.
* @note The initial value for the pointer is NULL.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated if by glGetBufferPointerv if target is not one of the accepted buffer targets, or if pname
*         is not GL_BUFFER_MAP_POINTER.
* @errors GL_INVALID_OPERATION is generated by glGetBufferPointerv if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferPointerv if buffer is not the name of an existing buffer object.
*
*/
#define glGetBufferPointerv glad_glGetBufferPointerv
GLAD_API_CALL PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
/**
* @name glGetBufferSubData, glGetNamedBufferSubData - returns a subset of a buffer object's data store
* @usage
* @code void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data); @endcode
* @code void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
* @param size Specifies the size in bytes of the data store region being returned.
* @param data Specifies a pointer to the location where buffer object data is returned.
* @description
* 	glGetBufferSubData and glGetNamedBufferSubData return some or all of the data contents of the data store of the specified
* buffer object. Data starting at byte offset offset and extending for size bytes is copied from the buffer object's data
* store to the memory pointed to by data. An error is thrown if the buffer object is currently mapped, or if offset and
* size together define a range beyond the bounds of the buffer object's data store.<br>
*
* @note If an error is generated, no change is made to the contents of data.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_OPERATION is generated by glGetBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is mapped with glMapBufferRange or glMapBuffer, unless it was mapped
*         with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glGetBufferSubData glad_glGetBufferSubData
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
/**
* @name glGetCompressedTexImage - return a compressed texture image
* @usage
* @code void glGetCompressedTexImage(GLenum target, GLint level, void * pixels); @endcode
* @code void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels); @endcode
* @code void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetCompressedTexImage</b> and <b>glGetnCompressedTexImage</b>
*               functions. <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, <b>GL_TEXTURE_RECTANGLE</b> are accepted.
* @param texture Specifies the texture object name for <b>glGetCompressedTextureImage</b> function.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap
*              reduction image.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetCompressedTextureImage</b> and <b>glGetnCompressedTexImage</b>
*                functions.
* @param pixels Returns the compressed texture image.
* @description
* 	glGetCompressedTexImage and glGetnCompressedTexImage return the compressed texture image associated with target and lod
* into pixels. glGetCompressedTextureImage serves the same purpose, but instead of taking a texture target, it takes the
* ID of the texture object. pixels should be an array of bufSize bytes for glGetnCompresedTexImage and glGetCompressedTextureImage
* functions, and of GL_TEXTURE_COMPRESSED_IMAGE_SIZE bytes in case of glGetCompressedTexImage. If the actual data
* takes less space than bufSize, the remaining bytes will not be touched. target specifies the texture target, to which the
* texture the data the function should extract the data from is bound to. lod specifies the level-of-detail number of the
* desired image.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a texture image
* is requested, pixels is treated as a byte offset into the buffer object's data store.<br>
* 	To minimize errors, first verify that the texture is compressed by calling glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED.
* If the texture is compressed, you can determine the amount of memory required to store the compressed texture
* by calling glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED_IMAGE_SIZE. Finally, retrieve the internal format
* of the texture by calling glGetTexLevelParameter with argument GL_TEXTURE_INTERNAL_FORMAT. To store the texture for
* later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective
* texture or subtexture loading routine used for loading target textures.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glGetCompressedTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than zero or greater than the maximum number of LODs permitted by the implementation.
* @errors GL_INVALID_OPERATION is generated if glGetCompressedTexImage, glGetnCompressedTexImage, and glGetCompressedTextureImage
*         is used to retrieve a texture that is in an uncompressed internal format.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target, the buffer
*         storage was not initialized with glBufferStorage using GL_MAP_PERSISTENT_BIT flag, and the buffer object's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
*
*/
#define glGetCompressedTexImage glad_glGetCompressedTexImage
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;
/**
* @name glGetCompressedTexImage - return a compressed texture image
* @usage
* @code void glGetCompressedTexImage(GLenum target, GLint level, void * pixels); @endcode
* @code void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels); @endcode
* @code void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetCompressedTexImage</b> and <b>glGetnCompressedTexImage</b>
*               functions. <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, <b>GL_TEXTURE_RECTANGLE</b> are accepted.
* @param texture Specifies the texture object name for <b>glGetCompressedTextureImage</b> function.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap
*              reduction image.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetCompressedTextureImage</b> and <b>glGetnCompressedTexImage</b>
*                functions.
* @param pixels Returns the compressed texture image.
* @description
* 	glGetCompressedTexImage and glGetnCompressedTexImage return the compressed texture image associated with target and lod
* into pixels. glGetCompressedTextureImage serves the same purpose, but instead of taking a texture target, it takes the
* ID of the texture object. pixels should be an array of bufSize bytes for glGetnCompresedTexImage and glGetCompressedTextureImage
* functions, and of GL_TEXTURE_COMPRESSED_IMAGE_SIZE bytes in case of glGetCompressedTexImage. If the actual data
* takes less space than bufSize, the remaining bytes will not be touched. target specifies the texture target, to which the
* texture the data the function should extract the data from is bound to. lod specifies the level-of-detail number of the
* desired image.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a texture image
* is requested, pixels is treated as a byte offset into the buffer object's data store.<br>
* 	To minimize errors, first verify that the texture is compressed by calling glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED.
* If the texture is compressed, you can determine the amount of memory required to store the compressed texture
* by calling glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED_IMAGE_SIZE. Finally, retrieve the internal format
* of the texture by calling glGetTexLevelParameter with argument GL_TEXTURE_INTERNAL_FORMAT. To store the texture for
* later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective
* texture or subtexture loading routine used for loading target textures.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glGetCompressedTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than zero or greater than the maximum number of LODs permitted by the implementation.
* @errors GL_INVALID_OPERATION is generated if glGetCompressedTexImage, glGetnCompressedTexImage, and glGetCompressedTextureImage
*         is used to retrieve a texture that is in an uncompressed internal format.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target, the buffer
*         storage was not initialized with glBufferStorage using GL_MAP_PERSISTENT_BIT flag, and the buffer object's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
*
*/
#define glGetCompressedTextureImage glad_glGetCompressedTextureImage
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;
/**
* @name glGetCompressedTextureSubImage - retrieve a sub-region of a compressed texture image from a
compressed texture object
* @usage
* @code void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels); @endcode
* @param texture Specifies the name of the source texture object. Must be <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>,
*                <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>
*                or <b>GL_TEXTURE_RECTANGLE</b>. In specific, buffer and multisample textures are not permitted.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the <em class="parameter"><b>offset</b></em>
*              is zero and the size equals the texture image size.
* @param height Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the <em class="parameter"><b>offset</b></em>
*               is zero and the size equals the texture image size.
* @param depth Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the <em class="parameter"><b>offset</b></em>
*              is zero and the size equals the texture image size.
* @param bufSize Specifies the size of the buffer to receive the retrieved pixel data.
* @param pixels Returns the texture subimage. Should be a pointer to an array of the type specified by type.
* @description
* 	glGetCompressedTextureSubImage can be used to obtain a sub-region of a compressed texture image instead of the whole image,
* as long as the compressed data are arranged into fixed-size blocks of texels. texture is the name of the texture object,
* and must not be a buffer or multisample texture. The effective target is the value of GL_TEXTURE_TARGET for texture.
* level and pixels have the same meaning as the corresponding arguments of glCompressedTexSubImage3D. bufSize indicates
* the size of the buffer to receive the retrieved pixel data.<br>
* 	For cube map textures, the behavior is as though glGetCompressedTexImage were called once for each requested face (selected
* by zoffset and depth, as described below) with target corresponding to the requested texture cube map face as indicated
* by the table presented below. pixels is offset appropriately for each successive image.<br>
* 	xoffset, yoffset and zoffset indicate the position of the subregion to return. width, height and depth indicate the size
* of the region to return. These arguments have the same meaning as for glCompressedTexSubImage3D, though there are extra
* restrictions, described in the errors section below.<br>
* 	The mapping between the xoffset, yoffset, zoffset, width, height and depth parameters and the faces, layers, and layer-faces
* for cube map, array, and cube map array textures is the same as for glGetTextureSubImage.<br>
* 	The xoffset, yoffset, zoffset offsets and width, height and depth sizes must be multiples of the values of GL_PACK_COMPRESSED_BLOCK_WIDTH,
* GL_PACK_COMPRESSED_BLOCK_HEIGHT, and GL_PACK_COMPRESSED_BLOCK_DEPTH respectively, unless offset is zero
* and the corresponding size is the same as the texture size in that dimension.<br>
* 	Pixel storage modes are treated as for glGetCompressedTexSubImage. The texel at (xoffset, yoffset, zoffset) will be stored
* at the location indicated by pixels and the current pixel packing parameters.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated if texture is the name of a buffer or multisample texture.
* @errors GL_INVALID_OPERATION error is generated if the buffer size required to store the requested data is greater than bufSize.
* @errors GL_INVALID_OPERATION error is generated if the texture compression format is not based on fixed-size blocks.
* @errors GL_INVALID_VALUE error is generated if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset are negative.
* @errors GL_INVALID_VALUE is generated if xoffset + width is greater than the texture's width, yoffset + height is greater than the
*         texture's height, or zoffset + depth is greater than the texture's depth.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D and either yoffset is not zero, or height is
*         not one.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE
*         and either zoffset is not zero, or depth is not one.
* @errors GL_INVALID_VALUE error is generated if xoffset, yoffset or zoffset is not a multiple of the compressed block width, height
*         or depth respectively.
* @errors GL_INVALID_VALUE error is generated if width, height or depth is not a multiple of the compressed block width, height or
*         depth respectively, unless the offset is zero and the size equals the texture image size.
*
*/
#define glGetCompressedTextureSubImage glad_glGetCompressedTextureSubImage
GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;
/**
* @name glGetDebugMessageLog - retrieve messages from the debug message log
* @usage
* @code GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog); @endcode
* @param count The number of debug messages to retrieve from the log.
* @param bufSize The size of the buffer whose address is given by <em class="parameter"><b>messageLog</b></em>.
* @param sources The address of an array of variables to receive the sources of the retrieved messages.
* @param types The address of an array of variables to receive the types of the retrieved messages.
* @param ids The address of an array of unsigned integers to receive the ids of the retrieved messages.
* @param severities The address of an array of variables to receive the severites of the retrieved messages.
* @param lengths The address of an array of variables to receive the lengths of the received messages.
* @param messageLog The address of an array of characters that will receive the messages.
* @description
* 	glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are retrieved from the
* log. If sources is not NULL then the source of each message is written into up to count elements of the array. If types
* is not NULL then the type of each message is written into up to count elements of the array. If id is not NULL then the
* identifier of each message is written into up to count elements of the array. If severities is not NULL then the severity
* of each message is written into up to count elements of the array. If lengths is not NULL then the length of each message
* is written into up to count elements of the array.<br>
* 	messageLog specifies the address of a character array into which the debug messages will be written. Each message will
* be concatenated onto the array starting at the first element of messageLog. bufSize specifies the size of the array messageLog.
* If a message will not fit into the remaining space in messageLog then the function terminates and returns the number
* of messages written so far, which may be zero.<br>
* 	If glGetDebugMessageLog returns zero then no messages are present in the debug log, or there was not enough space in messageLog
* to retrieve the first message in the queue. If messageLog is NULL then no messages are written and the value of
* bufSize is ignored.<br>
*
* @note Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially
*       inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug
*       context may produce no messages at all.
*
* @errors GL_INVALID_VALUE is generated if count or bufSize is negative.
*
*/
#define glGetDebugMessageLog glad_glGetDebugMessageLog
GLAD_API_CALL PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;
// Unable to find the docs for this function!
#define glGetDoublei_v glad_glGetDoublei_v
GLAD_API_CALL PFNGLGETDOUBLEVPROC glad_glGetDoublev;
// Unable to find the docs for this function!
#define glGetDoublev glad_glGetDoublev
GLAD_API_CALL PFNGLGETERRORPROC glad_glGetError;
/**
* @name glGetError - return error information
* @usage
* @code GLenum glGetError( void); @endcode
* @description
* 	glGetError returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When
* an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until glGetError
* is called, the error code is returned, and the flag is reset to GL_NO_ERROR. If a call to glGetError returns GL_NO_ERROR,
* there has been no detectable error since the last call to glGetError, or since the GL was initialized.<br>
* 	To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error,
* the value of that flag is returned and that flag is reset to GL_NO_ERROR when glGetError is called. If more than one
* flag has recorded an error, glGetError returns and clears an arbitrary error flag value. Thus, glGetError should always
* be called in a loop, until it returns GL_NO_ERROR, if all error flags are to be reset.<br>
* 	Initially, all error flags are set to GL_NO_ERROR.<br>
* 	The following errors are currently defined:<br>
* 	No error has been recorded. The value of this symbolic constant is guaranteed to be 0.<br>
* 	An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect
* than to set the error flag.<br>
* 	A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error
* flag.<br>
* 	The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect
* than to set the error flag.<br>
* 	The framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error
* flag.<br>
* 	There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error
* flags, after this error is recorded.<br>
* 	An attempt has been made to perform an operation that would cause an internal stack to underflow.<br>
* 	An attempt has been made to perform an operation that would cause an internal stack to overflow.<br>
* 	When an error flag is set, results of a GL operation are undefined only if GL_OUT_OF_MEMORY has occurred. In all other
* cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating
* command returns a value, it returns 0. If glGetError itself generates an error, it returns 0.<br>
*
*
*
*/
#define glGetError glad_glGetError
GLAD_API_CALL PFNGLGETFLOATI_VPROC glad_glGetFloati_v;
// Unable to find the docs for this function!
#define glGetFloati_v glad_glGetFloati_v
GLAD_API_CALL PFNGLGETFLOATVPROC glad_glGetFloatv;
// Unable to find the docs for this function!
#define glGetFloatv glad_glGetFloatv
GLAD_API_CALL PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
/**
* @name glGetFragDataIndex - query the bindings of color indices to user-defined varying out variables
* @usage
* @code GLint glGetFragDataIndex(GLuint program, const char * name); @endcode
* @param program The name of the program containing varying out variable whose binding to query
* @param name The name of the user-defined varying out variable whose index to query
* @description
* 	glGetFragDataIndex returns the index of the fragment color to which the variable name was bound when the program object
* program was last linked. If name is not a varying out variable of program, or if an error occurs, -1 will be returned.<br>
*
* @note glGetFragDataIndex is available only if the GL version is 3.3 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glGetFragDataIndex glad_glGetFragDataIndex
GLAD_API_CALL PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
/**
* @name glGetFragDataLocation - query the bindings of color numbers to user-defined varying out variables
* @usage
* @code GLint glGetFragDataLocation(GLuint program, const char * name); @endcode
* @param program The name of the program containing varying out variable whose binding to query
* @param name The name of the user-defined varying out variable whose binding to query
* @description
* 	glGetFragDataLocation retrieves the assigned color number binding for the user-defined varying out variable name for program
* program. program must have previously been linked. name must be a null-terminated string. If name is not the name
* of an active user-defined varying out fragment shader variable within program, -1 will be returned.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glGetFragDataLocation glad_glGetFragDataLocation
GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;
// Unable to find the docs for this function!
#define glGetFramebufferAttachmentParameteriv glad_glGetFramebufferAttachmentParameteriv
GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;
// Unable to find the docs for this function!
#define glGetFramebufferParameteriv glad_glGetFramebufferParameteriv
GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;
/**
* @name glGetGraphicsResetStatus - check if the rendering context has not been lost due to software or hardware issues
* @usage
* @code GLenum glGetGraphicsResetStatus(void); @endcode
* @description
* 	Certain events can result in a reset of the GL context. Such a reset causes all context state to be lost and requires the
* application to recreate all objects in the affected context.<br>
* 	glGetGraphicsResetStatus can return one of the following constants:<br>
* 	Indicates that the GL context has not been in a reset state since the last call.<br>
* 	Indicates that a reset has been detected that is attributable to the current GL context.<br>
* 	Indicates a reset has been detected that is not attributable to the current GL context.<br>
* 	Indicates a detected graphics reset whose cause is unknown.<br>
* 	If a reset status other than GL_NO_ERROR is returned and subsequent calls return GL_NO_ERROR, the context reset was encountered
* and completed. If a reset status is repeatedly returned, the context may be in the process of resetting.<br>
* 	Reset notification behavior is determined at context creation time, and may be queried by calling GetIntegerv with the
* symbolic constant GL_RESET_NOTIFICATION_STRATEGY.<br>
* 	If the reset notification behavior is GL_NO_RESET_NOTIFICATION, then the implementation will never deliver notification
* of reset events, and glGetGraphicsResetStatus will always return GL_NO_ERROR.<br>
* 	If the behavior is GL_LOSE_CONTEXT_ON_RESET, a graphics reset will result in the loss of all context state, requiring the
* recreation of all associated objects. In this case glGetGraphicsResetStatus may return any of the values described above.<br>
* 	If a graphics reset notification occurs in a context, a notification must also occur in all other contexts which share
* objects with that context.<br>
* 	After a graphics reset has occurred on a context, subsequent GL commands on that context (or any context which shares with
* that context) will generate a GL_CONTEXT_LOST error. Such commands will not have side effects (in particular, they will
* not modify memory passed by pointer for query results), and will not block indefinitely or cause termination of the
* application. There are two important exceptions to this behavior:<br>
* 	glGetError and glGetGraphicsResetStatus behave normally following a graphics reset, so that the application can determine
* a reset has occurred, and when it is safe to destroy and re-create the context.<br>
* 	Any commands which might cause a polling application to block indefinitely will generate a GL_CONTEXT_LOST error, but will
* also return a value indicating completion to the application. Such commands include:<br>
* 	glGetSynciv with pname GL_SYNC_STATUS ignores the other parameters and returns GL_SIGNALED in values.<br>
* 	glGetQueryObjectuiv with pname GL_QUERY_RESULT_AVAILABLE ignores the other parameters and returns TRUE in params.<br>
*
*
*
*/
#define glGetGraphicsResetStatus glad_glGetGraphicsResetStatus
GLAD_API_CALL PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
// Unable to find the docs for this function!
#define glGetInteger64i_v glad_glGetInteger64i_v
GLAD_API_CALL PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
// Unable to find the docs for this function!
#define glGetInteger64v glad_glGetInteger64v
GLAD_API_CALL PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
// Unable to find the docs for this function!
#define glGetIntegeri_v glad_glGetIntegeri_v
GLAD_API_CALL PFNGLGETINTEGERVPROC glad_glGetIntegerv;
// Unable to find the docs for this function!
#define glGetIntegerv glad_glGetIntegerv
GLAD_API_CALL PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;
// Unable to find the docs for this function!
#define glGetInternalformati64v glad_glGetInternalformati64v
GLAD_API_CALL PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;
// Unable to find the docs for this function!
#define glGetInternalformativ glad_glGetInternalformativ
GLAD_API_CALL PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
// Unable to find the docs for this function!
#define glGetMultisamplefv glad_glGetMultisamplefv
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;
// Unable to find the docs for this function!
#define glGetNamedBufferParameteri64v glad_glGetNamedBufferParameteri64v
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;
// Unable to find the docs for this function!
#define glGetNamedBufferParameteriv glad_glGetNamedBufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;
/**
* @name glGetBufferPointerv, glGetNamedBufferPointerv - return the pointer to a mapped buffer object's data store
* @usage
* @code void glGetBufferPointerv(GLenum target, GLenum pname, void ** params); @endcode
* @code void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferPointerv</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferPointerv</b>.
* @param pname Specifies the name of the pointer to be returned. Must be <b>GL_BUFFER_MAP_POINTER</b>.
* @param params Returns the pointer value specified by <em class="parameter"><b>pname</b></em>.
* @description
* 	glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be GL_BUFFER_MAP_POINTER.
* The single buffer map pointer is returned in params. A NULL pointer is returned if the buffer object's data store is not
* currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable
* to support mappings on multiple clients.<br>
*
* @note If an error is generated, no change is made to the contents of params.
* @note The initial value for the pointer is NULL.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated if by glGetBufferPointerv if target is not one of the accepted buffer targets, or if pname
*         is not GL_BUFFER_MAP_POINTER.
* @errors GL_INVALID_OPERATION is generated by glGetBufferPointerv if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferPointerv if buffer is not the name of an existing buffer object.
*
*/
#define glGetNamedBufferPointerv glad_glGetNamedBufferPointerv
GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;
/**
* @name glGetBufferSubData, glGetNamedBufferSubData - returns a subset of a buffer object's data store
* @usage
* @code void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data); @endcode
* @code void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
* @param size Specifies the size in bytes of the data store region being returned.
* @param data Specifies a pointer to the location where buffer object data is returned.
* @description
* 	glGetBufferSubData and glGetNamedBufferSubData return some or all of the data contents of the data store of the specified
* buffer object. Data starting at byte offset offset and extending for size bytes is copied from the buffer object's data
* store to the memory pointed to by data. An error is thrown if the buffer object is currently mapped, or if offset and
* size together define a range beyond the bounds of the buffer object's data store.<br>
*
* @note If an error is generated, no change is made to the contents of data.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_OPERATION is generated by glGetBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is mapped with glMapBufferRange or glMapBuffer, unless it was mapped
*         with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glGetNamedBufferSubData glad_glGetNamedBufferSubData
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;
// Unable to find the docs for this function!
#define glGetNamedFramebufferAttachmentParameteriv glad_glGetNamedFramebufferAttachmentParameteriv
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;
// Unable to find the docs for this function!
#define glGetNamedFramebufferParameteriv glad_glGetNamedFramebufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;
// Unable to find the docs for this function!
#define glGetNamedRenderbufferParameteriv glad_glGetNamedRenderbufferParameteriv
GLAD_API_CALL PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;
/**
* @name glGetObjectLabel - retrieve the label of a named object identified within a namespace
* @usage
* @code void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label); @endcode
* @param identifier The namespace from which the name of the object is allocated.
* @param name The name of the object whose label to retrieve.
* @param bufSize The length of the buffer whose address is in <em class="parameter"><b>label</b></em>.
* @param length The address of a variable to receive the length of the object label.
* @param label The address of a string that will receive the object label.
* @description
* 	glGetObjectLabel retrieves the label of the object identified by name within the namespace given by identifier. identifier
* must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY, GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK,
* GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER, to indicate the namespace containing the names of buffers,
* shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures,
* renderbuffers and frame buffers, respectively.<br>
* 	label is the address of a string that will be used to store the object label. bufSize specifies the number of characters
* in the array identified by label. length contains the address of a variable which will receive the number of characters
* in the object label. If length is NULL, then it is ignored and no data is written. Likewise, if label is NULL, or if bufSize
* is zero then no data is written to label.<br>
*
*
* @errors GL_INVALID_ENUM is generated if identifier is not one of the accepted object types.
* @errors GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier.
* @errors GL_INVALID_VALUE is generated if bufSize is zero.
* @errors If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including
*         process termination may occur.
*
*/
#define glGetObjectLabel glad_glGetObjectLabel
GLAD_API_CALL PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;
/**
* @name glGetObjectPtrLabel - retrieve the label of a sync object identified by a pointer
* @usage
* @code void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label); @endcode
* @param ptr The name of the sync object whose label to retrieve.
* @param bufSize The length of the buffer whose address is in <em class="parameter"><b>label</b></em>.
* @param length The address of a variable to receive the length of the object label.
* @param label The address of a string that will receive the object label.
* @description
* 	glGetObjectPtrLabel retrieves the label of the sync object identified by ptr.<br>
* 	label is the address of a string that will be used to store the object label. bufSize specifies the number of characters
* in the array identified by label. length contains the address of a variable which will receive the number of characters
* in the object label. If length is NULL, then it is ignored and no data is written. Likewise, if label is NULL, or if bufSize
* is zero then no data is written to label.<br>
*
*
* @errors GL_INVALID_ENUM is generated if identifier is not one of the accepted object types.
* @errors GL_INVALID_VALUE is generated if ptr is not the name of an existing sync object.
* @errors GL_INVALID_VALUE is generated if bufSize is zero.
* @errors If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including
*         process termination may occur.
*
*/
#define glGetObjectPtrLabel glad_glGetObjectPtrLabel
GLAD_API_CALL PFNGLGETPOINTERVPROC glad_glGetPointerv;
/**
* @name glGetPointerv - return the address of the specified pointer
* @usage
* @code void glGetPointerv(GLenum pname, void ** params); @endcode
* @param pname Specifies the pointer to be returned. Must be one of <b>GL_DEBUG_CALLBACK_FUNCTION</b> or <b>GL_DEBUG_CALLBACK_USER_PARAM</b>.
* @param params Returns the pointer value specified by <em class="parameter"><b>pname</b></em>.
* @description
* 	glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is a pointer to a location
* in which to place the returned data. The parameters that may be queried include:<br>
* 	Returns the current callback function set with the callback argument of glDebugMessageCallback.<br>
* 	Returns the user parameter to the current callback function set with the userParam argument of glDebugMessageCallback.<br>
*
* @note glGetPointerv is available in the OpenGL core profile only if the GL version is 4.3 or later. It is available in the compatibility
*       profile for all GL versions, and accepts additional queries. However, these reference pages document only the
*       core profile.
*
* @errors GL_INVALID_ENUM is generated if pname is not an accepted value.
*
*/
#define glGetPointerv glad_glGetPointerv
GLAD_API_CALL PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;
/**
* @name glGetProgramBinary - return a binary representation of a program object's compiled and linked executable source
* @usage
* @code void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary); @endcode
* @param program Specifies the name of a program object whose binary representation to retrieve.
* @param bufSize Specifies the size of the buffer whose address is given by <em class="parameter"><b>binary</b></em>.
* @param length Specifies the address of a variable to receive the number of bytes written into <em class="parameter"><b>binary</b></em>.
* @param binaryFormat Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
* @param binary Specifies the address an array into which the GL will return <em class="parameter"><b>program</b></em>'s binary representation.
* @description
* 	glGetProgramBinary returns a binary representation of the compiled and linked executable for program into the array of
* bytes whose address is specified in binary. The maximum number of bytes that may be written into binary is specified by
* bufSize. If the program binary is greater in size than bufSize bytes, then an error is generated, otherwise the actual number
* of bytes written into binary is returned in the variable whose address is given by length. If length is NULL, then
* no length is returned.<br>
* 	The format of the program binary written into binary is returned in the variable whose address is given by binaryFormat,
* and may be implementation dependent. The binary produced by the GL may subsequently be returned to the GL by calling glProgramBinary,
* with binaryFormat and length set to the values returned by glGetProgramBinary, and passing the returned
* binary data in the binary parameter.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if bufSize is less than the size of GL_PROGRAM_BINARY_LENGTH for program.
* @errors GL_INVALID_OPERATION is generated if GL_LINK_STATUS for the program object is false.
*
*/
#define glGetProgramBinary glad_glGetProgramBinary
GLAD_API_CALL PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
/**
* @name glGetProgramInfoLog - Returns the information log for a program object
* @usage
* @code void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog); @endcode
* @param program Specifies the program object whose information log is to be queried.
* @param maxLength Specifies the size of the character buffer for storing the returned information log.
* @param length Returns the length of the string returned in <em class="parameter"><b>infoLog</b></em> (excluding the null terminator).
* @param infoLog Specifies an array of characters that is used to return the information log.
* @description
* 	glGetProgramInfoLog returns the information log for the specified program object. The information log for a program object
* is modified when the program object is linked or validated. The string that is returned will be null terminated.<br>
* 	glGetProgramInfoLog returns in infoLog as much of the information log as it can, up to a maximum of maxLength characters.
* The number of characters actually returned, excluding the null termination character, is specified by length. If the
* length of the returned string is not required, a value of NULL can be passed in the length argument. The size of the buffer
* required to store the returned information log can be obtained by calling glGetProgram with the value GL_INFO_LOG_LENGTH.<br>
* 	The information log for a program object is either an empty string, or a string containing information about the last link
* operation, or a string containing information about the last validation operation. It may contain diagnostic messages,
* warning messages, and other information. When a program object is created, its information log will be a string of length
* 0.<br>
*
* @note The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking
*       and validating. Therefore, the information log can be helpful to application developers during the development process,
*       even when these operations are successful. Application developers should not expect different OpenGL implementations
*       to produce identical information logs.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if maxLength is less than 0.
*
*/
#define glGetProgramInfoLog glad_glGetProgramInfoLog
GLAD_API_CALL PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;
// Unable to find the docs for this function!
#define glGetProgramInterfaceiv glad_glGetProgramInterfaceiv
GLAD_API_CALL PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;
/**
* @name glGetProgramPipelineInfoLog - retrieve the info log string from a program pipeline object
* @usage
* @code void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog); @endcode
* @param pipeline Specifies the name of a program pipeline object from which to retrieve the info log.
* @param bufSize Specifies the maximum number of characters, including the null terminator, that may be written into <em class="parameter"><b>infoLog</b></em>.
* @param length Specifies the address of a variable into which will be written the number of characters written into <em class="parameter"><b>infoLog</b></em>.
* @param infoLog Specifies the address of an array of characters into which will be written the info log for <em class="parameter"><b>pipeline</b></em>.
* @description
* 	glGetProgramPipelineInfoLog retrieves the info log for the program pipeline object pipeline. The info log, including its
* null terminator, is written into the array of characters whose address is given by infoLog. The maximum number of characters
* that may be written into infoLog is given by bufSize, and the actual number of characters written into infoLog is
* returned in the integer whose address is given by length. If length is NULL, no length is returned.<br>
* 	The actual length of the info log for the program pipeline may be determined by calling glGetProgramPipeline with pname
* set to GL_INFO_LOG_LENGTH.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glGetProgramPipelineInfoLog glad_glGetProgramPipelineInfoLog
GLAD_API_CALL PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;
// Unable to find the docs for this function!
#define glGetProgramPipelineiv glad_glGetProgramPipelineiv
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;
/**
* @name glGetProgramResourceIndex - query the index of a named resource within a program
* @usage
* @code GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the resource named <em class="parameter"><b>name</b></em>.
* @param name The name of the resource to query the index of.
* @description
* 	glGetProgramResourceIndex returns the unsigned integer index assigned to a resource named name in the interface type programInterface
* of program object program.<br>
* 	program must be the name of an existing program object. programInterface is the name of the interface within program which
* contains the resource named nameand must be one of the following values:<br>
* 	The query is targeted at the set of active uniforms within program.<br>
* 	The query is targeted at the set of active uniform blocks within program.<br>
* 	The query is targeted at the set of active input variables used by the first shader stage of program. If program contains
* multiple shader stages then input variables from any stage other than the first will not be enumerated.<br>
* 	The query is targeted at the set of active output variables produced by the last shader stage of program. If program contains
* multiple shader stages then output variables from any stage other than the last will not be enumerated.<br>
* 	The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry,
* fragment and compute shader stages of program, respectively.<br>
* 	The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation
* evaluation, geometry, fragment and compute shader stages of program, respectively.<br>
* 	The query is targeted at the set of output variables from the last non-fragment stage of program that would be captured
* if transform feedback were active.<br>
* 	The query is targeted at the set of active buffer binding points to which output variables in the GL_TRANSFORM_FEEDBACK_VARYING
* interface are written.<br>
* 	The query is targeted at the set of active buffer variables used by program.<br>
* 	The query is targeted at the set of active shader storage blocks used by program.<br>
* 	If name exactly matches the name string of one of the active resources for programInterface, the index of the matched resource
* is returned. Additionally, if name would exactly match the name string of an active resource if "[0]" were appended
* to name, the index of the matched resource is returned.  Otherwise, name is considered not to be the name of an active
* resource, and GL_INVALID_INDEX is returned.<br>
* 	For the interface GL_TRANSFORM_FEEDBACK_VARYING, the value GL_INVALID_INDEX should be returned when querying the index
* assigned to the special names gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, or gl_SkipComponents4.<br>
*
*
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active
*         atomic counter and transform feedback buffer resources are not assigned name strings.
* @errors Although not an error, GL_INVALID_INDEX is returned if name is not the name of a resource within the interface identified
*         by programInterface.
*
*/
#define glGetProgramResourceIndex glad_glGetProgramResourceIndex
GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;
/**
* @name glGetProgramResourceLocation - query the location of a named resource within a program
* @usage
* @code GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the resource named <em class="parameter"><b>name</b></em>.
* @param name The name of the resource to query the location of.
* @description
* 	glGetProgramResourceLocation returns the location assigned to the variable named name in interface programInterface of
* program object program.  program must be the name of a program that has been linked successfully. programInterface must
* be one of GL_UNIFORM, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM,
* GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM, GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM,
* or GL_TRANSFORM_FEEDBACK_BUFFER.<br>
* 	The value -1 will be returned if an error occurs, if name does not identify an active variable on programInterface, or
* if name identifies an active variable that does not have a valid location assigned, as described above.  The locations returned
* by these commands are the same locations returned when querying the GL_LOCATION and GL_LOCATION_INDEX resource properties.<br>
* 	A string provided to glGetProgramResourceLocation is considered to match an active variable if:<br>
* 	the string exactly matches the name of the active variable<br>
* 	if the string identifies the base name of an active array, where the string would exactly match the name of the variable
* if the suffix "[0]" were appended to the string<br>
* 	if the string identifies an active element of the array, where the string ends with the concatenation of the "[" character,
* an integer with no "+" sign, extra leading zeroes, or whitespace identifying an array element, and the "]" character,
* the integer is less than the number of active elements of the array variable, and where the string would exactly match
* the enumerated name of the array if the decimal integer were replaced with zero.<br>
* 	Any other string is considered not to identify an active variable.  If the string specifies an element of an array variable,
* glGetProgramResourceLocation returns the location assigned to that element.  If it specifies the base name of an array,
* it identifies the resources associated with the first element of the array.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_OPERATION is generated if program has not been linked successfully.
*
*/
#define glGetProgramResourceLocation glad_glGetProgramResourceLocation
GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;
/**
* @name glGetProgramResourceLocationIndex - query the fragment color index of a named variable within a program
* @usage
* @code GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the resource named <em class="parameter"><b>name</b></em>.
* @param name The name of the resource to query the location of.
* @description
* 	glGetProgramResourceLocationIndex returns the fragment color index assigned to the variable named name in interface programInterface
* of program object program.  program must be the name of a program that has been linked successfully. programInterface
* must be GL_PROGRAM_OUTPUT.<br>
* 	The value -1 will be returned if an error occurs, if name does not identify an active variable on programInterface, or
* if name identifies an active variable that does not have a valid location assigned, as described above.  The locations returned
* by these commands are the same locations returned when querying the GL_LOCATION and GL_LOCATION_INDEX resource properties.<br>
* 	A string provided to glGetProgramResourceLocationIndex is considered to match an active variable if:<br>
* 	the string exactly matches the name of the active variable<br>
* 	if the string identifies the base name of an active array, where the string would exactly match the name of the variable
* if the suffix "[0]" were appended to the string<br>
* 	if the string identifies an active element of the array, where the string ends with the concatenation of the "[" character,
* an integer with no "+" sign, extra leading zeroes, or whitespace identifying an array element, and the "]" character,
* the integer is less than the number of active elements of the array variable, and where the string would exactly match
* the enumerated name of the array if the decimal integer were replaced with zero.<br>
* 	Any other string is considered not to identify an active variable.  If the string specifies an element of an array variable,
* glGetProgramResourceLocation returns the location assigned to that element.  If it specifies the base name of an array,
* it identifies the resources associated with the first element of the array.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_OPERATION is generated if program has not been linked successfully.
*
*/
#define glGetProgramResourceLocationIndex glad_glGetProgramResourceLocationIndex
GLAD_API_CALL PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;
/**
* @name glGetProgramResourceName - query the name of an indexed resource within a program
* @usage
* @code void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the indexed resource.
* @param index The index of the resource within <em class="parameter"><b>programInterface</b></em> of <em class="parameter"><b>program</b></em>.
* @param bufSize The size of the character array whose address is given by <em class="parameter"><b>name</b></em>.
* @param length The address of a variable which will receive the length of the resource name.
* @param name The address of a character array into which will be written the name of the resource.
* @description
* 	glGetProgramResourceName retrieves the name string assigned to the single active resource with an index of index in the
* interface programInterface of program object program. index must be less than the number of entries in the active resource
* list for programInterface.<br>
* 	program must be the name of an existing program object. programInterface is the name of the interface within program which
* contains the resource and must be one of the following values:<br>
* 	The query is targeted at the set of active uniforms within program.<br>
* 	The query is targeted at the set of active uniform blocks within program.<br>
* 	The query is targeted at the set of active input variables used by the first shader stage of program. If program contains
* multiple shader stages then input variables from any stage other than the first will not be enumerated.<br>
* 	The query is targeted at the set of active output variables produced by the last shader stage of program. If program contains
* multiple shader stages then output variables from any stage other than the last will not be enumerated.<br>
* 	The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry,
* fragment and compute shader stages of program, respectively.<br>
* 	The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation
* evaluation, geometry, fragment and compute shader stages of program, respectively.<br>
* 	The query is targeted at the set of output variables from the last non-fragment stage of program that would be captured
* if transform feedback were active.<br>
* 	The query is targeted at the set of active buffer variables used by program.<br>
* 	The query is targeted at the set of active shader storage blocks used by program.<br>
* 	The name string assigned to the active resource identified by index is returned as a null-terminated string in the character
* array whose address is given in name.  The actual number of characters written into name, excluding the null terminator,
* is returned in length.  If length is NULL, no length is returned.  The maximum number of characters that may be written
* into name, including the null terminator, is specified by bufSize.  If the length of the name string including the
* null terminator is greater than bufSize, the first bufSize-1 characters of the name string will be written to name, followed
* by a null terminator.  If bufSize is zero, no error will be generated but no characters will be written to name.
*  The length of the longest name string for programInterface>, including a null terminator, can be queried by calling glGetProgramInterface
* with a pname of GL_MAX_NAME_LENGTH.<br>
*
*
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_VALUE is generated if progam is not the name of an existing program.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of entries in the active resource list for
*         programInterface.
* @errors GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active
*         atomic counter and transform feedback buffer resources are not assigned name strings.
*
*/
#define glGetProgramResourceName glad_glGetProgramResourceName
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;
// Unable to find the docs for this function!
#define glGetProgramResourceiv glad_glGetProgramResourceiv
GLAD_API_CALL PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;
// Unable to find the docs for this function!
#define glGetProgramStageiv glad_glGetProgramStageiv
GLAD_API_CALL PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
// Unable to find the docs for this function!
#define glGetProgramiv glad_glGetProgramiv
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;
// Unable to find the docs for this function!
#define glGetQueryBufferObjecti64v glad_glGetQueryBufferObjecti64v
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;
// Unable to find the docs for this function!
#define glGetQueryBufferObjectiv glad_glGetQueryBufferObjectiv
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;
// Unable to find the docs for this function!
#define glGetQueryBufferObjectui64v glad_glGetQueryBufferObjectui64v
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;
// Unable to find the docs for this function!
#define glGetQueryBufferObjectuiv glad_glGetQueryBufferObjectuiv
GLAD_API_CALL PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;
// Unable to find the docs for this function!
#define glGetQueryIndexediv glad_glGetQueryIndexediv
GLAD_API_CALL PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
// Unable to find the docs for this function!
#define glGetQueryObjecti64v glad_glGetQueryObjecti64v
GLAD_API_CALL PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
// Unable to find the docs for this function!
#define glGetQueryObjectiv glad_glGetQueryObjectiv
GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
// Unable to find the docs for this function!
#define glGetQueryObjectui64v glad_glGetQueryObjectui64v
GLAD_API_CALL PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
// Unable to find the docs for this function!
#define glGetQueryObjectuiv glad_glGetQueryObjectuiv
GLAD_API_CALL PFNGLGETQUERYIVPROC glad_glGetQueryiv;
/**
* @name glGetQueryiv - return parameters of a query object target
* @usage
* @code void glGetQueryiv(GLenum target, GLenum pname, GLint * params); @endcode
* @param target Specifies a query object target. Must be <b>GL_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</b>
<b>GL_PRIMITIVES_GENERATED</b>,
*               <b>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</b>, <b>GL_TIME_ELAPSED</b>,
*               or <b>GL_TIMESTAMP</b>.
* @param pname Specifies the symbolic name of a query object target parameter. Accepted values are <b>GL_CURRENT_QUERY</b> or <b>GL_QUERY_COUNTER_BITS</b>.
* @param params Returns the requested data.
* @description
* 	glGetQueryiv returns in params a selected parameter of the query object target specified by target.<br>
* 	pname names a specific query object target parameter.  When pname is GL_CURRENT_QUERY, the name of the currently active
* query for target, or zero if no query is active, will be placed in params. If pname is GL_QUERY_COUNTER_BITS, the implementation-dependent
* number of bits used to hold the result of queries for target is returned in params.<br>
*
* @note The target GL_ANY_SAMPLES_PASSED_CONSERVATIVE is available only if the GL version is 4.3 or greater.
* @note If an error is generated, no change is made to the contents of params.
*
* @errors GL_INVALID_ENUM is generated if target or pname is not an accepted value.
*
*/
#define glGetQueryiv glad_glGetQueryiv
GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
// Unable to find the docs for this function!
#define glGetRenderbufferParameteriv glad_glGetRenderbufferParameteriv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
// Unable to find the docs for this function!
#define glGetSamplerParameterIiv glad_glGetSamplerParameterIiv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
// Unable to find the docs for this function!
#define glGetSamplerParameterIuiv glad_glGetSamplerParameterIuiv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
// Unable to find the docs for this function!
#define glGetSamplerParameterfv glad_glGetSamplerParameterfv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
// Unable to find the docs for this function!
#define glGetSamplerParameteriv glad_glGetSamplerParameteriv
GLAD_API_CALL PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
/**
* @name glGetShaderInfoLog - Returns the information log for a shader object
* @usage
* @code void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog); @endcode
* @param shader Specifies the shader object whose information log is to be queried.
* @param maxLength Specifies the size of the character buffer for storing the returned information log.
* @param length Returns the length of the string returned in <em class="parameter"><b>infoLog</b></em> (excluding the null terminator).
* @param infoLog Specifies an array of characters that is used to return the information log.
* @description
* 	glGetShaderInfoLog returns the information log for the specified shader object. The information log for a shader object
* is modified when the shader is compiled. The string that is returned will be null terminated.<br>
* 	glGetShaderInfoLog returns in infoLog as much of the information log as it can, up to a maximum of maxLength characters.
* The number of characters actually returned, excluding the null termination character, is specified by length. If the length
* of the returned string is not required, a value of NULL can be passed in the length argument. The size of the buffer
* required to store the returned information log can be obtained by calling glGetShader with the value GL_INFO_LOG_LENGTH.<br>
* 	The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information
* about the last compile operation. When a shader object is created, its information log will be a string of length
* 0.<br>
*
* @note The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the
*       compilation process. Therefore, the information log can be helpful to application developers during the development process,
*       even when compilation is successful. Application developers should not expect different OpenGL implementations to
*       produce identical information logs.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_VALUE is generated if maxLength is less than 0.
*
*/
#define glGetShaderInfoLog glad_glGetShaderInfoLog
GLAD_API_CALL PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;
/**
* @name glGetShaderPrecisionFormat - retrieve the range and precision for numeric formats supported by the shader compiler
* @usage
* @code void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision); @endcode
* @param shaderType Specifies the type of shader whose precision to query. <em class="parameter"><b>shaderType</b></em> must be <b>GL_VERTEX_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param precisionType Specifies the numeric format whose precision and range to query.
* @param range Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
* @param precision Specifies the address of an integer into which the numeric precision of the implementation is written.
* @description
* 	glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's representation of quantities
* in different numeric formats in specified shader type. shaderType specifies the type of shader for which the numeric
* precision and range is to be retrieved and must be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies
* the numeric format to query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOATGL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT,
* or GL_HIGH_INT.<br>
* 	range points to an array of two integers into which the format's numeric range will be returned. If min and max are the
* smallest values representable in the format, then the values returned are defined to be: range[0] = floor(log2(|min|))
* and range[1] = floor(log2(|max|)).<br>
* 	precision specifies the address of an integer into which will be written the log2 value of the number of bits of precision
* of the format. If the smallest representable value greater than 1 is 1 + eps, then the integer addressed by precision
* will contain floor(-log2(eps)).<br>
*
*
* @errors GL_INVALID_ENUM is generated if shaderType or precisionType is not an accepted value.
*
*/
#define glGetShaderPrecisionFormat glad_glGetShaderPrecisionFormat
GLAD_API_CALL PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
/**
* @name glGetShaderSource - Returns the source code string from a shader object
* @usage
* @code void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source); @endcode
* @param shader Specifies the shader object to be queried.
* @param bufSize Specifies the size of the character buffer for storing the returned source code string.
* @param length Returns the length of the string returned in <em class="parameter"><b>source</b></em> (excluding the null terminator).
* @param source Specifies an array of characters that is used to return the source code string.
* @description
* 	glGetShaderSource returns the concatenation of the source code strings from the shader object specified by shader. The
* source code strings for a shader object are the result of a previous call to glShaderSource. The string returned by the
* function will be null terminated.<br>
* 	glGetShaderSource returns in source as much of the source code string as it can, up to a maximum of bufSize characters.
* The number of characters actually returned, excluding the null termination character, is specified by length. If the length
* of the returned string is not required, a value of NULL can be passed in the length argument. The size of the buffer
* required to store the returned source code string can be obtained by calling glGetShader with the value GL_SHADER_SOURCE_LENGTH.<br>
*
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_VALUE is generated if bufSize is less than 0.
*
*/
#define glGetShaderSource glad_glGetShaderSource
GLAD_API_CALL PFNGLGETSHADERIVPROC glad_glGetShaderiv;
// Unable to find the docs for this function!
#define glGetShaderiv glad_glGetShaderiv
GLAD_API_CALL PFNGLGETSTRINGPROC glad_glGetString;
/**
* @name glGetString - return a string describing the current GL connection
* @usage
* @code const GLubyte *glGetString(GLenum name); @endcode
* @param name Specifies a symbolic constant, one of <b>GL_VENDOR</b>, <b>GL_RENDERER</b>, <b>GL_VERSION</b>, or <b>GL_SHADING_LANGUAGE_VERSION</b>.
*             Additionally, <b>glGetStringi</b> accepts the <b>GL_EXTENSIONS</b> token.
* @param index For <b>glGetStringi</b>, specifies the index of the string to return.
* @description
* 	glGetString returns a pointer to a static string describing some aspect of the current GL connection. name can be one of
* the following:<br>
* 	Returns the company responsible for this GL implementation. This name does not change from release to release.<br>
* 	Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform.
* It does not change from release to release.<br>
* 	Returns a version or release number.<br>
* 	Returns a version or release number for the shading language.<br>
* 	glGetStringi returns a pointer to a static string indexed by index. name can be one of the following:<br>
* 	For glGetStringi only, returns the extension string supported by the implementation at index.<br>
* 	Strings GL_VENDOR and GL_RENDERER together uniquely specify a platform. They do not change from release to release and
* should be used by platform-recognition algorithms.<br>
* 	The GL_VERSION and GL_SHADING_LANGUAGE_VERSION strings begin with a version number. The version number uses one of these
* forms:<br>
* 	major_number.minor_numbermajor_number.minor_number.release_number<br>
* 	Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always
* separates the version number and the vendor-specific information.<br>
* 	All strings are null-terminated.<br>
*
* @note If an error is generated, glGetString returns 0.
* @note The client and server may support different versions. glGetString always returns a compatible version number. The release
*       number always describes the server.
*
* @errors GL_INVALID_ENUM is generated if name is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glGetStringi if index is outside the valid range for indexed state name.
*
*/
#define glGetString glad_glGetString
GLAD_API_CALL PFNGLGETSTRINGIPROC glad_glGetStringi;
// Unable to find the docs for this function!
#define glGetStringi glad_glGetStringi
GLAD_API_CALL PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;
/**
* @name glGetSubroutineIndex - retrieve the index of a subroutine uniform of a given shader stage within a program
* @usage
* @code GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name); @endcode
* @param program Specifies the name of the program containing shader stage.
* @param shadertype Specifies the shader stage from which to query for subroutine uniform index. <em class="parameter"><b>shadertype</b></em>
*                   must be one of <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>, <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param name Specifies the name of the subroutine uniform whose index to query.
* @description
* 	glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a program object. program
* contains the name of the program to which the shader is attached. shadertype specifies the stage from which to query
* shader subroutine index. name contains the null-terminated name of the subroutine uniform whose name to query.<br>
* 	If name is not the name of a subroutine uniform in the shader stage, GL_INVALID_INDEX is returned, but no error is generated.
* If name is the name of a subroutine uniform in the shader stage, a value between zero and the value of GL_ACTIVE_SUBROUTINES
* minus one will be returned. Subroutine indices are assigned using consecutive integers in the range from zero
* to the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.<br>
*
*
* @errors GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetSubroutineIndex glad_glGetSubroutineIndex
GLAD_API_CALL PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;
/**
* @name glGetSubroutineUniformLocation - retrieve the location of a subroutine uniform of a given shader stage within a program
* @usage
* @code GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name); @endcode
* @param program Specifies the name of the program containing shader stage.
* @param shadertype Specifies the shader stage from which to query for subroutine uniform index. <em class="parameter"><b>shadertype</b></em>
*                   must be one of <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>, <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param name Specifies the name of the subroutine uniform whose index to query.
* @description
* 	glGetSubroutineUniformLocation returns the location of the subroutine uniform variable name in the shader stage of type
* shadertype attached to program, with behavior otherwise identical to glGetUniformLocation.<br>
* 	If name is not the name of a subroutine uniform in the shader stage, -1 is returned, but no error is generated. If name
* is the name of a subroutine uniform in the shader stage, a value between zero and the value of GL_ACTIVE_SUBROUTINE_LOCATIONS
* minus one will be returned. Subroutine locations are assigned using consecutive integers in the range from zero to
* the value of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one for the shader stage.  For active subroutine uniforms declared as
* arrays, the declared array elements are assigned consecutive locations.<br>
*
*
* @errors GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetSubroutineUniformLocation glad_glGetSubroutineUniformLocation
GLAD_API_CALL PFNGLGETSYNCIVPROC glad_glGetSynciv;
// Unable to find the docs for this function!
#define glGetSynciv glad_glGetSynciv
GLAD_API_CALL PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
/**
* @name glGetTexImage - return a texture image
* @usage
* @code void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels); @endcode
* @code void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @code void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetTexImage</b> and <b>glGetnTexImage</b> functions. <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_ARRAY</b> are acceptable.
* @param texture Specifies the texture object name.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <math overflow="scroll"><mi
*              mathvariant="italic">n</mi></math> is the <math overflow="scroll"><mi mathvariant="italic">n</mi></math>th mipmap
*              reduction image.
* @param format Specifies a pixel format for the returned data. The supported formats are <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGBA</b>,
*               <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_GREEN_INTEGER</b>, <b>GL_BLUE_INTEGER</b>, <b>GL_RG_INTEGER</b>,
*               <b>GL_RGB_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGR_INTEGER</b>, <b>GL_BGRA_INTEGER</b>.
* @param type Specifies a pixel type for the returned data. The supported types are <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
*             <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetnTexImage</b> and <b>glGetTextureImage</b>
*                functions.
* @param pixels Returns the texture image. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @description
* 	glGetTexImage, glGetnTexImage and glGetTextureImage functions return a texture image into pixels. For glGetTexImage and
* glGetnTexImage, target specifies whether the desired texture image is one specified by glTexImage1D (GL_TEXTURE_1D), glTexImage2D
* (GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D or any of GL_TEXTURE_CUBE_MAP_*), or glTexImage3D (GL_TEXTURE_2D_ARRAY,
* GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY). For glGetTextureImage, texture specifies the texture object
* name. In addition to types of textures accepted by glGetTexImage and glGetnTexImage, the function also accepts cube
* map texture objects (with effective target GL_TEXTURE_CUBE_MAP). level specifies the level-of-detail number of the desired
* image. format and type specify the format and type of the desired image array. See the reference page for glTexImage1D
* for a description of the acceptable values for the format and type parameters, respectively. For glGetnTexImage and glGetTextureImage
* functions, bufSize tells the size of the buffer to receive the retrieved pixel data. glGetnTexImage and
* glGetTextureImage do not write more than bufSize bytes into pixels.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a texture image
* is requested, pixels is treated as a byte offset into the buffer object's data store.<br>
* 	To understand the operation of glGetTexImage, consider the selected internal four-component texture image to be an RGBA
* color buffer the size of the image. The semantics of glGetTexImage are then identical to those of glReadPixels, with the
* exception that no pixel transfer operations are performed, when called with the same format and type, with x and y set
* to 0, width set to the width of the texture image and height set to 1 for 1D images, or to the height of the texture image
* for 2D images.<br>
* 	If the selected texture image does not contain four components, the following mappings are applied. Single-component textures
* are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha
* set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the
* value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with
* red set to component zero, green set to component one, blue set to component two, and alpha set to 1.<br>
* 	To determine the required size of pixels, use glGetTexLevelParameter to determine the dimensions of the internal texture
* image, then scale the required number of pixels by the storage required for each pixel, based on format and type. Be sure
* to take the pixel storage parameters into account, especially GL_PACK_ALIGNMENT.<br>
* 	If glGetTextureImage is used against a cube map texture object, the texture is treated as a three-dimensional image of
* a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below:<br>
*
* @note If an error is generated, no change is made to the contents of pixels.
* @note glGetTexImage and glGetnTexImage return the texture image for the active texture unit.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetTexImage and glGetnTexImage functions if target is not an accepted value. These include:
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z for glGetTexImage and glGetnTexImage
*         functions.
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         and GL_TEXTURE_CUBE_MAP for glGetTextureImage function.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format, or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than  log2 ⁡ max , where maxis the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if level is non-zero and the effective target is GL_TEXTURE_RECTANGLE.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or
*         GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage and glGetnTexImage if the buffer size required to store the requested
*         data is greater than bufSize.
*
*/
#define glGetTexImage glad_glGetTexImage
GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
// Unable to find the docs for this function!
#define glGetTexLevelParameterfv glad_glGetTexLevelParameterfv
GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
// Unable to find the docs for this function!
#define glGetTexLevelParameteriv glad_glGetTexLevelParameteriv
GLAD_API_CALL PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
// Unable to find the docs for this function!
#define glGetTexParameterIiv glad_glGetTexParameterIiv
GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
// Unable to find the docs for this function!
#define glGetTexParameterIuiv glad_glGetTexParameterIuiv
GLAD_API_CALL PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
// Unable to find the docs for this function!
#define glGetTexParameterfv glad_glGetTexParameterfv
GLAD_API_CALL PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
// Unable to find the docs for this function!
#define glGetTexParameteriv glad_glGetTexParameteriv
GLAD_API_CALL PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;
/**
* @name glGetTexImage - return a texture image
* @usage
* @code void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels); @endcode
* @code void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @code void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetTexImage</b> and <b>glGetnTexImage</b> functions. <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_ARRAY</b> are acceptable.
* @param texture Specifies the texture object name.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <math overflow="scroll"><mi
*              mathvariant="italic">n</mi></math> is the <math overflow="scroll"><mi mathvariant="italic">n</mi></math>th mipmap
*              reduction image.
* @param format Specifies a pixel format for the returned data. The supported formats are <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGBA</b>,
*               <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_GREEN_INTEGER</b>, <b>GL_BLUE_INTEGER</b>, <b>GL_RG_INTEGER</b>,
*               <b>GL_RGB_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGR_INTEGER</b>, <b>GL_BGRA_INTEGER</b>.
* @param type Specifies a pixel type for the returned data. The supported types are <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
*             <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetnTexImage</b> and <b>glGetTextureImage</b>
*                functions.
* @param pixels Returns the texture image. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @description
* 	glGetTexImage, glGetnTexImage and glGetTextureImage functions return a texture image into pixels. For glGetTexImage and
* glGetnTexImage, target specifies whether the desired texture image is one specified by glTexImage1D (GL_TEXTURE_1D), glTexImage2D
* (GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D or any of GL_TEXTURE_CUBE_MAP_*), or glTexImage3D (GL_TEXTURE_2D_ARRAY,
* GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY). For glGetTextureImage, texture specifies the texture object
* name. In addition to types of textures accepted by glGetTexImage and glGetnTexImage, the function also accepts cube
* map texture objects (with effective target GL_TEXTURE_CUBE_MAP). level specifies the level-of-detail number of the desired
* image. format and type specify the format and type of the desired image array. See the reference page for glTexImage1D
* for a description of the acceptable values for the format and type parameters, respectively. For glGetnTexImage and glGetTextureImage
* functions, bufSize tells the size of the buffer to receive the retrieved pixel data. glGetnTexImage and
* glGetTextureImage do not write more than bufSize bytes into pixels.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a texture image
* is requested, pixels is treated as a byte offset into the buffer object's data store.<br>
* 	To understand the operation of glGetTexImage, consider the selected internal four-component texture image to be an RGBA
* color buffer the size of the image. The semantics of glGetTexImage are then identical to those of glReadPixels, with the
* exception that no pixel transfer operations are performed, when called with the same format and type, with x and y set
* to 0, width set to the width of the texture image and height set to 1 for 1D images, or to the height of the texture image
* for 2D images.<br>
* 	If the selected texture image does not contain four components, the following mappings are applied. Single-component textures
* are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha
* set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the
* value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with
* red set to component zero, green set to component one, blue set to component two, and alpha set to 1.<br>
* 	To determine the required size of pixels, use glGetTexLevelParameter to determine the dimensions of the internal texture
* image, then scale the required number of pixels by the storage required for each pixel, based on format and type. Be sure
* to take the pixel storage parameters into account, especially GL_PACK_ALIGNMENT.<br>
* 	If glGetTextureImage is used against a cube map texture object, the texture is treated as a three-dimensional image of
* a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below:<br>
*
* @note If an error is generated, no change is made to the contents of pixels.
* @note glGetTexImage and glGetnTexImage return the texture image for the active texture unit.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetTexImage and glGetnTexImage functions if target is not an accepted value. These include:
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z for glGetTexImage and glGetnTexImage
*         functions.
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         and GL_TEXTURE_CUBE_MAP for glGetTextureImage function.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format, or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than  log2 ⁡ max , where maxis the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if level is non-zero and the effective target is GL_TEXTURE_RECTANGLE.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or
*         GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage and glGetnTexImage if the buffer size required to store the requested
*         data is greater than bufSize.
*
*/
#define glGetTextureImage glad_glGetTextureImage
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;
// Unable to find the docs for this function!
#define glGetTextureLevelParameterfv glad_glGetTextureLevelParameterfv
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;
// Unable to find the docs for this function!
#define glGetTextureLevelParameteriv glad_glGetTextureLevelParameteriv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;
// Unable to find the docs for this function!
#define glGetTextureParameterIiv glad_glGetTextureParameterIiv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;
// Unable to find the docs for this function!
#define glGetTextureParameterIuiv glad_glGetTextureParameterIuiv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;
// Unable to find the docs for this function!
#define glGetTextureParameterfv glad_glGetTextureParameterfv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;
// Unable to find the docs for this function!
#define glGetTextureParameteriv glad_glGetTextureParameteriv
GLAD_API_CALL PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;
/**
* @name glGetTextureSubImage - retrieve a sub-region of a texture image from a texture
object
* @usage
* @code void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param texture Specifies the name of the source texture object. Must be <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>,
*                <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>
*                or <b>GL_TEXTURE_RECTANGLE</b>. In specific, buffer and multisample textures are not permitted.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_DEPTH_COMPONENT</b> and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param bufSize Specifies the size of the buffer to receive the retrieved pixel data.
* @param pixels Returns the texture subimage. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @description
* 	glGetTextureSubImage returns a texture subimage into pixels.<br>
* 	texture is the name of the source texture object and must not be a buffer or multisample texture. The effective target
* parameter is the value of GL_TEXTURE_TARGET for texture. Level, format, type and pixels have the same meaning as for glGetTexImage.
* bufSize is the size of the buffer to receive the retrieved pixel data.<br>
* 	For cube map textures, the behavior is as though GetTextureImage were called, but only texels from the requested cube map
* faces (selected by zoffset and depth, as described below) were returned.<br>
* 	xoffset, yoffset and zoffset values indicate the position of the subregion to return. width, height and depth indicate
* the size of the region to return. These parameters have the same meaning as for glTexSubImage3D, though for one- and two-dimensional
* textures there are extra restrictions, described in the errors section below.<br>
* 	For one-dimensional array textures, yoffset is interpreted as the first layer to access and height is the number of layers
* to access.<br>
* 	For two-dimensional array textures, zoffset is interpreted as the first layer to access and depth is the number of layers
* to access.<br>
* 	Cube map textures are treated as an array of six slices in the z-dimension, where the value of zoffset is interpreted as
* specifying the cube map face for the corresponding layer (as presented in the table below) and depth is the number of
* faces to access:<br>
* 	For cube map array textures, zoffset is the first layer-face to access, and depth is the number of layer-faces to access.
* A layer-face described by $k$ is translated into an array layer and face according to $$ layer = \left\lfloor { layer
* \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$<br>
* 	Component groups from the specified sub-region are packed and placed into memory as described for glGetTextureImage, starting
* with the texel at (xoffset, yoffset, zoffset).<br>
*
*
* @errors GL_INVALID_VALUE error is generated if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION error is generated if texture is the name of a buffer or multisample texture.
* @errors GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset are negative.
* @errors GL_INVALID_VALUE is generated if xoffset + width is greater than the texture's width, yoffset + height is greater than the
*         texture's height, or zoffset + depth is greater than the texture's depth.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D and either yoffset is not zero, or height is
*         not one.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE
*         and either zoffset is not zero, or depth is not one.
* @errors GL_INVALID_OPERATION error is generated if the buffer size required to store the requested data is greater than bufSize.
*
*/
#define glGetTextureSubImage glad_glGetTextureSubImage
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
/**
* @name glGetTransformFeedbackVarying - retrieve information about varying variables selected for transform feedback
* @usage
* @code void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name); @endcode
* @param program The name of the target program object.
* @param index The index of the varying variable whose information to retrieve.
* @param bufSize The maximum number of characters, including the null terminator, that may be written into <em class="parameter"><b>name</b></em>.
* @param length The address of a variable which will receive the number of characters written into <em class="parameter"><b>name</b></em>,
*               excluding the null-terminator. If <em class="parameter"><b>length</b></em> is <b>NULL</b> no length is returned.
* @param size The address of a variable that will receive the size of the varying.
* @param type The address of a variable that will receive the type of the varying.
* @param name The address of a buffer into which will be written the name of the varying.
* @description
* 	Information about the set of varying variables in a linked program that will be captured during transform feedback may
* be retrieved by calling glGetTransformFeedbackVarying. glGetTransformFeedbackVarying provides information about the varying
* variable selected by index. An index of 0 selects the first varying variable specified in the varyings array passed
* to glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one selects the last such
* variable.<br>
* 	The name of the selected varying is returned as a null-terminated string in name. The actual number of characters written
* into name, excluding the null terminator, is returned in length. If length is NULL, no length is returned. The maximum
* number of characters that may be written into name, including the null terminator, is specified by bufSize.<br>
* 	The length of the longest varying name in program is given by GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, which can be queried
* with glGetProgram.<br>
* 	For the selected varying variable, its type is returned into type. The size of the varying is returned into size. The value
* in size is in units of the type returned in type. The type returned can be any of the scalar, vector, or matrix attribute
* types returned by glGetActiveAttrib. If an error occurred, the return parameters length, size, type and name will
* be unmodified. This command will return as much information about the varying variables as possible. If no information
* is available, length will be set to zero and name will be an empty string. This situation could arise if glGetTransformFeedbackVarying
* is called after a failed link.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object.
* @errors GL_INVALID_VALUE is generated if index is greater or equal to the value of GL_TRANSFORM_FEEDBACK_VARYINGS.
* @errors GL_INVALID_OPERATION is generated program has not been linked.
*
*/
#define glGetTransformFeedbackVarying glad_glGetTransformFeedbackVarying
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;
// Unable to find the docs for this function!
#define glGetTransformFeedbacki64_v glad_glGetTransformFeedbacki64_v
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;
// Unable to find the docs for this function!
#define glGetTransformFeedbacki_v glad_glGetTransformFeedbacki_v
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;
// Unable to find the docs for this function!
#define glGetTransformFeedbackiv glad_glGetTransformFeedbackiv
GLAD_API_CALL PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
/**
* @name glGetUniformBlockIndex - retrieve the index of a named uniform block
* @usage
* @code GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName); @endcode
* @param program Specifies the name of a program containing the uniform block.
* @param uniformBlockName Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.
* @description
* 	glGetUniformBlockIndex retrieves the index of a uniform block within program.<br>
* 	program must be the name of a program object for which the command glLinkProgram must have been called in the past, although
* it is not required that glLinkProgram must have succeeded. The link could have failed because the number of active
* uniforms exceeded the limit.<br>
* 	uniformBlockName must contain a nul-terminated string specifying the name of the uniform block.<br>
* 	glGetUniformBlockIndex returns the uniform block index for the uniform block named uniformBlockName of program. If uniformBlockName
* does not identify an active uniform block of program, glGetUniformBlockIndex returns the special identifier,
* GL_INVALID_INDEX. Indices of the active uniform blocks of a program are assigned in consecutive order, beginning with
* zero.<br>
*
* @note glGetUniformBlockIndex is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called
*         in the past.
*
*/
#define glGetUniformBlockIndex glad_glGetUniformBlockIndex
GLAD_API_CALL PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
/**
* @name glGetUniformIndices - retrieve the index of a named uniform block
* @usage
* @code void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices); @endcode
* @param program Specifies the name of a program containing uniforms whose indices to query.
* @param uniformCount Specifies the number of uniforms whose indices to query.
* @param uniformNames Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
* @param uniformIndices Specifies the address of an array that will receive the indices of the uniforms.
* @description
* 	glGetUniformIndices retrieves the indices of a number of uniforms within program.<br>
* 	program must be the name of a program object for which the command glLinkProgram must have been called in the past, although
* it is not required that glLinkProgram must have succeeded. The link could have failed because the number of active
* uniforms exceeded the limit.<br>
* 	uniformCount indicates both the number of elements in the array of names uniformNames and the number of indices that may
* be written to uniformIndices.<br>
* 	uniformNames contains a list of uniformCount name strings identifying the uniform names to be queried for indices. For
* each name string in uniformNames, the index assigned to the active uniform of that name will be written to the corresponding
* element of uniformIndices. If a string in uniformNames is not the name of an active uniform, the special value GL_INVALID_INDEX
* will be written to the corresponding element of uniformIndices.<br>
* 	If an error occurs, nothing is written to uniformIndices.<br>
*
* @note glGetUniformIndices is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called
*         in the past.
*
*/
#define glGetUniformIndices glad_glGetUniformIndices
GLAD_API_CALL PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
/**
* @name glGetUniformLocation - Returns the location of a uniform variable
* @usage
* @code GLint glGetUniformLocation(GLuint program, const GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param name Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
* @description
* 	glGetUniformLocation  returns an integer that represents the location of a specific uniform variable within a program object.
* name must be a null terminated string that contains no white space. name must be an active uniform variable name
* in program that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns
* -1 if name does not correspond to an active uniform variable in program, if name starts with the reserved prefix "gl_",
* or if name is associated with an atomic counter or a named uniform block.<br>
* 	Uniform variables that are structures or arrays of structures may be queried by calling glGetUniformLocation for each field
* within the structure. The array element operator "[]" and the structure field operator "." may be used in name in order
* to select elements within an array or fields within a structure. The result of using these operators is not allowed
* to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of
* name indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name
* of the array, or by using the name appended by "[0]".<br>
* 	The actual locations assigned to uniform variables are not known until the program object is linked successfully. After
* linking has occurred, the command glGetUniformLocation can be used to obtain the location of a uniform variable. This location
* value can then be passed to glUniform to set the value of the uniform variable or to glGetUniform in order to query
* the current value of the uniform variable. After a program object has been linked successfully, the index values for
* uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried
* after a link if the link was successful.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program has not been successfully linked.
*
*/
#define glGetUniformLocation glad_glGetUniformLocation
GLAD_API_CALL PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;
// Unable to find the docs for this function!
#define glGetUniformSubroutineuiv glad_glGetUniformSubroutineuiv
GLAD_API_CALL PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;
// Unable to find the docs for this function!
#define glGetUniformdv glad_glGetUniformdv
GLAD_API_CALL PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
// Unable to find the docs for this function!
#define glGetUniformfv glad_glGetUniformfv
GLAD_API_CALL PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
// Unable to find the docs for this function!
#define glGetUniformiv glad_glGetUniformiv
GLAD_API_CALL PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
// Unable to find the docs for this function!
#define glGetUniformuiv glad_glGetUniformuiv
GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;
/**
* @name glGetVertexArrayIndexed - retrieve parameters of an attribute of a vertex array
object
* @usage
* @code void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param); @endcode
* @param vaobj Specifies the name of a vertex array object.
* @param index Specifies the index of the vertex array object attribute. Must be a number between 0 and (<b>GL_MAX_VERTEX_ATTRIBS</b> -
*              1).
* @param pname Specifies the property to be used for the query. For <b>glGetVertexArrayIndexediv</b>, it must be one of the following values:
*              <b>GL_VERTEX_ATTRIB_ARRAY_ENABLED</b>, <b>GL_VERTEX_ATTRIB_ARRAY_SIZE</b>, <b>GL_VERTEX_ATTRIB_ARRAY_STRIDE</b>,
*              <b>GL_VERTEX_ATTRIB_ARRAY_TYPE</b>, <b>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</b>, <b>GL_VERTEX_ATTRIB_ARRAY_INTEGER</b>, <b>GL_VERTEX_ATTRIB_ARRAY_LONG</b>,
*              <b>GL_VERTEX_ATTRIB_ARRAY_DIVISOR</b>, or <b>GL_VERTEX_ATTRIB_RELATIVE_OFFSET</b>. For
*              <b>glGetVertexArrayIndexed64v</b>, it must be equal to <b>GL_VERTEX_BINDING_OFFSET</b>.
* @param param Returns the requested value.
* @description
* 	glGetVertexArrayIndexediv and glGetVertexArrayIndexed64iv provide a way of querying parameters of an attribute at an user-specified
* index of a vertex array object. The vertex array object does not have to be bound to the rendering context
* at the time of the call, but must have been bound at least once prior to this call.<br>
* 	The following parameter values can be retrieved with glGetVertexArrayIndexediv for each of the attributes defined for a
* vertex array object:<br>
* 	GL_VERTEX_ATTRIB_ARRAY_ENABLED: param returns a value that is non-zero (true) if the vertex attribute array for index is
* enabled and 0 (false) if it is disabled. The initial value is GL_FALSE.<br>
* 	GL_VERTEX_ATTRIB_ARRAY_SIZE: param returns a single value, the size of the vertex attribute array for index. The size is
* the number of values for each element of the vertex attribute array, and it will be 1, 2, 3 or 4. The initial value is
* 4.<br>
* 	GL_VERTEX_ATTRIB_ARRAY_STRIDE: param returns a single value, the array stride for (number of bytes between successive elements
* in) the vertex attribute array for index. A value of 0 indicates the array elements are stored sequentially in memory.
* The initial value is 0.<br>
* 	GL_VERTEX_ATTRIB_ARRAY_TYPE: param returns a single value, a symbolic constant indicating the array type for the vertex
* attribute array for index. Possible values are GL_BYTE, GL_DOUBLE, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT, GL_INT, GL_INT_2_10_10_10_REV,
* GL_SHORT, GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT, GL_UNSIGNED_INT_2_10_10_10_REV, and GL_UNSIGNED_INT_10F_11F_11F_REV
* . The initial value is GL_FLOAT.<br>
* 	GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: param returns a single value that is non-zero (true) if fixed-point data types for the
* vertex attribute array indicated by index are normalized when they are converted to floating-point, and 0 (false) otherwise.
* The initial value is GL_FALSE.<br>
* 	GL_VERTEX_ATTRIB_ARRAY_INTEGER: param returns a single value that is non-zero (true) if fixed-point data types for the
* vertex attribute array indicated by index have integer data type, and 0 (false) otherwise. The initial value is 0 (GL_FALSE).<br>
* 	GL_VERTEX_ATTRIB_ARRAY_LONG: param returns a single value that is non-zero (true) if a vertex attribute is stored as an
* unconverted double, and 0 (false) otherwise. The initial value is 0 (GL_FALSE).<br>
* 	GL_VERTEX_ATTRIB_ARRAY_DIVISOR: param returns a single value that is the frequency divisor used for instanced rendering.
* See glVertexAttribDivisor. The initial value is 0.<br>
* 	GL_VERTEX_ATTRIB_RELATIVE_OFFSET: param returns a single value that is the byte offset of the first element relative to
* the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.<br>
* 	glGetVertexArrayIndexed64iv can be used to retrieve GL_VERTEX_BINDING_OFFSET parameter value for any of the attributes
* defined for a vertex array object. When pname is set to GL_VERTEX_BINDING_OFFSET, param returns a single value that is the
* byte offset of the first element in the bound buffer's data store. The initial value for this parameter is 0.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE error is generated if index is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM error is generated if pname is not one of the valid values. For more details, please see above.
*
*/
#define glGetVertexArrayIndexed64iv glad_glGetVertexArrayIndexed64iv
GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;
// Unable to find the docs for this function!
#define glGetVertexArrayIndexediv glad_glGetVertexArrayIndexediv
GLAD_API_CALL PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;
/**
* @name glGetVertexArrayiv - retrieve parameters of a vertex array object
* @usage
* @code void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param); @endcode
* @param vaobj specifies the name of the vertex array object to use for the query.
* @param pname Name of the property to use for the query. Must be <b>GL_ELEMENT_ARRAY_BUFFER_BINDING</b>.
* @param param Returns the requested value.
* @description
* 	This function provides a mean of querying properties of an existing vertex array object. The vertex array object does not
* have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this
* call.<br>
* 	glGetVertexArrayiv can be used to retrieve ID of a buffer object that will be bound to the GL_ELEMENT_ARRAY_BUFFER binding
* point whenever the queried vertex array object is bound to the rendering context. The binding can be changed for an
* active vertex array object with a glBindBuffer call.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_ENUM error is generated if pname is not GL_ELEMENT_ARRAY_BUFFER_BINDING.
*
*/
#define glGetVertexArrayiv glad_glGetVertexArrayiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
// Unable to find the docs for this function!
#define glGetVertexAttribIiv glad_glGetVertexAttribIiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
// Unable to find the docs for this function!
#define glGetVertexAttribIuiv glad_glGetVertexAttribIuiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;
// Unable to find the docs for this function!
#define glGetVertexAttribLdv glad_glGetVertexAttribLdv
GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
/**
* @name glGetVertexAttribPointerv - return the address of the specified generic vertex attribute pointer
* @usage
* @code void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer); @endcode
* @param index Specifies the generic vertex attribute parameter to be returned.
* @param pname Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be <b>GL_VERTEX_ATTRIB_ARRAY_POINTER</b>.
* @param pointer Returns the pointer value.
* @description
* 	glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be queried, pname is a
* symbolic constant indicating the pointer to be returned, and params is a pointer to a location in which to place the returned
* data.<br>
* 	The pointer returned is a byte offset into the data store of the buffer object that was bound to the GL_ARRAY_BUFFER target
* (see glBindBuffer) when the desired pointer was previously specified.<br>
*
* @note The state returned is retrieved from the currently bound vertex array object.
* @note The initial value for each pointer is 0.
*
* @errors GL_INVALID_OPERATION is generated if no vertex array object is currently bound.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if pname is not an accepted value.
*
*/
#define glGetVertexAttribPointerv glad_glGetVertexAttribPointerv
GLAD_API_CALL PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
// Unable to find the docs for this function!
#define glGetVertexAttribdv glad_glGetVertexAttribdv
GLAD_API_CALL PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
// Unable to find the docs for this function!
#define glGetVertexAttribfv glad_glGetVertexAttribfv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
// Unable to find the docs for this function!
#define glGetVertexAttribiv glad_glGetVertexAttribiv
GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;
/**
* @name glGetCompressedTexImage - return a compressed texture image
* @usage
* @code void glGetCompressedTexImage(GLenum target, GLint level, void * pixels); @endcode
* @code void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels); @endcode
* @code void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetCompressedTexImage</b> and <b>glGetnCompressedTexImage</b>
*               functions. <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, <b>GL_TEXTURE_RECTANGLE</b> are accepted.
* @param texture Specifies the texture object name for <b>glGetCompressedTextureImage</b> function.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap
*              reduction image.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetCompressedTextureImage</b> and <b>glGetnCompressedTexImage</b>
*                functions.
* @param pixels Returns the compressed texture image.
* @description
* 	glGetCompressedTexImage and glGetnCompressedTexImage return the compressed texture image associated with target and lod
* into pixels. glGetCompressedTextureImage serves the same purpose, but instead of taking a texture target, it takes the
* ID of the texture object. pixels should be an array of bufSize bytes for glGetnCompresedTexImage and glGetCompressedTextureImage
* functions, and of GL_TEXTURE_COMPRESSED_IMAGE_SIZE bytes in case of glGetCompressedTexImage. If the actual data
* takes less space than bufSize, the remaining bytes will not be touched. target specifies the texture target, to which the
* texture the data the function should extract the data from is bound to. lod specifies the level-of-detail number of the
* desired image.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a texture image
* is requested, pixels is treated as a byte offset into the buffer object's data store.<br>
* 	To minimize errors, first verify that the texture is compressed by calling glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED.
* If the texture is compressed, you can determine the amount of memory required to store the compressed texture
* by calling glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED_IMAGE_SIZE. Finally, retrieve the internal format
* of the texture by calling glGetTexLevelParameter with argument GL_TEXTURE_INTERNAL_FORMAT. To store the texture for
* later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective
* texture or subtexture loading routine used for loading target textures.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glGetCompressedTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than zero or greater than the maximum number of LODs permitted by the implementation.
* @errors GL_INVALID_OPERATION is generated if glGetCompressedTexImage, glGetnCompressedTexImage, and glGetCompressedTextureImage
*         is used to retrieve a texture that is in an uncompressed internal format.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target, the buffer
*         storage was not initialized with glBufferStorage using GL_MAP_PERSISTENT_BIT flag, and the buffer object's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
*
*/
#define glGetnCompressedTexImage glad_glGetnCompressedTexImage
GLAD_API_CALL PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;
/**
* @name glGetTexImage - return a texture image
* @usage
* @code void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels); @endcode
* @code void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @code void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetTexImage</b> and <b>glGetnTexImage</b> functions. <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_ARRAY</b> are acceptable.
* @param texture Specifies the texture object name.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <math overflow="scroll"><mi
*              mathvariant="italic">n</mi></math> is the <math overflow="scroll"><mi mathvariant="italic">n</mi></math>th mipmap
*              reduction image.
* @param format Specifies a pixel format for the returned data. The supported formats are <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGBA</b>,
*               <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_GREEN_INTEGER</b>, <b>GL_BLUE_INTEGER</b>, <b>GL_RG_INTEGER</b>,
*               <b>GL_RGB_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGR_INTEGER</b>, <b>GL_BGRA_INTEGER</b>.
* @param type Specifies a pixel type for the returned data. The supported types are <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
*             <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetnTexImage</b> and <b>glGetTextureImage</b>
*                functions.
* @param pixels Returns the texture image. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @description
* 	glGetTexImage, glGetnTexImage and glGetTextureImage functions return a texture image into pixels. For glGetTexImage and
* glGetnTexImage, target specifies whether the desired texture image is one specified by glTexImage1D (GL_TEXTURE_1D), glTexImage2D
* (GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D or any of GL_TEXTURE_CUBE_MAP_*), or glTexImage3D (GL_TEXTURE_2D_ARRAY,
* GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY). For glGetTextureImage, texture specifies the texture object
* name. In addition to types of textures accepted by glGetTexImage and glGetnTexImage, the function also accepts cube
* map texture objects (with effective target GL_TEXTURE_CUBE_MAP). level specifies the level-of-detail number of the desired
* image. format and type specify the format and type of the desired image array. See the reference page for glTexImage1D
* for a description of the acceptable values for the format and type parameters, respectively. For glGetnTexImage and glGetTextureImage
* functions, bufSize tells the size of the buffer to receive the retrieved pixel data. glGetnTexImage and
* glGetTextureImage do not write more than bufSize bytes into pixels.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a texture image
* is requested, pixels is treated as a byte offset into the buffer object's data store.<br>
* 	To understand the operation of glGetTexImage, consider the selected internal four-component texture image to be an RGBA
* color buffer the size of the image. The semantics of glGetTexImage are then identical to those of glReadPixels, with the
* exception that no pixel transfer operations are performed, when called with the same format and type, with x and y set
* to 0, width set to the width of the texture image and height set to 1 for 1D images, or to the height of the texture image
* for 2D images.<br>
* 	If the selected texture image does not contain four components, the following mappings are applied. Single-component textures
* are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha
* set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the
* value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with
* red set to component zero, green set to component one, blue set to component two, and alpha set to 1.<br>
* 	To determine the required size of pixels, use glGetTexLevelParameter to determine the dimensions of the internal texture
* image, then scale the required number of pixels by the storage required for each pixel, based on format and type. Be sure
* to take the pixel storage parameters into account, especially GL_PACK_ALIGNMENT.<br>
* 	If glGetTextureImage is used against a cube map texture object, the texture is treated as a three-dimensional image of
* a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below:<br>
*
* @note If an error is generated, no change is made to the contents of pixels.
* @note glGetTexImage and glGetnTexImage return the texture image for the active texture unit.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetTexImage and glGetnTexImage functions if target is not an accepted value. These include:
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z for glGetTexImage and glGetnTexImage
*         functions.
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         and GL_TEXTURE_CUBE_MAP for glGetTextureImage function.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format, or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than  log2 ⁡ max , where maxis the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if level is non-zero and the effective target is GL_TEXTURE_RECTANGLE.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or
*         GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage and glGetnTexImage if the buffer size required to store the requested
*         data is greater than bufSize.
*
*/
#define glGetnTexImage glad_glGetnTexImage
GLAD_API_CALL PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;
// Unable to find the docs for this function!
#define glGetnUniformdv glad_glGetnUniformdv
GLAD_API_CALL PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;
// Unable to find the docs for this function!
#define glGetnUniformfv glad_glGetnUniformfv
GLAD_API_CALL PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;
// Unable to find the docs for this function!
#define glGetnUniformiv glad_glGetnUniformiv
GLAD_API_CALL PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;
// Unable to find the docs for this function!
#define glGetnUniformuiv glad_glGetnUniformuiv
GLAD_API_CALL PFNGLHINTPROC glad_glHint;
/**
* @name glHint - specify implementation-specific hints
* @usage
* @code void glHint(GLenum target, GLenum mode); @endcode
* @param target Specifies a symbolic constant indicating the behavior to be controlled. <b>GL_LINE_SMOOTH_HINT</b>, <b>GL_POLYGON_SMOOTH_HINT</b>,
*               <b>GL_TEXTURE_COMPRESSION_HINT</b>, and <b>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</b> are accepted.
* @param mode Specifies a symbolic constant indicating the desired behavior. <b>GL_FASTEST</b>, <b>GL_NICEST</b>, and <b>GL_DONT_CARE</b>
*             are accepted.
* @description
* 	Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified
* with two arguments. target is a symbolic constant indicating the behavior to be controlled, and mode is another symbolic
* constant indicating the desired behavior. The initial value for each target is GL_DONT_CARE. mode can be one of the following:<br>
* 	The most efficient option should be chosen.<br>
* 	The most correct, or highest quality, option should be chosen.<br>
* 	No preference.<br>
* 	Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation.
* The hint aspects that can be specified with target, along with suggested semantics, are as follows:<br>
* 	Indicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions:
* dFdx, dFdy, and fwidth.<br>
* 	Indicates the sampling quality of antialiased lines. If a larger filter function is applied, hinting GL_NICEST can result
* in more pixel fragments being generated during rasterization.<br>
* 	Indicates the sampling quality of antialiased polygons. Hinting GL_NICEST can result in more pixel fragments being generated
* during rasterization, if a larger filter function is applied.<br>
* 	Indicates the quality and performance of the compressing texture images. Hinting GL_FASTEST indicates that texture images
* should be compressed as quickly as possible, while GL_NICEST indicates that texture images should be compressed with
* as little image quality loss as possible. GL_NICEST should be selected if the texture is to be retrieved by glGetCompressedTexImage
* for reuse.<br>
*
* @note The interpretation of hints depends on the implementation. Some implementations ignore glHint settings.
*
* @errors GL_INVALID_ENUM is generated if either target or mode is not an accepted value.
*
*/
#define glHint glad_glHint
GLAD_API_CALL PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;
/**
* @name glInvalidateBufferData - invalidate the content of a buffer object's data store
* @usage
* @code void glInvalidateBufferData(GLuint buffer); @endcode
* @param buffer The name of a buffer object whose data store to invalidate.
* @description
* 	glInvalidateBufferData invalidates all of the content of the data store of a buffer object. After invalidation, the content
* of the buffer's data store becomes undefined.<br>
*
*
* @errors GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of buffer is currently mapped.
*
*/
#define glInvalidateBufferData glad_glInvalidateBufferData
GLAD_API_CALL PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;
/**
* @name glInvalidateBufferSubData - invalidate a region of a buffer object's data store
* @usage
* @code void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length); @endcode
* @param buffer The name of a buffer object, a subrange of whose data store to invalidate.
* @param offset The offset within the buffer's data store of the start of the range to be invalidated.
* @param length The length of the range within the buffer's data store to be invalidated.
* @description
* 	glInvalidateBufferSubData invalidates all or part of the content of the data store of a buffer object. After invalidation,
* the content of the specified range of the buffer's data store becomes undefined. The start of the range is given by
* offset and its size is given by length, both measured in basic machine units.<br>
*
*
* @errors GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length is greater than the value of GL_BUFFER_SIZE
*         for buffer.
* @errors GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of buffer is currently mapped.
*
*/
#define glInvalidateBufferSubData glad_glInvalidateBufferSubData
GLAD_API_CALL PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;
/**
* @name glInvalidateFramebuffer, glInvalidateNamedFramebufferData - invalidate the content of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments); @endcode
* @code void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
* @description
* 	glInvalidateFramebuffer and glInvalidateNamedFramebufferData invalidate the entire contents of a specified set of attachments
* of a framebuffer.<br>
* 	For glInvalidateFramebuffer, the framebuffer object is that bound to target. target must be GL_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_DRAW_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER. Default framebuffers may also be invalidated
* if bound to target.<br>
* 	For glInvalidateNamedFramebufferData, framebuffer is the name of the framebuffer object. If framebuffer is zero, the default
* draw framebuffer is affected.<br>
* 	The set of attachments whose contents are to be invalidated are specified in the attachments array, which contains numAttachments
* elements.<br>
* 	If the specified framebuffer is a framebuffer object, each element of attachments must be one of GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT,
* or GL_COLOR_ATTACHMENTi, where i is between zero and the value of GL_MAX_FRAMEBUFFER_ATTACHMENTS
* minus one.<br>
* 	If the specified framebuffer is a default framebuffer, each element of attachments must be one of GL_FRONT_LEFT, GL_FRONT_RIGHT,
* GL_BACK_LEFT, GL_BACK_RIGHT, GL_AUXi, GL_ACCUM, GL_COLOR, GL_DEPTH, or GL_STENCIL. GL_COLOR, is treated as GL_BACK_LEFT
* for a double-buffered context and GL_FRONT_LEFT for a single-buffered context. The other attachments identify
* the corresponding specific buffer.<br>
* 	The entire contents of each specified attachment become undefined after execution of glInvalidateFramebuffer or glInvalidateNamedFramebufferData.<br>
* 	If the framebuffer object is not complete, glInvalidateFramebuffer and glInvalidateNamedFramebufferData may be ignored.
* This is not an error.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glInvalidateFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glInvalidateNamedFramebufferData if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_VALUE is generated if numAttachments is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateFramebuffer glad_glInvalidateFramebuffer
GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;
/**
* @name glInvalidateFramebuffer, glInvalidateNamedFramebufferData - invalidate the content of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments); @endcode
* @code void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
* @description
* 	glInvalidateFramebuffer and glInvalidateNamedFramebufferData invalidate the entire contents of a specified set of attachments
* of a framebuffer.<br>
* 	For glInvalidateFramebuffer, the framebuffer object is that bound to target. target must be GL_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_DRAW_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER. Default framebuffers may also be invalidated
* if bound to target.<br>
* 	For glInvalidateNamedFramebufferData, framebuffer is the name of the framebuffer object. If framebuffer is zero, the default
* draw framebuffer is affected.<br>
* 	The set of attachments whose contents are to be invalidated are specified in the attachments array, which contains numAttachments
* elements.<br>
* 	If the specified framebuffer is a framebuffer object, each element of attachments must be one of GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT,
* or GL_COLOR_ATTACHMENTi, where i is between zero and the value of GL_MAX_FRAMEBUFFER_ATTACHMENTS
* minus one.<br>
* 	If the specified framebuffer is a default framebuffer, each element of attachments must be one of GL_FRONT_LEFT, GL_FRONT_RIGHT,
* GL_BACK_LEFT, GL_BACK_RIGHT, GL_AUXi, GL_ACCUM, GL_COLOR, GL_DEPTH, or GL_STENCIL. GL_COLOR, is treated as GL_BACK_LEFT
* for a double-buffered context and GL_FRONT_LEFT for a single-buffered context. The other attachments identify
* the corresponding specific buffer.<br>
* 	The entire contents of each specified attachment become undefined after execution of glInvalidateFramebuffer or glInvalidateNamedFramebufferData.<br>
* 	If the framebuffer object is not complete, glInvalidateFramebuffer and glInvalidateNamedFramebufferData may be ignored.
* This is not an error.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glInvalidateFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glInvalidateNamedFramebufferData if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_VALUE is generated if numAttachments is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateNamedFramebufferData glad_glInvalidateNamedFramebufferData
GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;
/**
* @name glInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData - invalidate the content of a region of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height); @endcode
* @code void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateSubFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferSubData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
* @param x Specifies the X offset of the region to be invalidated.
* @param y Specifies the Y offset of the region to be invalidated.
* @param width Specifies the width of the region to be invalidated.
* @param height Specifies the height of the region to be invalidated.
* @description
* 	glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData invalidate the contents of a specified region of a specified
* set of attachments of a framebuffer.<br>
* 	For glInvalidateSubFramebuffer, the framebuffer object is that bound to target, which must be one of GL_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_DRAW_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER. Default framebuffers may
* also be invalidated if bound to target.<br>
* 	For glInvalidateNamedFramebufferSubData, framebuffer is the name of the framebuffer object. If framebuffer is zero, the
* default draw framebuffer is affected.<br>
* 	The set of attachments of which a region is to be invalidated are specified in the attachments array, which contains numAttachments
* elements.<br>
* 	If the specified framebuffer is a framebuffer object, each element of attachments must be one of GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT,
* or GL_COLOR_ATTACHMENTi, where i is between zero and the value of GL_MAX_FRAMEBUFFER_ATTACHMENTS
* minus one.<br>
* 	If the specified framebuffer is a default framebuffer, each element of attachments must be one of GL_FRONT_LEFT, GL_FRONT_RIGHT,
* GL_BACK_LEFT, GL_BACK_RIGHT, GL_AUXi, GL_ACCUM, GL_COLOR, GL_DEPTH, or GL_STENCIL. GL_COLOR, is treated as GL_BACK_LEFT
* for a double-buffered context and GL_FRONT_LEFT for a single-buffered context. The other attachments identify
* the corresponding specific buffer.<br>
* 	The contents of the specified region of each specified attachment become undefined after execution of glInvalidateSubFramebuffer
* or glInvalidateNamedFramebufferSubData. The region to be invalidated is specified by x, y, width and height where
* x and y give the offset from the origin (with lower-left corner at $(0,0)$) and width and height are the width and height,
* respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the
* default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is
* not complete, these commands may be ignored.<br>
* 	If the framebuffer object is not complete, glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData may be ignored.
* This is not an error.<br>
*
*
* @errors GL_INVALID_ENUM by glInvalidateSubFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION by glInvalidateNamedFramebufferSubData if framebuffer is not zero of the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if numAttachments, width or height is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateNamedFramebufferSubData glad_glInvalidateNamedFramebufferSubData
GLAD_API_CALL PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;
/**
* @name glInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData - invalidate the content of a region of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height); @endcode
* @code void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateSubFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferSubData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
* @param x Specifies the X offset of the region to be invalidated.
* @param y Specifies the Y offset of the region to be invalidated.
* @param width Specifies the width of the region to be invalidated.
* @param height Specifies the height of the region to be invalidated.
* @description
* 	glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData invalidate the contents of a specified region of a specified
* set of attachments of a framebuffer.<br>
* 	For glInvalidateSubFramebuffer, the framebuffer object is that bound to target, which must be one of GL_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_DRAW_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER. Default framebuffers may
* also be invalidated if bound to target.<br>
* 	For glInvalidateNamedFramebufferSubData, framebuffer is the name of the framebuffer object. If framebuffer is zero, the
* default draw framebuffer is affected.<br>
* 	The set of attachments of which a region is to be invalidated are specified in the attachments array, which contains numAttachments
* elements.<br>
* 	If the specified framebuffer is a framebuffer object, each element of attachments must be one of GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT,
* or GL_COLOR_ATTACHMENTi, where i is between zero and the value of GL_MAX_FRAMEBUFFER_ATTACHMENTS
* minus one.<br>
* 	If the specified framebuffer is a default framebuffer, each element of attachments must be one of GL_FRONT_LEFT, GL_FRONT_RIGHT,
* GL_BACK_LEFT, GL_BACK_RIGHT, GL_AUXi, GL_ACCUM, GL_COLOR, GL_DEPTH, or GL_STENCIL. GL_COLOR, is treated as GL_BACK_LEFT
* for a double-buffered context and GL_FRONT_LEFT for a single-buffered context. The other attachments identify
* the corresponding specific buffer.<br>
* 	The contents of the specified region of each specified attachment become undefined after execution of glInvalidateSubFramebuffer
* or glInvalidateNamedFramebufferSubData. The region to be invalidated is specified by x, y, width and height where
* x and y give the offset from the origin (with lower-left corner at $(0,0)$) and width and height are the width and height,
* respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the
* default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is
* not complete, these commands may be ignored.<br>
* 	If the framebuffer object is not complete, glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData may be ignored.
* This is not an error.<br>
*
*
* @errors GL_INVALID_ENUM by glInvalidateSubFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION by glInvalidateNamedFramebufferSubData if framebuffer is not zero of the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if numAttachments, width or height is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateSubFramebuffer glad_glInvalidateSubFramebuffer
GLAD_API_CALL PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;
/**
* @name glInvalidateTexImage - invalidate the entirety a texture image
* @usage
* @code void glInvalidateTexImage(GLuint texture, GLint level); @endcode
* @param texture The name of a texture object to invalidate.
* @param level The level of detail of the texture object to invalidate.
* @description
* 	glInvalidateTexSubImage invalidates all of a texture image. texture and level indicated which texture image is being invalidated.
* After this command, data in the texture image has undefined values.<br>
* 	level must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height,
* or depth.<br>
* 	For textures of targets GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
* level must be zero.<br>
*
*
* @errors GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum
*         texture width, height, or depth.
* @errors GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE,
*         or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero.
* @errors GL_INVALID_VALUE is generated if texture is not the name of an existing texture object.
*
*/
#define glInvalidateTexImage glad_glInvalidateTexImage
GLAD_API_CALL PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;
/**
* @name glInvalidateTexSubImage - invalidate a region of a texture image
* @usage
* @code void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @param texture The name of a texture object a subregion of which to invalidate.
* @param level The level of detail of the texture object within which the region resides.
* @param xoffset The X offset of the region to be invalidated.
* @param yoffset The Y offset of the region to be invalidated.
* @param zoffset The Z offset of the region to be invalidated.
* @param width The width of the region to be invalidated.
* @param height The height of the region to be invalidated.
* @param depth The depth of the region to be invalidated.
* @description
* 	glInvalidateTexSubImage invalidates all or part of a texture image. texture and level indicated which texture image is
* being invalidated. After this command, data in that subregion have undefined values. xoffset, yoffset, zoffset, width, height,
* and depth are interpreted as they are in glTexSubImage3D. For texture targets that don't have certain dimensions,
* this command treats those dimensions as having a size of 1. For example, to invalidate a portion of a two- dimensional
* texture, the application would use zoffset equal to zero and depth equal to one. Cube map textures are treated as an array
* of six slices in the z-dimension, where a value of zoffset is interpreted as specifying face GL_TEXTURE_CUBE_MAP_POSITIVE_X
* + zoffset.<br>
* 	level must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height,
* or depth. xoffset, yoffset and zoffset must be greater than or equal to zero and be less than the width, height or depth
* of the image, respectively. Furthermore, xoffset + width, yoffset + height, and zoffset + depth must be less than or equal
* to the width, height or depth of the image, respectively.<br>
* 	For textures of targets GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
* level must be zero.<br>
*
*
* @errors GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset is less than zero, or if any of them is greater than the size
*         of the image in the corresponding dimension.
* @errors GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum
*         texture width, height, or depth.
* @errors GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE,
*         or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero.
* @errors GL_INVALID_VALUE is generated if texture is not the name of an existing texture object.
*
*/
#define glInvalidateTexSubImage glad_glInvalidateTexSubImage
GLAD_API_CALL PFNGLISBUFFERPROC glad_glIsBuffer;
/**
* @name glIsBuffer - determine if a name corresponds to a buffer object
* @usage
* @code GLboolean glIsBuffer(GLuint buffer); @endcode
* @param buffer Specifies a value that may be the name of a buffer object.
* @description
* 	glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object. If buffer is zero, or is a non-zero value
* that is not currently the name of a buffer object, or if an error occurs, glIsBuffer returns GL_FALSE.<br>
* 	A name returned by glGenBuffers, but not yet associated with a buffer object by calling glBindBuffer, is not the name of
* a buffer object.<br>
*
*
*
*/
#define glIsBuffer glad_glIsBuffer
GLAD_API_CALL PFNGLISENABLEDPROC glad_glIsEnabled;
/**
* @name glIsEnabled, glIsEnabledi - test whether a capability is enabled
* @usage
* @code GLboolean glIsEnabled(GLenum cap); @endcode
* @param cap Specifies a symbolic constant indicating a GL capability.
* @param index Specifies the index of the capability.
* @description
* 	glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean states that are indexed
* may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index of the capability to test. index must
* be between zero and the count of indexed capabilities for cap. Initially all capabilities except GL_DITHER are disabled;
* GL_DITHER is initially enabled.<br>
* 	The following capabilities are accepted for cap:<br>
*
* @note If an error is generated, glIsEnabled and glIsEnabledi return GL_FALSE.
* @note GL_PRIMITIVE_RESTART_FIXED_INDEX are available only if the GL version is 4.3 or greater.
* @note GL_DEBUG_OUTPUT and GL_DEBUG_OUTPUT_SYNCHRONOUS are available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if cap is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glIsEnabledi if index is outside the valid range for the indexed state cap.
*
*/
#define glIsEnabled glad_glIsEnabled
GLAD_API_CALL PFNGLISENABLEDIPROC glad_glIsEnabledi;
// Unable to find the docs for this function!
#define glIsEnabledi glad_glIsEnabledi
GLAD_API_CALL PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
/**
* @name glIsFramebuffer - determine if a name corresponds to a framebuffer object
* @usage
* @code GLboolean glIsFramebuffer(GLuint framebuffer); @endcode
* @param framebuffer Specifies a value that may be the name of a framebuffer object.
* @description
* 	glIsFramebuffer returns GL_TRUE if framebuffer is currently the name of a framebuffer object. If framebuffer is zero, or
* if framebuffer is not the name of a framebuffer object, or if an error occurs, glIsFramebuffer returns GL_FALSE. If framebuffer
* is a name returned by glGenFramebuffers, by that has not yet been bound through a call to glBindFramebuffer, then
* the name is not a framebuffer object and glIsFramebuffer returns GL_FALSE.<br>
*
*
*
*/
#define glIsFramebuffer glad_glIsFramebuffer
GLAD_API_CALL PFNGLISPROGRAMPROC glad_glIsProgram;
/**
* @name glIsProgram - Determines if a name corresponds to a program object
* @usage
* @code GLboolean glIsProgram(GLuint program); @endcode
* @param program Specifies a potential program object.
* @description
* 	glIsProgram returns GL_TRUE if program is the name of a program object previously created with glCreateProgram and not
* yet deleted with glDeleteProgram. If program is zero or a non-zero value that is not the name of a program object, or if
* an error occurs, glIsProgram returns GL_FALSE.<br>
*
* @note No error is generated if program is not a valid program object name.
* @note A program object marked for deletion with glDeleteProgram but still in use as part of current rendering state is still considered
*       a program object and glIsProgram will return GL_TRUE.
*
*
*/
#define glIsProgram glad_glIsProgram
GLAD_API_CALL PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;
/**
* @name glIsProgramPipeline - determine if a name corresponds to a program pipeline object
* @usage
* @code GLboolean glIsProgramPipeline(GLuint pipeline); @endcode
* @param pipeline Specifies a value that may be the name of a program pipeline object.
* @description
* 	glIsProgramPipeline returns GL_TRUE if pipeline is currently the name of a program pipeline object. If pipeline is zero,
* or if pipeline is not the name of a program pipeline object, or if an error occurs, glIsProgramPipeline returns GL_FALSE.
* If pipeline is a name returned by glGenProgramPipelines, but that has not yet been bound through a call to glBindProgramPipeline,
* then the name is not a program pipeline object and glIsProgramPipeline returns GL_FALSE.<br>
*
*
*
*/
#define glIsProgramPipeline glad_glIsProgramPipeline
GLAD_API_CALL PFNGLISQUERYPROC glad_glIsQuery;
/**
* @name glIsQuery - determine if a name corresponds to a query object
* @usage
* @code GLboolean glIsQuery(GLuint id); @endcode
* @param id Specifies a value that may be the name of a query object.
* @description
* 	glIsQuery returns GL_TRUE if id is currently the name of a query object. If id is zero, or is a non-zero value that is
* not currently the name of a query object, or if an error occurs, glIsQuery returns GL_FALSE.<br>
* 	A name returned by glGenQueries, but not yet associated with a query object by calling glBeginQuery, is not the name of
* a query object.<br>
*
*
*
*/
#define glIsQuery glad_glIsQuery
GLAD_API_CALL PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
/**
* @name glIsRenderbuffer - determine if a name corresponds to a renderbuffer object
* @usage
* @code GLboolean glIsRenderbuffer(GLuint renderbuffer); @endcode
* @param renderbuffer Specifies a value that may be the name of a renderbuffer object.
* @description
* 	glIsRenderbuffer returns GL_TRUE if renderbuffer is currently the name of a renderbuffer object. If renderbuffer is zero,
* or if renderbuffer is not the name of a renderbuffer object, or if an error occurs, glIsRenderbuffer returns GL_FALSE.
* If renderbuffer is a name returned by glGenRenderbuffers, by that has not yet been bound through a call to glBindRenderbuffer
* or glFramebufferRenderbuffer, then the name is not a renderbuffer object and glIsRenderbuffer returns GL_FALSE.<br>
*
*
*
*/
#define glIsRenderbuffer glad_glIsRenderbuffer
GLAD_API_CALL PFNGLISSAMPLERPROC glad_glIsSampler;
/**
* @name glIsSampler - determine if a name corresponds to a sampler object
* @usage
* @code GLboolean glIsSampler(GLuint id); @endcode
* @param id Specifies a value that may be the name of a sampler object.
* @description
* 	glIsSampler returns GL_TRUE if id is currently the name of a sampler object. If id is zero, or is a non-zero value that
* is not currently the name of a sampler object, or if an error occurs, glIsSampler returns GL_FALSE.<br>
* 	A name returned by glGenSamplers, is the name of a sampler object.<br>
*
* @note glIsSampler is available only if the GL version is 3.3 or higher.
*
*
*/
#define glIsSampler glad_glIsSampler
GLAD_API_CALL PFNGLISSHADERPROC glad_glIsShader;
/**
* @name glIsShader - Determines if a name corresponds to a shader object
* @usage
* @code GLboolean glIsShader(GLuint shader); @endcode
* @param shader Specifies a potential shader object.
* @description
* 	glIsShader returns GL_TRUE if shader is the name of a shader object previously created with glCreateShader and not yet
* deleted with glDeleteShader. If shader is zero or a non-zero value that is not the name of a shader object, or if an error
* occurs, glIsShader  returns GL_FALSE.<br>
*
* @note No error is generated if shader is not a valid shader object name.
* @note A shader object marked for deletion with glDeleteShader but still attached to a program object is still considered a shader
*       object and glIsShader will return GL_TRUE.
*
*
*/
#define glIsShader glad_glIsShader
GLAD_API_CALL PFNGLISSYNCPROC glad_glIsSync;
/**
* @name glIsSync - determine if a name corresponds to a sync object
* @usage
* @code GLboolean glIsSync(GLsync sync); @endcode
* @param sync Specifies a value that may be the name of a sync object.
* @description
* 	glIsSync returns GL_TRUE if sync is currently the name of a sync object. If sync is not the name of a sync object, or if
* an error occurs, glIsSync returns GL_FALSE. Note that zero is not the name of a sync object.<br>
*
* @note glIsSync is available only if the GL version is 3.2 or greater.
*
*
*/
#define glIsSync glad_glIsSync
GLAD_API_CALL PFNGLISTEXTUREPROC glad_glIsTexture;
/**
* @name glIsTexture - determine if a name corresponds to a texture
* @usage
* @code GLboolean glIsTexture(GLuint texture); @endcode
* @param texture Specifies a value that may be the name of a texture.
* @description
* 	glIsTexture returns GL_TRUE if texture is currently the name of a texture. If texture is zero, or is a non-zero value that
* is not currently the name of a texture, or if an error occurs, glIsTexture returns GL_FALSE.<br>
* 	A name returned by glGenTextures, but not yet associated with a texture by calling glBindTexture, is not the name of a
* texture.<br>
*
*
*
*/
#define glIsTexture glad_glIsTexture
GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;
/**
* @name glIsTransformFeedback - determine if a name corresponds to a transform feedback object
* @usage
* @code GLboolean glIsTransformFeedback(GLuint id); @endcode
* @param id Specifies a value that may be the name of a transform feedback object.
* @description
* 	glIsTransformFeedback returns GL_TRUE if id is currently the name of a transform feedback object. If id is zero, or if
* id is not the name of a transform feedback object, or if an error occurs, glIsTransformFeedback returns GL_FALSE. If id
* is a name returned by glGenTransformFeedbacks, but that has not yet been bound through a call to glBindTransformFeedback,
* then the name is not a transform feedback object and glIsTransformFeedback returns GL_FALSE.<br>
*
*
*
*/
#define glIsTransformFeedback glad_glIsTransformFeedback
GLAD_API_CALL PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
/**
* @name glIsVertexArray - determine if a name corresponds to a vertex array object
* @usage
* @code GLboolean glIsVertexArray(GLuint array); @endcode
* @param array Specifies a value that may be the name of a vertex array object.
* @description
* 	glIsVertexArray returns GL_TRUE if array is currently the name of a vertex array object. If array is zero, or if array
* is not the name of a vertex array object, or if an error occurs, glIsVertexArray returns GL_FALSE. If array is a name returned
* by glGenVertexArrays, by that has not yet been bound through a call to glBindVertexArray, then the name is not a
* vertex array object and glIsVertexArray returns GL_FALSE.<br>
*
*
*
*/
#define glIsVertexArray glad_glIsVertexArray
GLAD_API_CALL PFNGLLINEWIDTHPROC glad_glLineWidth;
/**
* @name glLineWidth - specify the width of rasterized lines
* @usage
* @code void glLineWidth(GLfloat width); @endcode
* @param width Specifies the width of rasterized lines. The initial value is 1.
* @description
* 	glLineWidth specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different
* effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call glEnable
* and  glDisable with argument GL_LINE_SMOOTH. Line antialiasing is initially disabled.<br>
* 	If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer.
* (If the rounding results in the value 0, it is as if the line width were 1.) If Δx >= Δy , i pixels are filled in each
* column that is rasterized, where i is the rounded value of width. Otherwise, i pixels are filled in each row that is rasterized.<br>
* 	If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying
* within the rectangle having width equal to the current line width, length equal to the actual length of the line, and
* centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection
* of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization
* step.<br>
* 	Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported
* width is used. Only width 1 is guaranteed to be supported; others depend on the implementation.  Likewise, there
* is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported
* widths within the range, call glGet with arguments GL_ALIASED_LINE_WIDTH_RANGE, GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY.<br>
*
* @note The line width specified by glLineWidth is always returned when GL_LINE_WIDTH is queried. Clamping and rounding for aliased
*       and antialiased lines have no effect on the specified value.
* @note Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call glGet with GL_ALIASED_LINE_WIDTH_RANGE
*       to determine the maximum width.
* @note In OpenGL 1.2, the tokens GL_LINE_WIDTH_RANGE and GL_LINE_WIDTH_GRANULARITY were replaced by GL_ALIASED_LINE_WIDTH_RANGE,
*       GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY.  The old names are retained for backward compatibility,
*       but should not be used in new code.
*
* @errors GL_INVALID_VALUE is generated if width is less than or equal to 0.
*
*/
#define glLineWidth glad_glLineWidth
GLAD_API_CALL PFNGLLINKPROGRAMPROC glad_glLinkProgram;
/**
* @name glLinkProgram - Links a program object
* @usage
* @code void glLinkProgram(GLuint program); @endcode
* @param program Specifies the handle of the program object to be linked.
* @description
* 	glLinkProgram links the program object specified by program. If any shader objects of type GL_VERTEX_SHADER are attached
* to program, they will be used to create an executable that will run on the programmable vertex processor. If any shader
* objects of type GL_GEOMETRY_SHADER are attached to program, they will be used to create an executable that will run on
* the programmable geometry processor. If any shader objects of type GL_FRAGMENT_SHADER are attached to program, they will
* be used to create an executable that will run on the programmable fragment processor.<br>
* 	The status of the link operation will be stored as part of the program object's state. This value will be set to GL_TRUE
* if the program object was linked without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling
* glGetProgram with arguments program and GL_LINK_STATUS.<br>
* 	As a result of a successful link operation, all active user-defined uniform variables belonging to program will be initialized
* to 0, and each of the program object's active uniform variables will be assigned a location that can be queried
* by calling glGetUniformLocation. Also, any active user-defined attribute variables that have not been bound to a generic
* vertex attribute index will be bound to one at this time.<br>
* 	Linking of a program object can fail for a number of reasons as specified in the OpenGL Shading Language Specification.
* The following lists some of the conditions that will cause a link error.<br>
* 	The number of active attribute variables supported by the implementation has been exceeded.<br>
* 	The storage limit for uniform variables has been exceeded.<br>
* 	The number of active uniform variables supported by the implementation has been exceeded.<br>
* 	The main function is missing for the vertex, geometry or fragment shader.<br>
* 	A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in
* the vertex shader, or geometry shader if present.<br>
* 	A reference to a function or variable name is unresolved.<br>
* 	A shared global is declared with two different types or two different initial values.<br>
* 	One or more of the attached shader objects has not been successfully compiled.<br>
* 	Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of GL_MAX_VERTEX_ATTRIBS.<br>
* 	Not enough contiguous vertex attribute slots could be found to bind attribute matrices.<br>
* 	The program object contains objects to form a fragment shader but does not contain objects to form a vertex shader.<br>
* 	The program object contains objects to form a geometry shader but does not contain objects to form a vertex shader.<br>
* 	The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum
* output vertex count is not specified in any compiled geometry shader object.<br>
* 	The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum
* output vertex count is specified differently in multiple geometry shader objects.<br>
* 	The number of active outputs in the fragment shader is greater than the value of GL_MAX_DRAW_BUFFERS.<br>
* 	The program has an active output assigned to a location greater than or equal to the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
* and has an active output assigned an index greater than or equal to one.<br>
* 	More than one varying out variable is bound to the same number and index.<br>
* 	The explicit binding assigments do not leave enough space for the linker to automatically assign a location for a varying
* out array, which requires multiple contiguous locations.<br>
* 	The count specified by glTransformFeedbackVaryings is non-zero, but the program object has no vertex or geometry shader.<br>
* 	Any variable name specified to glTransformFeedbackVaryings in the varyings array is not declared as an output in the vertex
* shader (or the geometry shader, if active).<br>
* 	Any two entries in the varyings array given glTransformFeedbackVaryings specify the same varying variable.<br>
* 	The total number of components to capture in any transform feedback varying variable is  greater  than  the  constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
* and the buffer mode is GL_SEPARATE_ATTRIBS.<br>
* 	When a program object has been successfully linked, the program object can be made part of current state by calling glUseProgram.
* Whether or not the link operation was successful, the program object's information log will be overwritten. The
* information log can be retrieved by calling glGetProgramInfoLog.<br>
* 	glLinkProgram will also install the generated executables as part of the current rendering state if the link operation
* was successful and the specified program object is already currently in use as a result of a previous call to glUseProgram.
* If the program object currently in use is relinked unsuccessfully, its link status will be set to GL_FALSE , but the
* executables and associated state will remain part of the current state until a subsequent call to glUseProgram removes
* it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.<br>
* 	If program contains shader objects of type GL_VERTEX_SHADER, and optionally of type GL_GEOMETRY_SHADER, but does not contain
* shader objects of type GL_FRAGMENT_SHADER, the vertex shader executable will be installed on the programmable vertex
* processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but
* no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will
* be undefined.<br>
* 	The program object's information log is updated and the program is generated at the time of the link operation. After the
* link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader
* objects, delete shader objects, and attach additional shader objects. None of these operations affects the information
* log or the program that is part of the program object.<br>
*
* @note If the link operation is unsuccessful, any information about a previous link operation on program is lost (i.e., a failed
*       link does not restore the old state of program ). Certain information can still be retrieved from program even after an
*       unsuccessful link operation. See for instance glGetActiveAttrib and glGetActiveUniform.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program is the currently active program object and transform feedback mode is active.
*
*/
#define glLinkProgram glad_glLinkProgram
GLAD_API_CALL PFNGLLOGICOPPROC glad_glLogicOp;
/**
* @name glLogicOp - specify a logical pixel operation for rendering
* @usage
* @code void glLogicOp(GLenum opcode); @endcode
* @param opcode Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: <b>GL_CLEAR</b>, <b>GL_SET</b>,
*               <b>GL_COPY</b>, <b>GL_COPY_INVERTED</b>, <b>GL_NOOP</b>, <b>GL_INVERT</b>, <b>GL_AND</b>, <b>GL_NAND</b>, <b>GL_OR</b>,
*               <b>GL_NOR</b>, <b>GL_XOR</b>, <b>GL_EQUIV</b>, <b>GL_AND_REVERSE</b>, <b>GL_AND_INVERTED</b>, <b>GL_OR_REVERSE</b>,
*               and <b>GL_OR_INVERTED</b>. The initial value is <b>GL_COPY</b>.
* @description
* 	glLogicOp specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color
* at the corresponding location in the frame buffer. To enable or disable the logical operation, call glEnable and  glDisable
* using the symbolic constant GL_COLOR_LOGIC_OP. The initial value is disabled.<br>
* 	opcode is a symbolic constant chosen from the list above. In the explanation of the logical operations, s represents the
* incoming color and d represents the color in the frame buffer. Standard C-language operators are used. As these bitwise
* operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.<br>
*
* @note When more than one RGBA color buffer is enabled for drawing, logical operations are performed separately for each enabled
*       buffer, using for the destination value the contents of that buffer (see glDrawBuffer).
* @note Logic operations have no effect on floating point draw buffers. However, if GL_COLOR_LOGIC_OP is enabled, blending is still
*       disabled in this case.
*
* @errors GL_INVALID_ENUM is generated if opcode is not an accepted value.
*
*/
#define glLogicOp glad_glLogicOp
GLAD_API_CALL PFNGLMAPBUFFERPROC glad_glMapBuffer;
/**
* @name glMapBuffer, glMapNamedBuffer - map all of a buffer object's data store into the client's address space
* @usage
* @code void *glMapBuffer(GLenum target, GLenum access); @endcode
* @code void *glMapNamedBuffer(GLuint buffer, GLenum access); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glMapBuffer</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glMapNamedBuffer</b>.
* @param access Specifies the access policy for <b>glMapBuffer</b> and <b>glMapNamedBuffer</b>, indicating whether it will be possible to
*               read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must
*               be <b>GL_READ_ONLY</b>, <b>GL_WRITE_ONLY</b>, or <b>GL_READ_WRITE</b>.
* @description
* 	glMapBuffer and glMapNamedBuffer map the entire data store of a specified buffer object into the client's address space.
* The data can then be directly read and/or written relative to the returned pointer, depending on the specified access
* policy.<br>
* 	A pointer to the beginning of the mapped range is returned once all pending operations on that buffer object have completed,
* and may be used to modify and/or query the corresponding range of the data store according to the value of access:<br>
* 	GL_READ_ONLY indicates that the returned pointer may be used to read buffer object data.<br>
* 	GL_WRITE_ONLY indicates that the returned pointer may be used to modify buffer object data.<br>
* 	GL_READ_WRITE indicates that the returned pointer may be used to read and to modify buffer object data.<br>
* 	If an error is generated, a NULL pointer is returned.<br>
* 	If no error occurs, the returned pointer will reflect an allocation aligned to the value of GL_MIN_MAP_BUFFER_ALIGNMENT
* basic machine units.<br>
* 	The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to
* specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although
* implementations may not check for such behavior for performance reasons.<br>
* 	No GL error is generated if the returned pointer is accessed in a way inconsistent with access (e.g. used to read from
* a mapping made with accessGL_WRITE_ONLY or write to a mapping made with accessGL_READ_ONLY), but the result is undefined
* and system errors (possibly including program termination) may occur.<br>
* 	Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings
* may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal
* performance, the client should use the mapping in a fashion consistent with the values of GL_BUFFER_USAGE for the buffer
* object and of access. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of
* magnitude slower than using normal memory.<br>
*
* @note Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the GL_ATOMIC_COUNTER_BUFFER
*       target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glMapBuffer if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glMapBuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glMapNamedBuffer if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if access is not GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to map the buffer object's data store. This may occur for a variety of
*         system-specific reasons, such as the absence of sufficient remaining virtual memory.
* @errors GL_INVALID_OPERATION is generated if the buffer object is in a mapped state.
*
*/
#define glMapBuffer glad_glMapBuffer
GLAD_API_CALL PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
/**
* @name glMapBufferRange, glMapNamedBufferRange - map all or part of a buffer object's data store into the client's address space
* @usage
* @code void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access); @endcode
* @code void *glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glMapBufferRange</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glMapNamedBufferRange</b>.
* @param offset Specifies the starting offset within the buffer of the range to be mapped.
* @param length Specifies the length of the range to be mapped.
* @param access Specifies a combination of access flags indicating the desired access to the mapped range.
* @description
* 	glMapBufferRange and glMapNamedBufferRange map all or part of the data store of a specified buffer object into the client's
* address space. offset and length indicate the range of data in the buffer object that is to be mapped, in terms of
* basic machine units. access is a bitfield containing flags which describe the requested mapping. These flags are described
* below.<br>
* 	A pointer to the beginning of the mapped range is returned once all pending operations on the buffer object have completed,
* and may be used to modify and/or query the corresponding range of the data store according to the following flag bits
* set in access:<br>
* 	GL_MAP_READ_BIT indicates that the returned pointer may be used to read buffer object data. No GL error is generated if
* the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly
* including program termination) may occur.<br>
* 	GL_MAP_WRITE_BIT indicates that the returned pointer may be used to modify buffer object data. No GL error is generated
* if the pointer is used to modify a mapping which excludes this flag, but the result is undefined and system errors (possibly
* including program termination) may occur.<br>
* 	GL_MAP_PERSISTENT_BIT indicates that the mapping is to be made in a persistent fashion and that the client intends to hold
* and use the returned pointer during subsequent GL operation. It is not an error to call drawing commands (render) while
* buffers are mapped using this flag. It is an error to specify this flag if the buffer's data store was not allocated
* through a call to the glBufferStorage command in which the GL_MAP_PERSISTENT_BIT was also set.<br>
* 	GL_MAP_COHERENT_BIT indicates that a persistent mapping is also to be coherent. Coherent maps guarantee that the effect
* of writes to a buffer's data store by either the client or server will eventually become visible to the other without further
* intervention from the application. In the absence of this bit, persistent mappings are not coherent and modified
* ranges of the buffer store must be explicitly communicated to the GL, either by unmapping the buffer, or through a call
* to glFlushMappedBufferRange or glMemoryBarrier.<br>
* 	The following optional flag bits in access may be used to modify the mapping:<br>
* 	GL_MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the specified range may be discarded. Data within this
* range are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations
* access unwritten data, but the result is undefined and system errors (possibly including program termination) may
* occur. This flag may not be used in combination with GL_MAP_READ_BIT.<br>
* 	GL_MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the entire buffer may be discarded. Data within the
* entire buffer are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL
* operations access unwritten data, but the result is undefined and system errors (possibly including program termination)
* may occur. This flag may not be used in combination with GL_MAP_READ_BIT.<br>
* 	GL_MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges of the mapping may be modified. When this flag
* is set, modifications to each subrange must be explicitly flushed by calling glFlushMappedBufferRange. No GL error is set
* if a subrange of the mapping is modified and not flushed, but data within the corresponding subrange of the buffer are
* undefined. This flag may only be used in conjunction with GL_MAP_WRITE_BIT. When this option is selected, flushing is strictly
* limited to regions that are explicitly indicated with calls to glFlushMappedBufferRange prior to unmap; if this
* option is not selected glUnmapBuffer will automatically flush the entire mapped range when called.<br>
* 	GL_MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to synchronize pending operations on the buffer prior
* to returning from glMapBufferRange or glMapNamedBufferRange. No GL error is generated if pending operations which source
* or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.<br>
* 	If an error occurs, a NULL pointer is returned.<br>
* 	If no error occurs, the returned pointer will reflect an allocation aligned to the value of GL_MIN_MAP_BUFFER_ALIGNMENT
* basic machine units. Subtracting offset from this returned pointer will always produce a multiple of the value of GL_MIN_MAP_BUFFER_ALIGNMENT.<br>
* 	The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to
* specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although
* implementations may not check for such behavior for performance reasons.<br>
* 	Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings
* may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal
* performance, the client should use the mapping in a fashion consistent with the values of GL_BUFFER_USAGE for the buffer
* object and of access. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of
* magnitude slower than using normal memory.<br>
*
* @note Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the GL_ATOMIC_COUNTER_BUFFER
*       target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are accepted only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
* @note The GL_MAP_PERSISTENT_BIT and GL_MAP_COHERENT_BIT flags are available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glMapBufferRange if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glMapBufferRange if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glMapNamedBufferRange if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or length is negative, if $offset + length$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object, or if access has any bits set other than those defined above.
* @errors GL_INVALID_OPERATION is generated for any of the following conditions:
* @errors length is zero.
* @errors The buffer object is already in a mapped state.
* @errors Neither GL_MAP_READ_BIT nor GL_MAP_WRITE_BIT is set.
* @errors GL_MAP_READ_BIT is set and any of GL_MAP_INVALIDATE_RANGE_BIT, GL_MAP_INVALIDATE_BUFFER_BIT or GL_MAP_UNSYNCHRONIZED_BIT
*         is set.
* @errors GL_MAP_FLUSH_EXPLICIT_BIT is set and GL_MAP_WRITE_BIT is not set.
* @errors Any of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, or GL_MAP_COHERENT_BIT are set, but the same bit is not
*         included in the buffer's storage flags.
* @errors No error is generated if memory outside the mapped range is modified or queried, but the result is undefined and system
*         errors (possibly including program termination) may occur.
*
*/
#define glMapBufferRange glad_glMapBufferRange
GLAD_API_CALL PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;
// Unable to find the docs for this function!
#define glMapNamedBuffer glad_glMapNamedBuffer
GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;
// Unable to find the docs for this function!
#define glMapNamedBufferRange glad_glMapNamedBufferRange
GLAD_API_CALL PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;
/**
* @name glMemoryBarrier - defines a barrier ordering memory transactions
* @usage
* @code void glMemoryBarrier(GLbitfield barriers); @endcode
* @code void glMemoryBarrierByRegion(GLbitfield barriers); @endcode
* @param barriers Specifies the barriers to insert.
* @description
* 	glMemoryBarrier defines a barrier ordering the memory transactions issued prior to the command relative to those issued
* after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued
* by the rendering command that triggered the execution of the shader. barriers is a bitfield indicating the set of operations
* that are synchronized with shader stores; the bits used in barriers are as follows:<br>
* 	If set, vertex data sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.
*  The set of buffer objects affected by this bit is derived from the buffer object bindings used for generic vertex
* attributes derived from the GL_VERTEX_ATTRIB_ARRAY_BUFFER bindings.<br>
* 	If set, vertex array indices sourced from buffer objects after the barrier will reflect data written by shaders prior to
* the barrier.  The buffer objects affected by this bit are derived from the GL_ELEMENT_ARRAY_BUFFER binding.<br>
* 	Shader uniforms sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.<br>
* 	Texture fetches from shaders, including fetches from buffer object memory via buffer textures, after the barrier will reflect
* data written by shaders prior to the barrier.<br>
* 	Memory accesses using shader image load, store, and atomic built-in functions issued after the barrier will reflect data
* written by shaders prior to the barrier. Additionally, image stores and atomics issued after the barrier will not execute
* until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.<br>
* 	Command data sourced from buffer objects by Draw*Indirect commands after the barrier will reflect data written by shaders
* prior to the barrier.  The buffer objects affected by this bit are derived from the GL_DRAW_INDIRECT_BUFFER binding.<br>
* 	Reads and writes of buffer objects via the GL_PIXEL_PACK_BUFFER and GL_PIXEL_UNPACK_BUFFER bindings (via glReadPixels,
* glTexSubImage1D, etc.) after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer
* object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.<br>
* 	Writes to a texture via glTex(Sub)Image*, glCopyTex(Sub)Image*, glCompressedTex(Sub)Image*, and reads via glGetTexImage
* after the barrier will reflect data written by shaders prior to the barrier.  Additionally, texture writes from these commands
* issued after the barrier will not execute until all shader writes initiated prior to the barrier complete.<br>
* 	Reads or writes via glBufferSubData, glCopyBufferSubData, or glGetBufferSubData, or to buffer object memory mapped by glMapBuffer
* or glMapBufferRange after the barrier will reflect data written by shaders prior to the barrier. Additionally,
* writes via these commands issued after the barrier will wait on the completion of any shader writes to the same memory
* initiated prior to the barrier.<br>
* 	Access by the client to persistent mapped regions of buffer objects will reflect data written by shaders prior to the barrier.
* Note that this may cause additional synchronization operations.<br>
* 	Reads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the
* barrier.  Additionally, framebuffer writes issued after the barrier will wait on the completion of all shader writes issued
* prior to the barrier.<br>
* 	Writes via transform feedback bindings after the barrier will reflect data written by shaders prior to the barrier.  Additionally,
* transform feedback writes issued after the barrier will wait on the completion of all shader writes issued prior
* to the barrier.<br>
* 	Accesses to atomic counters after the barrier will reflect writes prior to the barrier.<br>
* 	Accesses to shader storage blocks after the barrier will reflect writes prior to the barrier.<br>
* 	Writes of buffer objects via the GL_QUERY_BUFFER binding after the barrier will reflect data written by shaders prior to
* the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes
* initiated prior to the barrier.<br>
* 	If barriers is GL_ALL_BARRIER_BITS, shader memory accesses will be synchronized relative to all the operations described
* above.<br>
* 	Implementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for
* example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses.
*  Implementations are not required to keep these caches coherent with shader memory writes.  Stores issued by one invocation
* may not be immediately observable by other pipeline stages or other shader invocations because the value stored may
* remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache
* elsewhere in the system. When glMemoryBarrier is called, the GL flushes and/or invalidates any caches relevant to the
* operations specified by the barriers parameter to ensure consistent ordering of operations across the barrier.<br>
* 	To allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables
* in the OpenGL Shading Language may be declared as "coherent".  Buffer object or texture image memory accessed through
* such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation.
* If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared
* as coherent will observe the results stored using coherent variables in other invocations.  Using variables declared
* as "coherent" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared
* variables; calling glMemoryBarrier is required to ensure that the stores are visible to other operations.<br>
* 	The following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers.<br>
* 	Data that are read-only or constant may be accessed without using coherent variables or calling MemoryBarrier(). Updates
* to the read-only data via API calls such as glBufferSubData will invalidate shader caches implicitly as required.<br>
* 	Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another
* invocation) should use coherent variables to read and write the shared data.<br>
* 	Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution ("dependent
* invocations") should use coherent variables in the producing shader invocation and call memoryBarrier() after
* the last write. The consuming shader invocation should also use coherent variables.<br>
* 	Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables
* or memoryBarrier(). Calling glMemoryBarrier with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in barriers between passes
* is necessary.<br>
* 	Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in
* a later pass need not use coherent variables or memoryBarrier(). Calling glMemoryBarrier with the appropriate bits set
* in barriers between passes is necessary.<br>
*
* @note GL_SHADER_STORAGE_BARRIER_BIT is available only if the GL version is 4.3 or higher.
* @note GL_QUERY_BUFFER_BARRIER_BIT is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if barriers is not the special value GL_ALL_BARRIER_BITS, and has any bits set other than
*         those described above for glMemoryBarrier or glMemoryBarrierByRegion respectively.
*
*/
#define glMemoryBarrier glad_glMemoryBarrier
GLAD_API_CALL PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;
/**
* @name glMemoryBarrier - defines a barrier ordering memory transactions
* @usage
* @code void glMemoryBarrier(GLbitfield barriers); @endcode
* @code void glMemoryBarrierByRegion(GLbitfield barriers); @endcode
* @param barriers Specifies the barriers to insert.
* @description
* 	glMemoryBarrier defines a barrier ordering the memory transactions issued prior to the command relative to those issued
* after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued
* by the rendering command that triggered the execution of the shader. barriers is a bitfield indicating the set of operations
* that are synchronized with shader stores; the bits used in barriers are as follows:<br>
* 	If set, vertex data sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.
*  The set of buffer objects affected by this bit is derived from the buffer object bindings used for generic vertex
* attributes derived from the GL_VERTEX_ATTRIB_ARRAY_BUFFER bindings.<br>
* 	If set, vertex array indices sourced from buffer objects after the barrier will reflect data written by shaders prior to
* the barrier.  The buffer objects affected by this bit are derived from the GL_ELEMENT_ARRAY_BUFFER binding.<br>
* 	Shader uniforms sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.<br>
* 	Texture fetches from shaders, including fetches from buffer object memory via buffer textures, after the barrier will reflect
* data written by shaders prior to the barrier.<br>
* 	Memory accesses using shader image load, store, and atomic built-in functions issued after the barrier will reflect data
* written by shaders prior to the barrier. Additionally, image stores and atomics issued after the barrier will not execute
* until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.<br>
* 	Command data sourced from buffer objects by Draw*Indirect commands after the barrier will reflect data written by shaders
* prior to the barrier.  The buffer objects affected by this bit are derived from the GL_DRAW_INDIRECT_BUFFER binding.<br>
* 	Reads and writes of buffer objects via the GL_PIXEL_PACK_BUFFER and GL_PIXEL_UNPACK_BUFFER bindings (via glReadPixels,
* glTexSubImage1D, etc.) after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer
* object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.<br>
* 	Writes to a texture via glTex(Sub)Image*, glCopyTex(Sub)Image*, glCompressedTex(Sub)Image*, and reads via glGetTexImage
* after the barrier will reflect data written by shaders prior to the barrier.  Additionally, texture writes from these commands
* issued after the barrier will not execute until all shader writes initiated prior to the barrier complete.<br>
* 	Reads or writes via glBufferSubData, glCopyBufferSubData, or glGetBufferSubData, or to buffer object memory mapped by glMapBuffer
* or glMapBufferRange after the barrier will reflect data written by shaders prior to the barrier. Additionally,
* writes via these commands issued after the barrier will wait on the completion of any shader writes to the same memory
* initiated prior to the barrier.<br>
* 	Access by the client to persistent mapped regions of buffer objects will reflect data written by shaders prior to the barrier.
* Note that this may cause additional synchronization operations.<br>
* 	Reads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the
* barrier.  Additionally, framebuffer writes issued after the barrier will wait on the completion of all shader writes issued
* prior to the barrier.<br>
* 	Writes via transform feedback bindings after the barrier will reflect data written by shaders prior to the barrier.  Additionally,
* transform feedback writes issued after the barrier will wait on the completion of all shader writes issued prior
* to the barrier.<br>
* 	Accesses to atomic counters after the barrier will reflect writes prior to the barrier.<br>
* 	Accesses to shader storage blocks after the barrier will reflect writes prior to the barrier.<br>
* 	Writes of buffer objects via the GL_QUERY_BUFFER binding after the barrier will reflect data written by shaders prior to
* the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes
* initiated prior to the barrier.<br>
* 	If barriers is GL_ALL_BARRIER_BITS, shader memory accesses will be synchronized relative to all the operations described
* above.<br>
* 	Implementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for
* example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses.
*  Implementations are not required to keep these caches coherent with shader memory writes.  Stores issued by one invocation
* may not be immediately observable by other pipeline stages or other shader invocations because the value stored may
* remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache
* elsewhere in the system. When glMemoryBarrier is called, the GL flushes and/or invalidates any caches relevant to the
* operations specified by the barriers parameter to ensure consistent ordering of operations across the barrier.<br>
* 	To allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables
* in the OpenGL Shading Language may be declared as "coherent".  Buffer object or texture image memory accessed through
* such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation.
* If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared
* as coherent will observe the results stored using coherent variables in other invocations.  Using variables declared
* as "coherent" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared
* variables; calling glMemoryBarrier is required to ensure that the stores are visible to other operations.<br>
* 	The following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers.<br>
* 	Data that are read-only or constant may be accessed without using coherent variables or calling MemoryBarrier(). Updates
* to the read-only data via API calls such as glBufferSubData will invalidate shader caches implicitly as required.<br>
* 	Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another
* invocation) should use coherent variables to read and write the shared data.<br>
* 	Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution ("dependent
* invocations") should use coherent variables in the producing shader invocation and call memoryBarrier() after
* the last write. The consuming shader invocation should also use coherent variables.<br>
* 	Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables
* or memoryBarrier(). Calling glMemoryBarrier with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in barriers between passes
* is necessary.<br>
* 	Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in
* a later pass need not use coherent variables or memoryBarrier(). Calling glMemoryBarrier with the appropriate bits set
* in barriers between passes is necessary.<br>
*
* @note GL_SHADER_STORAGE_BARRIER_BIT is available only if the GL version is 4.3 or higher.
* @note GL_QUERY_BUFFER_BARRIER_BIT is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if barriers is not the special value GL_ALL_BARRIER_BITS, and has any bits set other than
*         those described above for glMemoryBarrier or glMemoryBarrierByRegion respectively.
*
*/
#define glMemoryBarrierByRegion glad_glMemoryBarrierByRegion
GLAD_API_CALL PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;
/**
* @name glMinSampleShading - specifies minimum rate at which sample shading takes place
* @usage
* @code void glMinSampleShading(GLfloat value); @endcode
* @param value Specifies the rate at which samples are shaded within each covered pixel.
* @description
* 	glMinSampleShading specifies the rate at which samples are shaded within a covered pixel. Sample-rate shading is enabled
* by calling glEnable with the parameter GL_SAMPLE_SHADING. If GL_MULTISAMPLE or GL_SAMPLE_SHADING is disabled, sample shading
* has no effect. Otherwise, an implementation must provide at least as many unique color values for each covered fragment
* as specified by value times samples where samples is the value of GL_SAMPLES for the current framebuffer. At least
* 1 sample for each covered fragment is generated.<br>
* 	A value of 1.0 indicates that each sample in the framebuffer should be independently shaded. A value of 0.0 effectively
* allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset of the
* total samples within each covered fragment. Which samples are shaded and the algorithm used to select that subset of the
* fragment's samples is implementation dependent.<br>
*
* @note The type of the value parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described
*       in detail on the removedTypes page.
*
* @errors None.
*
*/
#define glMinSampleShading glad_glMinSampleShading
GLAD_API_CALL PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
/**
* @name glMultiDrawArrays - render multiple sets of primitives from array data
* @usage
* @code void glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param first Points to an array of starting indices in the enabled arrays.
* @param count Points to an array of the number of indices to be rendered.
* @param drawcount Specifies the size of the first and count
* @description
* 	glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a
* GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate
* arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to glMultiDrawArrays.<br>
* 	glMultiDrawArrays behaves identically to glDrawArrays except that drawcount separate ranges of elements are specified instead.<br>
* 	When glMultiDrawArrays is called, it uses count sequential elements from each enabled array to construct a sequence of
* geometric primitives, beginning with element first. mode specifies what kind of primitives are constructed, and how the
* array elements construct those primitives.<br>
* 	Vertex attributes that are modified by glMultiDrawArrays have an unspecified value after glMultiDrawArrays returns. Attributes
* that aren't modified remain well defined.<br>
*
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glMultiDrawArrays glad_glMultiDrawArrays
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;
/**
* @name glMultiDrawArraysIndirect - render multiple sets of primitives from array data, taking parameters from memory
* @usage
* @code void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param indirect Specifies the address of an array of structures containing the draw parameters.
* @param drawcount Specifies the number of elements in the array of draw parameter structures.
* @param stride Specifies the distance in basic machine units between elements of the draw parameter array.
* @description
* 	glMultiDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls. glMultiDrawArraysIndirect
* behaves similarly to a multitude of calls to glDrawArraysInstancedBaseInstance, execept that the parameters to each
* call to glDrawArraysInstancedBaseInstance are stored in an array in memory at the address given by indirect, separated
* by the stride, in basic machine units, specified by stride. If stride is zero, then the array is assumed to be tightly packed
* in memory.<br>
* 	The parameters addressed by indirect are packed into an array of structures, each element of which takes the form (in C):<br>
* 	A single call to glMultiDrawArraysIndirect is equivalent, assuming no errors are generated to:<br>
* 	If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time of a call to glMultiDrawArraysIndirect, indirect
* is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather
* than from client memory.<br>
* 	In contrast to glDrawArraysInstancedBaseInstance, the first member of the parameter structure is unsigned, and out-of-range
* indices do not generate an error.<br>
* 	Vertex attributes that are modified by glMultiDrawArraysIndirect have an unspecified value after glMultiDrawArraysIndirect
* returns. Attributes that aren't modified remain well defined.<br>
*
* @note The baseInstance member of the DrawArraysIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions
*       of the GL, behavior is undefined if it is non-zero.
* @note glMultiDrawArraysIndirect is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is not a multiple of four.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glMultiDrawArraysIndirect glad_glMultiDrawArraysIndirect
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount;
// Unable to find the docs for this function!
#define glMultiDrawArraysIndirectCount glad_glMultiDrawArraysIndirectCount
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
/**
* @name glMultiDrawElements - render multiple sets of primitives by specifying indices of array data elements
* @usage
* @code void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Points to an array of the elements counts.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param drawcount Specifies the size of the <em class="parameter"><b>count</b></em> and <em class="parameter"><b>indices</b></em> arrays.
* @description
* 	glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling
* a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate
* arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to glMultiDrawElements.<br>
* 	glMultiDrawElements is identical in operation to glDrawElements except that drawcount separate lists of elements are specified.<br>
* 	Vertex attributes that are modified by glMultiDrawElements have an unspecified value after glMultiDrawElements returns.
* Attributes that aren't modified maintain their previous values.<br>
*
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glMultiDrawElements glad_glMultiDrawElements
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
/**
* @name glMultiDrawElementsBaseVertex - render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
* @usage
* @code void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const void * const *indices, GLsizei drawcount, const GLint *basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Points to an array of the elements counts.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param drawcount Specifies the size of the <em class="parameter"><b>count</b></em>, <em class="parameter"><b>indices</b></em> and <em class="parameter"><b>basevertex</b></em>
*                  arrays.
* @param basevertex Specifies a pointer to the location where the base vertices are stored.
* @description
* 	glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount separate lists of
* elements are specifried instead.<br>
* 	It has the same effect as:<br>
*
* @note glMultiDrawElementsBaseVertex is available only if the GL version is 3.1 or greater.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glMultiDrawElementsBaseVertex glad_glMultiDrawElementsBaseVertex
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;
/**
* @name glMultiDrawElementsIndirect - render indexed primitives from array data, taking parameters from memory
* @usage
* @code void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param type Specifies the type of data in the buffer bound to the <b>GL_ELEMENT_ARRAY_BUFFER</b> binding.
* @param indirect Specifies the address of a structure containing an array of draw parameters.
* @param drawcount Specifies the number of elements in the array addressed by <em class="parameter"><b>indirect</b></em>.
* @param stride Specifies the distance in basic machine units between elements of the draw parameter array.
* @description
* 	glMultiDrawElementsIndirect specifies multiple indexed geometric primitives with very few subroutine calls. glMultiDrawElementsIndirect
* behaves similarly to a multitude of calls to glDrawElementsInstancedBaseVertexBaseInstance, execpt that
* the parameters to glDrawElementsInstancedBaseVertexBaseInstance are stored in an array in memory at the address given by
* indirect, separated by the stride, in basic machine units, specified by stride. If stride is zero, then the array is assumed
* to be tightly packed in memory.<br>
* 	The parameters addressed by indirect are packed into a structure that takes the form (in C):<br>
* 	A single call to glMultiDrawElementsIndirect is equivalent, assuming no errors are generated to:<br>
* 	If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time of a call to glDrawElementsIndirect, indirect is
* interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather
* than from client memory.<br>
* 	Note that indices stored in client memory are not supported. If no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding,
* an error will be generated.<br>
* 	The results of the operation are undefined if the reservedMustBeZero member of the parameter structure is non-zero. However,
* no error is generated in this case.<br>
* 	Vertex attributes that are modified by glDrawElementsIndirect have an unspecified value after glDrawElementsIndirect returns.
* Attributes that aren't modified remain well defined.<br>
*
* @note The baseInstance member of the DrawElementsIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier
*       versions of the GL, behavior is undefined if it is non-zero.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is not a multiple of four.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data
*         store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glMultiDrawElementsIndirect glad_glMultiDrawElementsIndirect
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount;
// Unable to find the docs for this function!
#define glMultiDrawElementsIndirectCount glad_glMultiDrawElementsIndirectCount
GLAD_API_CALL PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;
/**
* @name glBufferData, glNamedBufferData - creates and initializes a buffer object's data
store
* @usage
* @code void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage); @endcode
* @code void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferData</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param usage Specifies the expected usage pattern of the data store. The symbolic constant must be <b>GL_STREAM_DRAW</b>, <b>GL_STREAM_READ</b>,
*              <b>GL_STREAM_COPY</b>, <b>GL_STATIC_DRAW</b>, <b>GL_STATIC_READ</b>, <b>GL_STATIC_COPY</b>, <b>GL_DYNAMIC_DRAW</b>,
*              <b>GL_DYNAMIC_READ</b>, or <b>GL_DYNAMIC_COPY</b>.
* @description
* 	glBufferData and glNamedBufferData create a new data store for a buffer object. In case of glBufferData, the buffer object
* currently bound to target is used. For glNamedBufferData, a buffer object associated with ID specified by the caller
* in buffer will be used instead.<br>
* 	While creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified
* size in bytes and usage. If data is not NULL, the data store is initialized with data from this pointer. In its initial
* state, the new data store is not mapped, it has a NULL mapped pointer, and its mapped access is GL_READ_WRITE.<br>
* 	usage is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation
* to make more intelligent decisions that may significantly impact buffer object performance. It does not, however,
* constrain the actual usage of the data store. usage can be broken down into two parts: first, the frequency of access
* (modification and usage), and second, the nature of that access. The frequency of access may be one of these:<br>
* 	The data store contents will be modified once and used at most a few times.<br>
* 	The data store contents will be modified once and used many times.<br>
* 	The data store contents will be modified repeatedly and used many times.<br>
* 	The nature of access may be one of these:<br>
* 	The data store contents are modified by the application, and used as the source for GL drawing and image specification
* commands.<br>
* 	The data store contents are modified by reading data from the GL, and used to return that data when queried by the application.<br>
* 	The data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification
* commands.<br>
*
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
* @note Clients must align data elements consistently with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ,
*         GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
* @errors GL_INVALID_VALUE is generated if size is negative.
* @errors GL_INVALID_OPERATION is generated by glBufferData if the reserved buffer object name 0 is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size.
*
*/
#define glNamedBufferData glad_glNamedBufferData
GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;
/**
* @name glBufferStorage, glNamedBufferStorage - creates and initializes a buffer object's immutable data
store
* @usage
* @code void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags); @endcode
* @code void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferStorage</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferStorage</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param flags Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. <b>GL_DYNAMIC_STORAGE_BIT</b>,
*              <b>GL_MAP_READ_BIT</b>
<b>GL_MAP_WRITE_BIT</b>, <b>GL_MAP_PERSISTENT_BIT</b>, <b>GL_MAP_COHERENT_BIT</b>,
*              and <b>GL_CLIENT_STORAGE_BIT</b>.
* @description
* 	glBufferStorage and glNamedBufferStorage create a new immutable data store. For glBufferStorage, the buffer object currently
* bound to target will be initialized. For glNamedBufferStorage, buffer is the name of the buffer object that will be
* configured. The size of the data store is specified by size. If an initial data is available, its address may be supplied
* in data. Otherwise, to create an uninitialized data store, data should be NULL.<br>
* 	The flags parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset
* of the following flags:<br>
* 	The contents of the data store may be updated after creation through calls to glBufferSubData. If this bit is not set,
* the buffer content may not be directly updated by the client. The data argument may be used to specify the initial content
* of the buffer's data store regardless of the presence of the GL_DYNAMIC_STORAGE_BIT. Regardless of the presence of this
* bit, buffers may always be updated with server-side calls such as glCopyBufferSubData and glClearBufferSubData.<br>
* 	The data store may be mapped by the client for read access and a pointer in the client's address space obtained that may
* be read from.<br>
* 	The data store may be mapped by the client for write access and a pointer in the client's address space obtained that may
* be written through.<br>
* 	The client may request that the server read from or write to the buffer while it is mapped. The client's pointer to the
* data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.<br>
* 	Shared access to buffers that are simultaneously mapped for client access and are used by the server will be coherent,
* so long as that mapping is performed using glMapBufferRange. That is, data written to the store by either the client or
* server will be immediately visible to the other with no further action taken by the application. In particular,<br>
* 	If GL_MAP_COHERENT_BIT is not set and the client performs a write followed by a call to the glMemoryBarrier command with
* the GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT set, then in subsequent commands the server will see the writes.<br>
* 	If GL_MAP_COHERENT_BIT is set and the client performs a write, then in subsequent commands the server will see the writes.<br>
* 	If GL_MAP_COHERENT_BIT is not set and the server performs a write, the application must call glMemoryBarrier with the GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT
* set and then call glFenceSync with GL_SYNC_GPU_COMMANDS_COMPLETE (or glFinish). Then
* the CPU will see the writes after the sync is complete.<br>
* 	If GL_MAP_COHERENT_BIT is set and the server does a write, the app must call glFenceSync with GL_SYNC_GPU_COMMANDS_COMPLETE
* (or glFinish). Then the CPU will see the writes after the sync is complete.<br>
* 	When all other criteria for the buffer storage allocation are met, this bit may be used by an implementation to determine
* whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.<br>
* 	The allowed combinations of flags are subject to certain restrictions. They are as follows:<br>
* 	If flags contains GL_MAP_PERSISTENT_BIT, it must also contain at least one of GL_MAP_READ_BIT or GL_MAP_WRITE_BIT.<br>
* 	If flags contains GL_MAP_COHERENT_BIT, it must also contain GL_MAP_PERSISTENT_BIT.<br>
*
* @note glBufferStorage is available only if the GL version is 4.4 or greater.
* @note glNamedBufferStorage is available only if the GL version is 4.5 or greater.
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
*
* @errors GL_INVALID_ENUM is generated by glBufferStorage if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferStorage if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if size is less than or equal to zero.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the reserved buffer object name 0 is bound to target.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the properties requested in flags.
* @errors GL_INVALID_VALUE is generated if flags has any bits set other than those defined above.
* @errors GL_INVALID_VALUE error is generated if flags contains GL_MAP_PERSISTENT_BIT but does not contain at least one of GL_MAP_READ_BIT
*         or GL_MAP_WRITE_BIT.
* @errors GL_INVALID_VALUE is generated if flags contains GL_MAP_COHERENT_BIT, but does not also contain GL_MAP_PERSISTENT_BIT.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer bound to target
*         is GL_TRUE.
*
*/
#define glNamedBufferStorage glad_glNamedBufferStorage
GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;
/**
* @name glBufferSubData, glNamedBufferSubData - updates a subset of a buffer object's data store
* @usage
* @code void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data); @endcode
* @code void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferSubData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
* @param size Specifies the size in bytes of the data store region being replaced.
* @param data Specifies a pointer to the new data that will be copied into the data store.
* @description
* 	glBufferSubData and glNamedBufferSubData redefine some or all of the data store for the specified buffer object. Data starting
* at byte offset offset and extending for size bytes is copied to the data store from the memory pointed to by data.
* offset and size must define a range lying entirely within the buffer object's data store.<br>
*
* @note When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with
*       glBufferData. This avoids the cost of reallocating the data store.
* @note Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering
*       in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific
*       region being updated, that rendering must drain from the pipeline before the data store can be updated.
* @note Clients must align data elements consistent with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferSubData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the specified buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and
*         the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set.
*
*/
#define glNamedBufferSubData glad_glNamedBufferSubData
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;
/**
* @name glDrawBuffer, glNamedFramebufferDrawBuffer - specify which color buffers are to be drawn into
* @usage
* @code void glDrawBuffer(GLenum buf); @endcode
* @code void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffer</b> function. Must be zero or the name
*                    of a framebuffer object.
* @param buf For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants <b>GL_NONE</b>,
*            <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>, <b>GL_FRONT</b>, <b>GL_BACK</b>,
*            <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and <b>GL_FRONT_AND_BACK</b> are accepted. The initial value is <b>GL_FRONT</b>
*            for single-buffered contexts, and <b>GL_BACK</b> for double-buffered contexts. For framebuffer objects, <b>GL_COLOR_ATTACHMENT$m$</b>
*            and <b>GL_NONE</b> enums are accepted, where <b>$m$</b> is a value between 0 and <b>GL_MAX_COLOR_ATTACHMENTS</b>.
* @description
* 	When colors are written to the frame buffer, they are written into the color buffers specified by glDrawBuffer. One of
* the following values can be used for default framebuffer:<br>
* 	No color buffers are written.<br>
* 	Only the front left color buffer is written.<br>
* 	Only the front right color buffer is written.<br>
* 	Only the back left color buffer is written.<br>
* 	Only the back right color buffer is written.<br>
* 	Only the front left and front right color buffers are written. If there is no front right color buffer, only the front
* left color buffer is written.<br>
* 	Only the back left and back right color buffers are written. If there is no back right color buffer, only the back left
* color buffer is written.<br>
* 	Only the front left and back left color buffers are written. If there is no back left color buffer, only the front left
* color buffer is written.<br>
* 	Only the front right and back right color buffers are written. If there is no back right color buffer, only the front right
* color buffer is written.<br>
* 	All the front and back color buffers (front left, front right, back left, back right) are written. If there are no back
* color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only
* the front left and back left color buffers are written. If there are no right or back color buffers, only the front left
* color buffer is written.<br>
* 	If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently
* for each color buffer and can produce different results in each buffer.<br>
* 	Monoscopic contexts include only left buffers, and stereoscopic contexts include both left and right buffers. Likewise,
* single-buffered contexts include only front buffers, and double-buffered contexts include both front and back buffers.
* The context is selected at GL initialization.<br>
* 	For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
* glDrawBuffer will set the draw buffer for fragment colors other than zero to GL_NONE.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if buf is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if the default framebuffer is affected and none of the buffers indicated by buf exists.
* @errors GL_INVALID_OPERATION is generated if a framebuffer object is affected and buf is not equal to GL_NONE or GL_COLOR_ATTACHMENT$m$,
*         where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glNamedFramebufferDrawBuffer glad_glNamedFramebufferDrawBuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;
/**
* @name glDrawBuffers, glNamedFramebufferDrawBuffers - Specifies a list of color buffers to be drawn
into
* @usage
* @code void glDrawBuffers(GLsizei n, const GLenum *bufs); @endcode
* @code void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffers</b>.
* @param n Specifies the number of buffers in <em class="parameter"><b>bufs</b></em>.
* @param bufs Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
* @description
* 	glDrawBuffers and glNamedFramebufferDrawBuffers define an array of buffers into which outputs from the fragment shader
* data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of
* each variable will be written into the buffer specified at a location within bufs corresponding to the location assigned
* to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal
* to n is implicitly set to GL_NONE and any data written to such an output is discarded.<br>
* 	For glDrawBuffers, the framebuffer object that is bound to the GL_DRAW_FRAMEBUFFER binding will be used. For glNamedFramebufferDrawBuffers,
* framebuffer is the name of the framebuffer object. If framebuffer is zero, then the default framebuffer
* is affected.<br>
* 	The symbolic constants contained in bufs may be any of the following:<br>
* 	The fragment shader output value is not written into any color buffer.<br>
* 	The fragment shader output value is written into the front left color buffer.<br>
* 	The fragment shader output value is written into the front right color buffer.<br>
* 	The fragment shader output value is written into the back left color buffer.<br>
* 	The fragment shader output value is written into the back right color buffer.<br>
* 	The fragment shader output value is written into the nth color attachment of the current framebuffer. n may range from
* zero to the value of GL_MAX_COLOR_ATTACHMENTS.<br>
* 	Except for GL_NONE, the preceding symbolic constants may not appear more than once in bufs. The maximum number of draw
* buffers supported is implementation dependent and can be queried by calling glGet with the argument GL_MAX_DRAW_BUFFERS.<br>
*
* @note The symbolic constants GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are not allowed in the bufs array since
*       they may refer to multiple buffers.
* @note If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader
*       execution are undefined. For each fragment generated in this situation, a different value may be written into each of
*       the buffers specified by bufs.
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffers if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if one of the values in bufs is not an accepted value.
* @errors GL_INVALID_ENUM is generated if the API call refers to the default framebuffer and one or more of the values in bufs is
*         one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if the API call refers to a framebuffer object and one or more of the values in bufs is anything
*         other than GL_NONE or one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if n is less than 0.
* @errors GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
* @errors GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does
*         not exist in the current GL context.
* @errors GL_INVALID_OPERATION is generated if any value in bufs is GL_BACK, and n is not one.
* @errors GL_INVALID_VALUE is generated if n is greater than GL_MAX_DRAW_BUFFERS.
*
*/
#define glNamedFramebufferDrawBuffers glad_glNamedFramebufferDrawBuffers
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;
/**
* @name glFramebufferParameteri, glNamedFramebufferParameteri - set a named parameter of a framebuffer object
* @usage
* @code void glFramebufferParameteri(GLenum target, GLenum pname, GLint param); @endcode
* @code void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferParameteri</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferParameteri</b>.
* @param pname Specifies the framebuffer parameter to be modified.
* @param param The new value for the parameter named <em class="parameter"><b>pname</b></em>.
* @description
* 	glFramebufferParameteri and glNamedFramebufferParameteri modify the value of the parameter named pname in the specified
* framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid
* targets of these commands.<br>
* 	For glFramebufferParameteri, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferParameteri, framebuffer is the name of the framebuffer object.<br>
* 	pname specifies the parameter to be modified. The following values are accepted:<br>
* 	param specifies the assumed with for a framebuffer object with no attachments. If a framebuffer has attachments then the
* width of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_WIDTH is used for the framebuffer. param
* must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_WIDTH.<br>
* 	param specifies the assumed height for a framebuffer object with no attachments. If a framebuffer has attachments then
* the height of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_HEIGHT is used for the framebuffer.
* param must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_HEIGHT.<br>
* 	param specifies the assumed number of layers for a framebuffer object with no attachments. If a framebuffer has attachments
* then the layer count of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_LAYERS is used for
* the framebuffer. param must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_LAYERS.<br>
* 	param specifies the assumed number of samples in a framebuffer object with no attachments. If a framebuffer has attachments
* then the sample count of those attachments is used, otherwise the value of GL_FRAMEBUFFER_DEFAULT_SAMPLES is used for
* the framebuffer. param must be greater than or equal to zero and less than or equal to the value of GL_MAX_FRAMEBUFFER_SAMPLE.<br>
* 	param specifies whether the framebuffer should assume identical sample locations and the same number of samples for all
* texels in the virtual image. If param is zero, then the implementation may vary the position or the count of samples within
* the virtual image from pixel to pixel, otherwise it will use the same sample position and count for all pixels in the
* virtual image.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glFramebufferParameteri if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferParameteri if the default framebuffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferParameteri if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_WIDTH and param is less than zero or greater than the value
*         of GL_MAX_FRAMEBUFFER_WIDTH.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_HEIGHT and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_HEIGHT.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_LAYERS and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_LAYERS.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_SAMPLES and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_SAMPLES.
*
*/
#define glNamedFramebufferParameteri glad_glNamedFramebufferParameteri
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;
/**
* @name glReadBuffer, glNamedFramebufferReadBuffer - select a color buffer source for pixels
* @usage
* @code void glReadBuffer(GLenum mode); @endcode
* @code void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferReadBuffer</b> function.
* @param mode Specifies a color buffer. Accepted values are <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>,
*             <b>GL_FRONT</b>, <b>GL_BACK</b>, <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and the constants <b>GL_COLOR_ATTACHMENT</b><span
*             class="emphasis"><em>i</em></span>.
* @description
* 	glReadBuffer specifies a color buffer as the source for subsequent glReadPixels, glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D,
* glCopyTexSubImage2D, and glCopyTexSubImage3D commands. mode accepts one of twelve or more predefined
* values. In a fully configured system, GL_FRONT, GL_LEFT, and GL_FRONT_LEFT all name the front left buffer, GL_FRONT_RIGHT
* and GL_RIGHT name the front right buffer, and GL_BACK_LEFT and GL_BACK name the back left buffer. Further more, the constants
* GL_COLOR_ATTACHMENTi may be used to indicate the ith color attachment where i ranges from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one.<br>
* 	Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations
* have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify
* a nonexistent buffer to glReadBuffer.<br>
* 	mode is initially GL_FRONT in single-buffered configurations and GL_BACK in double-buffered configurations.<br>
* 	For glReadBuffer, the target framebuffer object is that bound to GL_READ_FRAMEBUFFER. For glNamedFramebufferReadBuffer,
* framebuffer must either be zero or the name of the target framebuffer object. If framebuffer is zero, then the default
* read framebuffer is affected.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values.
* @errors GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferReadBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glNamedFramebufferReadBuffer glad_glNamedFramebufferReadBuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;
/**
* @name glFramebufferRenderbuffer, glNamedFramebufferRenderbuffer - attach a renderbuffer as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @code void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferRenderbuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferRenderbuffer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param renderbuffertarget Specifies the renderbuffer target. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of an existing renderbuffer object of type <em class="parameter"><b>renderbuffertarget</b></em> to attach.
* @description
* 	glFramebufferRenderbuffer and glNamedFramebufferRenderbuffer attaches a renderbuffer as one of the logical buffers of the
* specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are
* not valid targets of these commands.<br>
* 	For glFramebufferRenderbuffer, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferRenderbuffer, framebuffer is the name of the framebuffer object.<br>
* 	renderbuffertarget must be GL_RENDERBUFFER.<br>
* 	renderbuffer must be zero or the name of an existing renderbuffer object of type renderbuffertarget. If renderbuffer is
* not zero, then the specified renderbuffer will be used as the logical buffer identified by attachment of the specified
* framebuffer object. If renderbuffer is zero, then the value of renderbuffertarget is ignored.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS minus
* one. Setting attachment to the value GL_DEPTH_STENCIL_ATTACHMENT is a special case causing both the depth and stencil
* attachments of the specified framebuffer object to be set to renderbuffer, which should have the base internal format
* GL_DEPTH_STENCIL.<br>
* 	The value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the specified attachment point is set to GL_RENDERBUFFER and the
* value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to renderbuffer. All other state values of specified attachment point
* are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment
* to the attachment logical buffer of the specified framebuffer object is broken.<br>
* 	If renderbuffer is zero, these commands will detach the image, if any, identified by the specified attachment point of
* the specified framebuffer object. All state values of the attachment point are set to their default values.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glFramebufferRenderbuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferRenderbuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferRenderbuffer if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated if renderbuffertarget is not zero or the name of an existing renderbuffer object of type
*         GL_RENDERBUFFER.
*
*/
#define glNamedFramebufferRenderbuffer glad_glNamedFramebufferRenderbuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @description
* 	These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified
* framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets
* of these commands.<br>
* 	For all commands exceptglNamedFramebufferTexture, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER,
* GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTexture, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, textarget specifies what type of texture
* is named by texture, and for cube map textures, specifies the face that is to be attached. If texture is not zero, it must
* be the name of an existing texture object with effective target textarget unless it is a cube map texture, in which
* case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If texture is non-zero, the specified level of the texture object named texture is attached to the framebuffer attachment
* point named by attachment. For glFramebufferTexture1D, glFramebufferTexture2D, and glFramebufferTexture3D, texture must
* be zero or the name of an existing texture with an effective target of textarget, or texture must be the name of an existing
* cube-map texture and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.<br>
* 	If textarget is GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then level must be
* zero.<br>
* 	If textarget is GL_TEXTURE_3D, then level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater
* than or equal to zero and less than or equal to $log_2$ of the value of GL_MAX_CUBE_MAP_TEXTURE_SIZE.<br>
* 	For all other values of textarget, level must be greater than or equal to zero and less than or equal to $log_2$ of the
* value of GL_MAX_TEXTURE_SIZE.<br>
* 	layer specifies the layer of a 2-dimensional image within a 3-dimensional texture.<br>
* 	For glFramebufferTexture1D, if texture is not zero, then textarget must be GL_TEXTURE_1D. For glFramebufferTexture2D, if
* texture is not zero, textarget must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
* GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
* GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D, if texture is not zero, then
* textarget must be GL_TEXTURE_3D.<br>
* 	For glFramebufferTexture and glNamedFramebufferTexture, if texture is the name of a three-dimensional, cube map array,
* cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an
* array of images, and the framebuffer attachment is considered to be layered.<br>
*
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glNamedFramebufferTexture glad_glNamedFramebufferTexture
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;
/**
* @name glFramebufferTextureLayer, glNamedFramebufferTextureLayer - attach a single layer of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferTextureLayer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTextureLayer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @param layer Specifies the layer of the texture object to attach.
* @description
* 	glFramebufferTextureLayer and glNamedFramebufferTextureLayer attach a single layer of a three-dimensional or array texture
* object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default
* draw and read framebuffer, so they are not valid targets of these commands.<br>
* 	For glFramebufferTextureLayer, the framebuffer object is that bound to target, which must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER,
* or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.<br>
* 	For glNamedFramebufferTextureLayer, framebuffer is the name of the framebuffer object.<br>
* 	attachment specifies the logical attachment of the framebuffer and must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT
* or GL_DEPTH_STENCIL_ATTACHMENT. i in GL_COLOR_ATTACHMENTi may range from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one. Attaching a level of a texture to GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching
* that level to both the GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT attachment points simultaneously.<br>
* 	If texture is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional
* array, or cube map array texture.<br>
* 	If texture is a three-dimensional texture, then level must be greater than or equal to zero and less than or equal to $log_2$
* of the value of GL_MAX_3D_TEXTURE_SIZE.<br>
* 	If texture is a two-dimensional array texture, then level must be greater than or equal to zero and less than or equal
* to $log_2$ of the value of GL_MAX_TEXTURE_SIZE.<br>
* 	For cube map textures, layer is translated into a cube map face according to $$ face = k \bmod 6. $$ For cube map array
* textures, layer is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$
* and $$ face = k \bmod 6. $$<br>
*
*
* @errors GL_INVALID_ENUM is generated by glFramebufferTexture if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferTexture if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_OPERATION is generated if texture is not zero and is not the name of an existing three-dimensional, two-dimensional
*         multisample array, one- or two-dimensional array, cube map, or cube map array texture.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture, as described
*         above.
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE minus
*         one (for three-dimensional texture objects), or larger than the value of GL_MAX_ARRAY_TEXTURE_LAYERS minus one (for array
*         texture objects).
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is negative.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glNamedFramebufferTextureLayer glad_glNamedFramebufferTextureLayer
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;
/**
* @name glRenderbufferStorage, glNamedRenderbufferStorage - establish data storage, format and dimensions of a
renderbuffer object's image
* @usage
* @code void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorage</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorage</b> function.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
* @description
* 	glRenderbufferStorage is equivalent to calling glRenderbufferStorageMultisample with the samples set to zero, and glNamedRenderbufferStorage
* is equivalent to calling glNamedRenderbufferStorageMultisample with the samples set to zero.<br>
* 	For glRenderbufferStorage, the target of the operation, specified by target must be GL_RENDERBUFFER. For glNamedRenderbufferStorage,
* renderbuffer must be a name of an existing renderbuffer object. internalformat specifies the internal format
* to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable
* format. width and height are the dimensions, in pixels, of the renderbuffer. Both width and height must be less than
* or equal to the value of GL_MAX_RENDERBUFFER_SIZE.<br>
* 	Upon success, glRenderbufferStorage and glNamedRenderbufferStorage delete any existing data store for the renderbuffer
* image and the contents of the data store after calling glRenderbufferStorage are undefined.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorage if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorage if renderbuffer is not the name of an existing renderbuffer
*         object.
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glNamedRenderbufferStorage glad_glNamedRenderbufferStorage
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;
/**
* @name glRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample - establish data storage, format, dimensions and sample count of
a renderbuffer object's image
* @usage
* @code void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorageMultisample</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorageMultisample</b> function.
* @param samples Specifies the number of samples to be used for the renderbuffer object's storage.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
* @description
* 	glRenderbufferStorageMultisample and glNamedRenderbufferStorageMultisample establish the data storage, format, dimensions
* and number of samples of a renderbuffer object's image.<br>
* 	For glRenderbufferStorageMultisample, the target of the operation, specified by target must be GL_RENDERBUFFER. For glNamedRenderbufferStorageMultisample,
* renderbuffer must be an ID of an existing renderbuffer object. internalformat specifies
* the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable,
* or stencil-renderable format. width and height are the dimensions, in pixels, of the renderbuffer. Both width and height
* must be less than or equal to the value of GL_MAX_RENDERBUFFER_SIZE. samples specifies the number of samples to be used
* for the renderbuffer object's image, and must be less than or equal to the value of GL_MAX_SAMPLES. If internalformat
* is a signed or unsigned integer format then samples must be less than or equal to the value of GL_MAX_INTEGER_SAMPLES.<br>
* 	Upon success, glRenderbufferStorageMultisample and glNamedRenderbufferStorageMultisample delete any existing data store
* for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorageMultisample function if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorageMultisample function if renderbuffer is not the name of an
*         existing renderbuffer object.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for internalformat.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glNamedRenderbufferStorageMultisample glad_glNamedRenderbufferStorageMultisample
GLAD_API_CALL PFNGLOBJECTLABELPROC glad_glObjectLabel;
/**
* @name glObjectLabel - label a named object identified within a namespace
* @usage
* @code void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label); @endcode
* @param identifier The namespace from which the name of the object is allocated.
* @param name The name of the object to label.
* @param length The length of the label to be used for the object.
* @param label The address of a string containing the label to assign to the object.
* @description
* 	glObjectLabel labels the object identified by name within the namespace given by identifier. identifier must be one of
* GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY, GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE,
* GL_RENDERBUFFER, GL_FRAMEBUFFER, to indicate the namespace containing the names of buffers, shaders, programs,
* vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
* frame buffers, respectively.<br>
* 	label is the address of a string that will be used to label an object. length contains the number of characters in label.
* If length is negative, it is implied that label contains a null-terminated string. If label is NULL, any debug label
* is effectively removed from the object.<br>
*
*
* @errors GL_INVALID_ENUM is generated if identifier is not one of the accepted object types.
* @errors GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier.
* @errors GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative,
*         is greater than the value of GL_MAX_LABEL_LENGTH.
*
*/
#define glObjectLabel glad_glObjectLabel
GLAD_API_CALL PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;
/**
* @name glObjectPtrLabel - label a sync object identified by a pointer
* @usage
* @code void glObjectPtrLabel(void * ptr, GLsizei length, const char * label); @endcode
* @param ptr A pointer identifying a sync object.
* @param length The length of the label to be used for the object.
* @param label The address of a string containing the label to assign to the object.
* @description
* 	glObjectPtrLabel labels the sync object identified by ptr.<br>
* 	label is the address of a string that will be used to label the object. length contains the number of characters in label.
* If length is negative, it is implied that label contains a null-terminated string. If label is NULL, any debug label
* is effectively removed from the object.<br>
*
*
* @errors GL_INVALID_VALUE is generated if ptr is not a valid sync object.
* @errors GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative,
*         is greater than the value of GL_MAX_LABEL_LENGTH.
*
*/
#define glObjectPtrLabel glad_glObjectPtrLabel
GLAD_API_CALL PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;
// Unable to find the docs for this function!
#define glPatchParameterfv glad_glPatchParameterfv
GLAD_API_CALL PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;
// Unable to find the docs for this function!
#define glPatchParameteri glad_glPatchParameteri
GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;
/**
* @name glPauseTransformFeedback - pause transform feedback operations
* @usage
* @code void glPauseTransformFeedback(void); @endcode
* @description
* 	glPauseTransformFeedback pauses transform feedback operations on the currently active transform feedback object. When transform
* feedback operations are paused, transform feedback is still considered active and changing most transform feedback
* state related to the object results in an error. However, a new transform feedback object may be bound while transform
* feedback is paused.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is paused.
*
*/
#define glPauseTransformFeedback glad_glPauseTransformFeedback
GLAD_API_CALL PFNGLPIXELSTOREFPROC glad_glPixelStoref;
// Unable to find the docs for this function!
#define glPixelStoref glad_glPixelStoref
GLAD_API_CALL PFNGLPIXELSTOREIPROC glad_glPixelStorei;
// Unable to find the docs for this function!
#define glPixelStorei glad_glPixelStorei
GLAD_API_CALL PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
// Unable to find the docs for this function!
#define glPointParameterf glad_glPointParameterf
GLAD_API_CALL PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
// Unable to find the docs for this function!
#define glPointParameterfv glad_glPointParameterfv
GLAD_API_CALL PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
// Unable to find the docs for this function!
#define glPointParameteri glad_glPointParameteri
GLAD_API_CALL PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
// Unable to find the docs for this function!
#define glPointParameteriv glad_glPointParameteriv
GLAD_API_CALL PFNGLPOINTSIZEPROC glad_glPointSize;
/**
* @name glPointSize - specify the diameter of rasterized points
* @usage
* @code void glPointSize(GLfloat size); @endcode
* @param size Specifies the diameter of rasterized points. The initial value is 1.
* @description
* 	glPointSize specifies the rasterized diameter of points. If point size mode is disabled (see glEnable with parameter GL_PROGRAM_POINT_SIZE),
* this value will be used to rasterize points. Otherwise, the value written to the shading language
* built-in variable gl_PointSize will be used.<br>
*
* @note The point size specified by glPointSize is always returned when GL_POINT_SIZE is queried.  Clamping and rounding for points
*       have no effect on the specified value.
*
* @errors GL_INVALID_VALUE is generated if size is less than or equal to 0.
*
*/
#define glPointSize glad_glPointSize
GLAD_API_CALL PFNGLPOLYGONMODEPROC glad_glPolygonMode;
/**
* @name glPolygonMode - select a polygon rasterization mode
* @usage
* @code void glPolygonMode(GLenum face, GLenum mode); @endcode
* @param face Specifies the polygons that <em class="parameter"><b>mode</b></em> applies to. Must be <b>GL_FRONT_AND_BACK</b> for front-
*             and back-facing polygons.
* @param mode Specifies how polygons will be rasterized. Accepted values are <b>GL_POINT</b>, <b>GL_LINE</b>, and <b>GL_FILL</b>. The
*             initial value is <b>GL_FILL</b> for both front- and back-facing polygons.
* @description
* 	glPolygonMode controls the interpretation of polygons for rasterization. face describes which polygons mode applies to:
* both front and back-facing polygons (GL_FRONT_AND_BACK). The polygon mode affects only the final rasterization of polygons.
* In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.<br>
* 	Three modes are defined and can be specified in mode:<br>
* 	Polygon vertices that are marked as the start of a boundary edge are drawn as points. Point attributes such as GL_POINT_SIZE
* and GL_POINT_SMOOTH control the rasterization of the points. Polygon rasterization attributes other than GL_POLYGON_MODE
* have no effect.<br>
* 	Boundary edges of the polygon are drawn as line segments. Line attributes such as GL_LINE_WIDTH and GL_LINE_SMOOTH control
* the rasterization of the lines. Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.<br>
* 	The interior of the polygon is filled. Polygon attributes such as GL_POLYGON_SMOOTH control the rasterization of the polygon.<br>
*
* @note Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it
*       decomposes triangle stips and fans.
*
* @errors GL_INVALID_ENUM is generated if either face or mode is not an accepted value.
*
*/
#define glPolygonMode glad_glPolygonMode
GLAD_API_CALL PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
/**
* @name glPolygonOffset - set the scale and units used to calculate depth values
* @usage
* @code void glPolygonOffset(GLfloat factor, GLfloat units); @endcode
* @param factor Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
* @param units Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
* @description
* 	When GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, or GL_POLYGON_OFFSET_POINT is enabled, each fragment's depth value
* will be offset after it is interpolated from the depth values of the appropriate vertices. The value of the offset is factor×DZ
* + r×units , where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r
* is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added
* before the depth test is performed and before the value is written into the depth buffer.<br>
* 	glPolygonOffset is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with
* highlighted edges.<br>
*
*
*
*/
#define glPolygonOffset glad_glPolygonOffset
GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;
// Unable to find the docs for this function!
#define glPolygonOffsetClamp glad_glPolygonOffsetClamp
GLAD_API_CALL PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;
/**
* @name glPopDebugGroup - pop the active debug group
* @usage
* @code void glPopDebugGroup(void); @endcode
* @description
* 	glPopDebugGroup pops the active debug group. After popping a debug group, the GL will also generate a debug output message
* describing its cause based on the message string, the source source, and an ID id submitted to the corresponding glPushDebugGroup
* command. GL_DEBUG_TYPE_PUSH_GROUP and GL_DEBUG_TYPE_POP_GROUP share a single namespace for message id. severity
* has the value GL_DEBUG_SEVERITY_NOTIFICATION. The type has the value GL_DEBUG_TYPE_POP_GROUP. Popping a debug group
* restores the debug output volume control of the parent debug group.<br>
*
*
* @errors GL_STACK_UNDERFLOW is generated if an attempt is made to pop the default debug group from the stack.
*
*/
#define glPopDebugGroup glad_glPopDebugGroup
GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
/**
* @name glPrimitiveRestartIndex - specify the primitive restart index
* @usage
* @code void glPrimitiveRestartIndex(GLuint index); @endcode
* @param index Specifies the value to be interpreted as the primitive restart index.
* @description
* 	glPrimitiveRestartIndex specifies a vertex array element that is treated specially when primitive restarting is enabled.
* This is known as the primitive restart index.<br>
* 	When one of the Draw* commands transfers a set of generic attribute array elements to the GL, if the index within the vertex
* arrays corresponding to that set is equal to the primitive restart index, then the GL does not process those elements
* as a vertex. Instead, it is as if the drawing command ended with the immediately preceding transfer, and another drawing
* command is immediately started with the same parameters, but only transferring the immediately following element through
* the end of the originally specified elements.<br>
* 	When either glDrawElementsBaseVertex, glDrawElementsInstancedBaseVertex or glMultiDrawElementsBaseVertex is used, the primitive
* restart comparison occurs before the basevertex offset is added to the array index.<br>
*
* @note glPrimitiveRestartIndex is available only if the GL version is 3.1 or greater.
*
*
*/
#define glPrimitiveRestartIndex glad_glPrimitiveRestartIndex
GLAD_API_CALL PFNGLPROGRAMBINARYPROC glad_glProgramBinary;
/**
* @name glProgramBinary - load a program object with a program binary
* @usage
* @code void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length); @endcode
* @param program Specifies the name of a program object into which to load a program binary.
* @param binaryFormat Specifies the format of the binary data in binary.
* @param binary Specifies the address an array containing the binary to be loaded into <em class="parameter"><b>program</b></em>.
* @param length Specifies the number of bytes contained in <em class="parameter"><b>binary</b></em>.
* @description
* 	glProgramBinary loads a program object with a program binary previously returned from glGetProgramBinary. binaryFormat
* and binary must be those returned by a previous call to glGetProgramBinary, and length must be the length returned by glGetProgramBinary,
* or by glGetProgram when called with pname set to GL_PROGRAM_BINARY_LENGTH. If these conditions are not
* met, loading the program binary will fail and program's GL_LINK_STATUS will be set to GL_FALSE.<br>
* 	A program object's program binary is replaced by calls to glLinkProgram or glProgramBinary. When linking success or failure
* is concerned, glProgramBinary can be considered to perform an implicit linking operation. glLinkProgram and glProgramBinary
* both set the program object's GL_LINK_STATUS to GL_TRUE or GL_FALSE.<br>
* 	A successful call to glProgramBinary will reset all uniform variables to their initial values. The initial value is either
* the value of the variable's initializer as specified in the original shader source, or zero if no initializer was present.
* Additionally, all vertex shader input and fragment shader output assignments that were in effect when the program
* was linked before saving are restored with glProgramBinary is called.<br>
*
* @note A program binary may fail to load if the implementation determines that there has been a change in hardware or software
*       configuration from when the program binary was produced such as having been compiled with an incompatible or outdated version
*       of the compiler.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of an existing program object.
* @errors GL_INVALID_ENUM is generated if binaryFormat is not a value recognized by the implementation.
*
*/
#define glProgramBinary glad_glProgramBinary
GLAD_API_CALL PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;
// Unable to find the docs for this function!
#define glProgramParameteri glad_glProgramParameteri
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1d glad_glProgramUniform1d
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1dv glad_glProgramUniform1dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1f glad_glProgramUniform1f
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1fv glad_glProgramUniform1fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1i glad_glProgramUniform1i
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1iv glad_glProgramUniform1iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1ui glad_glProgramUniform1ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1uiv glad_glProgramUniform1uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2d glad_glProgramUniform2d
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2dv glad_glProgramUniform2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2f glad_glProgramUniform2f
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2fv glad_glProgramUniform2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2i glad_glProgramUniform2i
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2iv glad_glProgramUniform2iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2ui glad_glProgramUniform2ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2uiv glad_glProgramUniform2uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3d glad_glProgramUniform3d
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3dv glad_glProgramUniform3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3f glad_glProgramUniform3f
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3fv glad_glProgramUniform3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3i glad_glProgramUniform3i
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3iv glad_glProgramUniform3iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3ui glad_glProgramUniform3ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3uiv glad_glProgramUniform3uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4d glad_glProgramUniform4d
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4dv glad_glProgramUniform4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4f glad_glProgramUniform4f
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4fv glad_glProgramUniform4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4i glad_glProgramUniform4i
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4iv glad_glProgramUniform4iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4ui glad_glProgramUniform4ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4uiv glad_glProgramUniform4uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2dv glad_glProgramUniformMatrix2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2fv glad_glProgramUniformMatrix2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x3dv glad_glProgramUniformMatrix2x3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x3fv glad_glProgramUniformMatrix2x3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x4dv glad_glProgramUniformMatrix2x4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x4fv glad_glProgramUniformMatrix2x4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3dv glad_glProgramUniformMatrix3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3fv glad_glProgramUniformMatrix3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x2dv glad_glProgramUniformMatrix3x2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x2fv glad_glProgramUniformMatrix3x2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x4dv glad_glProgramUniformMatrix3x4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x4fv glad_glProgramUniformMatrix3x4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4dv glad_glProgramUniformMatrix4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4fv glad_glProgramUniformMatrix4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x2dv glad_glProgramUniformMatrix4x2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x2fv glad_glProgramUniformMatrix4x2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x3dv glad_glProgramUniformMatrix4x3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable
* to be modified is specified by location, which should be a value returned by glGetUniformLocation. glProgramUniform
* operates on the program object specified by program.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location
* using the values passed as arguments. The number specified in the command should match the number of components in the
* data type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2,
* etc.). The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values
* are being passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match
* the data type of the specified uniform variable. The i variants of this function should be used to provide values for
* uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used
* to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants
* should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either
* the i, ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays
* of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glProgramUniform until the next successful link operation occurs
* on the program object, when they are once again initialized to 0.<br>
* 	The commands glProgramUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array.
* These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable
* array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can
* be used to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a
* uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than
* the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The
* number specified in the name of the command indicates the number of components for each element in value, and it should
* match the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for
* vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified
* uniform variable as described previously for glProgramUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glProgramUniform3f or glProgramUniform3fv can be used to load a uniform variable array of type vec3). The number
* of elements of the uniform variable array to be modified is specified by count<br>
* 	The commands glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices.
* The numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix
* (i.e., 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix
* (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns
* and the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and
* 4 rows (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose
* is GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1
* can be used to modify an array of matrices.<br>
*
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x3fv glad_glProgramUniformMatrix4x3fv
GLAD_API_CALL PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
/**
* @name glProvokingVertex - specifiy the vertex to be used as the source of data for flat shaded varyings
* @usage
* @code void glProvokingVertex(GLenum provokeMode); @endcode
* @param provokeMode Specifies the vertex to be used as the source of data for flat shaded varyings.
* @description
* 	Flatshading a vertex shader varying output means to assign all vetices of the primitive the same value for that output.
* The vertex from which these values is derived is known as the provoking vertex and glProvokingVertex specifies which vertex
* is to be used as the source of data for flat shaded varyings.<br>
* 	provokeMode must be either GL_FIRST_VERTEX_CONVENTION or GL_LAST_VERTEX_CONVENTION, and controls the selection of the vertex
* whose values are assigned to flatshaded varying outputs. The interpretation of these values for the supported primitive
* types is:<br>
* 	i + 1, if i < n<br>
* 	1, if i = n<br>
* 	If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the flat qualifier when
* declaring the output.<br>
*
* @note glProvokingVertex is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if provokeMode is not an accepted value.
*
*/
#define glProvokingVertex glad_glProvokingVertex
GLAD_API_CALL PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;
/**
* @name glPushDebugGroup - push a named debug group into the command stream
* @usage
* @code void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message); @endcode
* @param source The source of the debug message.
* @param id The identifier of the message.
* @param length The length of the message to be sent to the debug output stream.
* @param message The a string containing the message to be sent to the debug output stream.
* @description
* 	glPushDebugGroup pushes a debug group described by the string message into the command stream. The value of id specifies
* the ID of messages generated. The parameter length contains the number of characters in message. If length is negative,
* it is implied that message contains a null terminated string. The message has the specified source and id, the type GL_DEBUG_TYPE_PUSH_GROUP,
* and severityGL_DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group on top of the debug
* group stack which inherits the control of the volume of debug output of the debug group previously residing on the top
* of the debug group stack. Because debug groups are strictly hierarchical, any additional control of the debug output volume
* will only apply within the active debug group and the debug groups pushed on top of the active debug group.<br>
*
*
* @errors GL_INVALID_ENUM is generated if the value of source is neither GL_DEBUG_SOURCE_APPLICATION nor GL_DEBUG_SOURCE_THIRD_PARTY.
* @errors GL_INVALID_VALUE is generated if length is negative and the number of characters in message, excluding the null-terminator,
*         is not less than the value of GL_MAX_DEBUG_MESSAGE_LENGTH.
*
*/
#define glPushDebugGroup glad_glPushDebugGroup
GLAD_API_CALL PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
/**
* @name glQueryCounter - record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
* @usage
* @code void glQueryCounter(GLuint id, GLenum target); @endcode
* @param id Specify the name of a query object into which to record the GL time.
* @param target Specify the counter to query. <em class="parameter"><b>target</b></em> must be <b>GL_TIMESTAMP</b>.
* @description
* 	glQueryCounter causes the GL to record the current time into the query object named id. target must be GL_TIMESTAMP. The
* time is recorded after all previous commands on the GL client and server state and the framebuffer have been fully realized.
* When the time is recorded, the query result for that object is marked available. glQueryCounter timer queries can
* be used within a glBeginQuery / glEndQuery block where the target is GL_TIME_ELAPSED and it does not affect the result
* of that query object.<br>
*
* @note glQueryCounter is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_OPERATION is generated if id is the name of a query object that is already in use within a glBeginQuery / glEndQuery
*         block.
* @errors GL_INVALID_VALUE is generated if id is not the name of a query object returned from a previous call to glGenQueries.
* @errors GL_INVALID_ENUM is generated if target is not GL_TIMESTAMP.
*
*/
#define glQueryCounter glad_glQueryCounter
GLAD_API_CALL PFNGLREADBUFFERPROC glad_glReadBuffer;
/**
* @name glReadBuffer, glNamedFramebufferReadBuffer - select a color buffer source for pixels
* @usage
* @code void glReadBuffer(GLenum mode); @endcode
* @code void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferReadBuffer</b> function.
* @param mode Specifies a color buffer. Accepted values are <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>,
*             <b>GL_FRONT</b>, <b>GL_BACK</b>, <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and the constants <b>GL_COLOR_ATTACHMENT</b><span
*             class="emphasis"><em>i</em></span>.
* @description
* 	glReadBuffer specifies a color buffer as the source for subsequent glReadPixels, glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D,
* glCopyTexSubImage2D, and glCopyTexSubImage3D commands. mode accepts one of twelve or more predefined
* values. In a fully configured system, GL_FRONT, GL_LEFT, and GL_FRONT_LEFT all name the front left buffer, GL_FRONT_RIGHT
* and GL_RIGHT name the front right buffer, and GL_BACK_LEFT and GL_BACK name the back left buffer. Further more, the constants
* GL_COLOR_ATTACHMENTi may be used to indicate the ith color attachment where i ranges from zero to the value of GL_MAX_COLOR_ATTACHMENTS
* minus one.<br>
* 	Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations
* have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify
* a nonexistent buffer to glReadBuffer.<br>
* 	mode is initially GL_FRONT in single-buffered configurations and GL_BACK in double-buffered configurations.<br>
* 	For glReadBuffer, the target framebuffer object is that bound to GL_READ_FRAMEBUFFER. For glNamedFramebufferReadBuffer,
* framebuffer must either be zero or the name of the target framebuffer object. If framebuffer is zero, then the default
* read framebuffer is affected.<br>
*
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values.
* @errors GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferReadBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glReadBuffer glad_glReadBuffer
GLAD_API_CALL PFNGLREADPIXELSPROC glad_glReadPixels;
/**
* @name glReadPixels, glReadnPixels - read a block of pixels from the frame buffer
* @usage
* @code void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data); @endcode
* @code void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data); @endcode
* @param x, y Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner
*             of a rectangular block of pixels.
* @param width, height Specify the dimensions of the pixel rectangle. <em class="parameter"><b>width</b></em> and <em class="parameter"><b>height</b></em>
*                      of one correspond to a single pixel.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RGB</b>, <b>GL_BGR</b>, <b>GL_RGBA</b>,
*               and <b>GL_BGRA</b>.
* @param type Specifies the data type of the pixel data. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>, <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>,
*             or <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>data</b></em> for <b>glReadnPixels</b> function.
* @param data Returns the pixel data.
* @description
* 	glReadPixels and glReadnPixels return pixel data from the frame buffer, starting with the pixel whose lower left corner
* is at location (x, y), into client memory starting at location data. Several parameters control the processing of the pixel
* data before it is placed into client memory. These parameters are set with glPixelStore. This reference page describes
* the effects on glReadPixels and glReadnPixels of most, but not all of the parameters specified by these three commands.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a block of pixels
* is requested, data is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.<br>
* 	glReadPixels and glReadnPixels return values from each pixel with lower left corner at  x+i y+j for 0<=i<width and 0<=j<height
* . This pixel is said to be the ith pixel in the jth row. Pixels are returned in row order from the lowest to the
* highest row, left to right in each row.<br>
* 	format specifies the format for the returned pixel values; accepted values are:<br>
* 	Stencil values are read from the stencil buffer.<br>
* 	Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth
* value maps to 0 and the maximum value maps to 1. Each component is clamped to the range 01 .<br>
* 	Values are taken from both the depth and stencil buffers. The type parameter must be GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.<br>
* 	Color values are taken from the color buffer.<br>
* 	Finally, the indices or components are converted to the proper format, as specified by type. If format is GL_STENCIL_INDEX
* and type is not GL_FLOAT, each index is masked with the mask value given in the following table. If type is GL_FLOAT,
* then each integer index is converted to single-precision floating-point format.<br>
* 	If format is GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, or GL_BGRA and type is not GL_FLOAT, each component is
* multiplied by the multiplier shown in the following table. If type is GL_FLOAT, then each component is passed as is (or
* converted to the client's single-precision floating-point format if it is different from the one used by the GL).<br>
* 	Return values are placed in memory as follows. If format is GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, or
* GL_BLUE, a single value is returned and the data for the ith pixel in the jth row is placed in location j ⁢width+i . GL_RGB
* and GL_BGR return three values, GL_RGBA and GL_BGRA return four values for each pixel, with all values corresponding
* to a single pixel occupying contiguous space in data. Storage parameters set by glPixelStore, such as GL_PACK_LSB_FIRST
* and GL_PACK_SWAP_BYTES, affect the way that data is written into memory. See glPixelStore for a description.<br>
* 	glReadnPixels function will only handle the call if bufSize is at least of the size required to store the requested data.
* Otherwise, it will generate a GL_INVALID_OPERATION error.<br>
*
* @note Values for pixels that lie outside the window connected to the current GL context are undefined.
* @note If an error is generated, no change is made to the contents of data.
*
* @errors GL_INVALID_ENUM is generated if format or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_STENCIL and there is no depth buffer or if there is no stencil buffer.
* @errors GL_INVALID_ENUM is generated if format is GL_DEPTH_STENCIL and type is not GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated if GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the
*         value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero.
* @errors GL_INVALID_OPERATION is generated by glReadnPixels if the buffer size required to store the requested data is greater than
*         bufSize.
*
*/
#define glReadPixels glad_glReadPixels
GLAD_API_CALL PFNGLREADNPIXELSPROC glad_glReadnPixels;
/**
* @name glReadPixels, glReadnPixels - read a block of pixels from the frame buffer
* @usage
* @code void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data); @endcode
* @code void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data); @endcode
* @param x, y Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner
*             of a rectangular block of pixels.
* @param width, height Specify the dimensions of the pixel rectangle. <em class="parameter"><b>width</b></em> and <em class="parameter"><b>height</b></em>
*                      of one correspond to a single pixel.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RGB</b>, <b>GL_BGR</b>, <b>GL_RGBA</b>,
*               and <b>GL_BGRA</b>.
* @param type Specifies the data type of the pixel data. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>, <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>,
*             or <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>data</b></em> for <b>glReadnPixels</b> function.
* @param data Returns the pixel data.
* @description
* 	glReadPixels and glReadnPixels return pixel data from the frame buffer, starting with the pixel whose lower left corner
* is at location (x, y), into client memory starting at location data. Several parameters control the processing of the pixel
* data before it is placed into client memory. These parameters are set with glPixelStore. This reference page describes
* the effects on glReadPixels and glReadnPixels of most, but not all of the parameters specified by these three commands.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a block of pixels
* is requested, data is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.<br>
* 	glReadPixels and glReadnPixels return values from each pixel with lower left corner at  x+i y+j for 0<=i<width and 0<=j<height
* . This pixel is said to be the ith pixel in the jth row. Pixels are returned in row order from the lowest to the
* highest row, left to right in each row.<br>
* 	format specifies the format for the returned pixel values; accepted values are:<br>
* 	Stencil values are read from the stencil buffer.<br>
* 	Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth
* value maps to 0 and the maximum value maps to 1. Each component is clamped to the range 01 .<br>
* 	Values are taken from both the depth and stencil buffers. The type parameter must be GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.<br>
* 	Color values are taken from the color buffer.<br>
* 	Finally, the indices or components are converted to the proper format, as specified by type. If format is GL_STENCIL_INDEX
* and type is not GL_FLOAT, each index is masked with the mask value given in the following table. If type is GL_FLOAT,
* then each integer index is converted to single-precision floating-point format.<br>
* 	If format is GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, or GL_BGRA and type is not GL_FLOAT, each component is
* multiplied by the multiplier shown in the following table. If type is GL_FLOAT, then each component is passed as is (or
* converted to the client's single-precision floating-point format if it is different from the one used by the GL).<br>
* 	Return values are placed in memory as follows. If format is GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, or
* GL_BLUE, a single value is returned and the data for the ith pixel in the jth row is placed in location j ⁢width+i . GL_RGB
* and GL_BGR return three values, GL_RGBA and GL_BGRA return four values for each pixel, with all values corresponding
* to a single pixel occupying contiguous space in data. Storage parameters set by glPixelStore, such as GL_PACK_LSB_FIRST
* and GL_PACK_SWAP_BYTES, affect the way that data is written into memory. See glPixelStore for a description.<br>
* 	glReadnPixels function will only handle the call if bufSize is at least of the size required to store the requested data.
* Otherwise, it will generate a GL_INVALID_OPERATION error.<br>
*
* @note Values for pixels that lie outside the window connected to the current GL context are undefined.
* @note If an error is generated, no change is made to the contents of data.
*
* @errors GL_INVALID_ENUM is generated if format or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_STENCIL and there is no depth buffer or if there is no stencil buffer.
* @errors GL_INVALID_ENUM is generated if format is GL_DEPTH_STENCIL and type is not GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated if GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the
*         value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero.
* @errors GL_INVALID_OPERATION is generated by glReadnPixels if the buffer size required to store the requested data is greater than
*         bufSize.
*
*/
#define glReadnPixels glad_glReadnPixels
GLAD_API_CALL PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;
/**
* @name glReleaseShaderCompiler - release resources consumed by the implementation's shader compiler
* @usage
* @code void glReleaseShaderCompiler(void); @endcode
* @description
* 	glReleaseShaderCompiler provides a hint to the implementation that it may free internal resources associated with its shader
* compiler. glCompileShader may subsequently be called and the implementation may at that time reallocate resources
* previously freed by the call to glReleaseShaderCompiler.<br>
*
*
*
*/
#define glReleaseShaderCompiler glad_glReleaseShaderCompiler
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
/**
* @name glRenderbufferStorage, glNamedRenderbufferStorage - establish data storage, format and dimensions of a
renderbuffer object's image
* @usage
* @code void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorage</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorage</b> function.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
* @description
* 	glRenderbufferStorage is equivalent to calling glRenderbufferStorageMultisample with the samples set to zero, and glNamedRenderbufferStorage
* is equivalent to calling glNamedRenderbufferStorageMultisample with the samples set to zero.<br>
* 	For glRenderbufferStorage, the target of the operation, specified by target must be GL_RENDERBUFFER. For glNamedRenderbufferStorage,
* renderbuffer must be a name of an existing renderbuffer object. internalformat specifies the internal format
* to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable
* format. width and height are the dimensions, in pixels, of the renderbuffer. Both width and height must be less than
* or equal to the value of GL_MAX_RENDERBUFFER_SIZE.<br>
* 	Upon success, glRenderbufferStorage and glNamedRenderbufferStorage delete any existing data store for the renderbuffer
* image and the contents of the data store after calling glRenderbufferStorage are undefined.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorage if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorage if renderbuffer is not the name of an existing renderbuffer
*         object.
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glRenderbufferStorage glad_glRenderbufferStorage
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
/**
* @name glRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample - establish data storage, format, dimensions and sample count of
a renderbuffer object's image
* @usage
* @code void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorageMultisample</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorageMultisample</b> function.
* @param samples Specifies the number of samples to be used for the renderbuffer object's storage.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
* @description
* 	glRenderbufferStorageMultisample and glNamedRenderbufferStorageMultisample establish the data storage, format, dimensions
* and number of samples of a renderbuffer object's image.<br>
* 	For glRenderbufferStorageMultisample, the target of the operation, specified by target must be GL_RENDERBUFFER. For glNamedRenderbufferStorageMultisample,
* renderbuffer must be an ID of an existing renderbuffer object. internalformat specifies
* the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable,
* or stencil-renderable format. width and height are the dimensions, in pixels, of the renderbuffer. Both width and height
* must be less than or equal to the value of GL_MAX_RENDERBUFFER_SIZE. samples specifies the number of samples to be used
* for the renderbuffer object's image, and must be less than or equal to the value of GL_MAX_SAMPLES. If internalformat
* is a signed or unsigned integer format then samples must be less than or equal to the value of GL_MAX_INTEGER_SAMPLES.<br>
* 	Upon success, glRenderbufferStorageMultisample and glNamedRenderbufferStorageMultisample delete any existing data store
* for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorageMultisample function if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorageMultisample function if renderbuffer is not the name of an
*         existing renderbuffer object.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for internalformat.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glRenderbufferStorageMultisample glad_glRenderbufferStorageMultisample
GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;
/**
* @name glResumeTransformFeedback - resume transform feedback operations
* @usage
* @code void glResumeTransformFeedback(void); @endcode
* @description
* 	glResumeTransformFeedback resumes transform feedback operations on the currently active transform feedback object. When
* transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback
* state related to the object results in an error. However, a new transform feedback object may be bound while transform
* feedback is paused.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is not paused.
*
*/
#define glResumeTransformFeedback glad_glResumeTransformFeedback
GLAD_API_CALL PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
/**
* @name glSampleCoverage - specify multisample coverage parameters
* @usage
* @code void glSampleCoverage(GLfloat value, GLboolean invert); @endcode
* @param value Specify a single floating-point sample coverage value.  The value is clamped to the range <math overflow="scroll">
<mfenced
*              close="]" open="[">
<mn>0</mn>
<mn>1</mn>
</mfenced>
</math>. The initial value is 1. 0.
* @param invert Specify a single boolean value representing if the coverage masks should be inverted.  <b>GL_TRUE</b> and <b>GL_FALSE</b>
*               are accepted.  The initial value is <b>GL_FALSE</b>.
* @description
* 	Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing
* effects.  Multisampling transparently antialiases points, lines, polygons, and images if it is enabled.<br>
* 	value is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment
* color.  This mask is bitwise-anded with the coverage mask generated from the multisampling computation.  If the invert
* flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed.<br>
* 	If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs
* with only a single sample computing a pixel's final RGB color.<br>
* 	Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated
* by combining several samples per pixel.  Each sample contains color, depth, and stencil information, allowing those
* operations to be performed on each sample.<br>
*
* @note The type of the value parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described
*       in detail on the removedTypes page.
*
*
*/
#define glSampleCoverage glad_glSampleCoverage
GLAD_API_CALL PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
/**
* @name glSampleMaski - set the value of a sub-word of the sample mask
* @usage
* @code void glSampleMaski(GLuint maskNumber, GLbitfield mask); @endcode
* @param maskNumber Specifies which 32-bit sub-word of the sample mask to update.
* @param mask Specifies the new value of the mask sub-word.
* @description
* 	glSampleMaski sets one 32-bit sub-word of the multi-word sample mask, GL_SAMPLE_MASK_VALUE.<br>
* 	maskIndex specifies which 32-bit sub-word of the sample mask to update, and mask specifies the new value to use for that
* sub-word. maskIndex must be less than the value of GL_MAX_SAMPLE_MASK_WORDS. Bit B of mask word M corresponds to sample
* 32 x M + B.<br>
*
* @note glSampleMaski is available only if the GL version is 3.2 or greater, or if the ARB_texture_multisample extension is supported.
*
* @errors GL_INVALID_VALUE is generated if maskIndex is greater than or equal to the value of GL_MAX_SAMPLE_MASK_WORDS.
*
*/
#define glSampleMaski glad_glSampleMaski
GLAD_API_CALL PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
// Unable to find the docs for this function!
#define glSamplerParameterIiv glad_glSamplerParameterIiv
GLAD_API_CALL PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
// Unable to find the docs for this function!
#define glSamplerParameterIuiv glad_glSamplerParameterIuiv
GLAD_API_CALL PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
// Unable to find the docs for this function!
#define glSamplerParameterf glad_glSamplerParameterf
GLAD_API_CALL PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
// Unable to find the docs for this function!
#define glSamplerParameterfv glad_glSamplerParameterfv
GLAD_API_CALL PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
// Unable to find the docs for this function!
#define glSamplerParameteri glad_glSamplerParameteri
GLAD_API_CALL PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
// Unable to find the docs for this function!
#define glSamplerParameteriv glad_glSamplerParameteriv
GLAD_API_CALL PFNGLSCISSORPROC glad_glScissor;
/**
* @name glScissor - define the scissor box
* @usage
* @code void glScissor(GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param x, y Specify the lower left corner of the scissor box. Initially (0, 0).
* @param width, height Specify the width and height of the scissor box. When a GL context is first attached to a window, <em class="parameter"><b>width</b></em>
*                      and <em class="parameter"><b>height</b></em> are set to the dimensions of that window.
* @description
* 	glScissor defines a rectangle, called the scissor box, in window coordinates. The first two arguments, x and y, specify
* the lower left corner of the box. width and height specify the width and height of the box.<br>
* 	To enable and disable the scissor test, call glEnable and  glDisable with argument GL_SCISSOR_TEST. The test is initially
* disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands.
* Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification
* of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in the
* window.<br>
* 	When the scissor test is disabled, it is as though the scissor box includes the entire window.<br>
*
*
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
*
*/
#define glScissor glad_glScissor
GLAD_API_CALL PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;
// Unable to find the docs for this function!
#define glScissorArrayv glad_glScissorArrayv
GLAD_API_CALL PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;
/**
* @name glScissorIndexed - define the scissor box for a specific viewport
* @usage
* @code void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height); @endcode
* @code void glScissorIndexedv(GLuint index, const GLint *v); @endcode
* @param index Specifies the index of the viewport whose scissor box to modify.
* @param left, bottom Specify the coordinate of the bottom left corner of the scissor box, in pixels.
* @param width, height Specify ths dimensions of the scissor box, in pixels.
* @param v For <b>glScissorIndexedv</b>, specifies the address of an array containing the left, bottom, width and height of each scissor
*          box, in that order.
* @description
* 	glScissorIndexed defines the scissor box for a specified viewport. index specifies the index of scissor box to modify.
* index must be less than the value of GL_MAX_VIEWPORTS. For glScissorIndexed, left, bottom, width and height specify the
* left, bottom, width and height of the scissor box, in pixels, respectively. For glScissorIndexedv, v specifies the address
* of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the
* scissor box, in that order.<br>
* 	To enable and disable the scissor test, call glEnable and  glDisable with argument GL_SCISSOR_TEST. The test is initially
* disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by
* drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1)
* allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of
* any pixels in the window.<br>
* 	When the scissor test is disabled, it is as though the scissor box includes the entire window.<br>
*
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS.
* @errors GL_INVALID_VALUE is generated if any width or height specified in the array v is negative.
*
*/
#define glScissorIndexed glad_glScissorIndexed
GLAD_API_CALL PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;
/**
* @name glScissorIndexed - define the scissor box for a specific viewport
* @usage
* @code void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height); @endcode
* @code void glScissorIndexedv(GLuint index, const GLint *v); @endcode
* @param index Specifies the index of the viewport whose scissor box to modify.
* @param left, bottom Specify the coordinate of the bottom left corner of the scissor box, in pixels.
* @param width, height Specify ths dimensions of the scissor box, in pixels.
* @param v For <b>glScissorIndexedv</b>, specifies the address of an array containing the left, bottom, width and height of each scissor
*          box, in that order.
* @description
* 	glScissorIndexed defines the scissor box for a specified viewport. index specifies the index of scissor box to modify.
* index must be less than the value of GL_MAX_VIEWPORTS. For glScissorIndexed, left, bottom, width and height specify the
* left, bottom, width and height of the scissor box, in pixels, respectively. For glScissorIndexedv, v specifies the address
* of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the
* scissor box, in that order.<br>
* 	To enable and disable the scissor test, call glEnable and  glDisable with argument GL_SCISSOR_TEST. The test is initially
* disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by
* drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1)
* allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of
* any pixels in the window.<br>
* 	When the scissor test is disabled, it is as though the scissor box includes the entire window.<br>
*
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS.
* @errors GL_INVALID_VALUE is generated if any width or height specified in the array v is negative.
*
*/
#define glScissorIndexedv glad_glScissorIndexedv
GLAD_API_CALL PFNGLSHADERBINARYPROC glad_glShaderBinary;
/**
* @name glShaderBinary - load pre-compiled shader binaries
* @usage
* @code void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length); @endcode
* @param count Specifies the number of shader object handles contained in <em class="parameter"><b>shaders</b></em>.
* @param shaders Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
* @param binaryFormat Specifies the format of the shader binaries contained in <em class="parameter"><b>binary</b></em>.
* @param binary Specifies the address of an array of bytes containing pre-compiled binary shader code.
* @param length Specifies the length of the array whose address is given in <em class="parameter"><b>binary</b></em>.
* @description
* 	glShaderBinary loads pre-compiled shader binary code into the count shader objects whose handles are given in shaders.
* binary points to length bytes of binary shader code stored in client memory. binaryFormat specifies the format of the pre-compiled
* code.<br>
* 	The binary image contained in binary will be decoded according to the extension specification defining the specified binaryFormat
* token. OpenGL does not define any specific binary formats, but it does provide a mechanism to obtain token vaues
* for such formats provided by such extensions.<br>
* 	Depending on the types of the shader objects in shaders, glShaderBinary will individually load binary vertex or fragment
* shaders, or load an executable binary that contains an optimized pair of vertex and fragment shaders stored in the same
* binary.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if more than one of the handles in shaders refers to the same shader object.
* @errors GL_INVALID_ENUM is generated if binaryFormat is not an accepted value.
* @errors GL_INVALID_VALUE is generated if the data pointed to by binary does not match the format specified by binaryFormat.
*
*/
#define glShaderBinary glad_glShaderBinary
GLAD_API_CALL PFNGLSHADERSOURCEPROC glad_glShaderSource;
/**
* @name glShaderSource - Replaces the source code in a shader object
* @usage
* @code void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length); @endcode
* @param shader Specifies the handle of the shader object whose source code is to be replaced.
* @param count Specifies the number of elements in the <em class="parameter"><b>string</b></em> and <em class="parameter"><b>length</b></em>
*              arrays.
* @param string Specifies an array of pointers to strings containing the source code to be loaded into the shader.
* @param length Specifies an array of string lengths.
* @description
* 	glShaderSource sets the source code in shader to the source code in the array of strings specified by string. Any source
* code previously stored in the shader object is completely replaced. The number of strings in the array is specified by
* count. If length is NULL, each string is assumed to be null terminated. If length is a value other than NULL, it points
* to an array containing a string length for each of the corresponding elements of string. Each element in the length array
* may contain the length of the corresponding string (the null character is not counted as part of the string length) or
* a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed
* at this time; they are simply copied into the specified shader object.<br>
*
* @note OpenGL copies the shader source code strings when glShaderSource is called, so an application may free its copy of the source
*       code strings immediately after the function returns.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
*
*/
#define glShaderSource glad_glShaderSource
GLAD_API_CALL PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;
/**
* @name glShaderStorageBlockBinding - change an active shader storage block binding
* @usage
* @code void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding); @endcode
* @param program The name of the program containing the block whose binding to change.
* @param storageBlockIndex The index storage block within the program.
* @param storageBlockBinding The index storage block binding to associate with the specified storage block.
* @description
* 	glShaderStorageBlockBinding, changes the active shader storage block with an assigned index of storageBlockIndex in program
* object program.  storageBlockIndex must be an active shader storage block index in program. storageBlockBinding must
* be less than the value of GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS. If successful, glShaderStorageBlockBinding specifies
* that program will use the data store of the buffer object bound to the binding point storageBlockBinding to read and write
* the values of the buffer variables in the shader storage block identified by storageBlockIndex.<br>
*
*
* @errors GL_INVALID_VALUE is generated if program is not the name of either a program or shader object.
* @errors GL_INVALID_OPERATION is generated if program is the name of a shader object.
* @errors GL_INVALID_VALUE is generated if storageBlockIndex is not an active shader storage block index in program, or if storageBlockBinding
*         is greater than or equal to the value of MAX_SHADER_STORAGE_BUFFER_BINDINGS.
*
*/
#define glShaderStorageBlockBinding glad_glShaderStorageBlockBinding
GLAD_API_CALL PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader;
// Unable to find the docs for this function!
#define glSpecializeShader glad_glSpecializeShader
GLAD_API_CALL PFNGLSTENCILFUNCPROC glad_glStencilFunc;
/**
* @name glStencilFunc - set front and back function and reference value for stencil testing
* @usage
* @code void glStencilFunc(GLenum func, GLint ref, GLuint mask); @endcode
* @param func Specifies the test function. Eight symbolic constants are valid: <b>GL_NEVER</b>, <b>GL_LESS</b>, <b>GL_LEQUAL</b>, <b>GL_GREATER</b>,
*             <b>GL_GEQUAL</b>, <b>GL_EQUAL</b>, <b>GL_NOTEQUAL</b>, and <b>GL_ALWAYS</b>. The initial value is <b>GL_ALWAYS</b>.
* @param ref Specifies the reference value for the stencil test. <em class="parameter"><b>ref</b></em> is clamped to the range <math
*            overflow="scroll">
<mfenced close="]" open="[">
<mn>0</mn>
<mrow>
<msup><mn>2</mn>
<mi mathvariant="italic">n</mi>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfenced>
</math>,
*            where <math overflow="scroll"><mi mathvariant="italic">n</mi></math>
*            is the number of bitplanes in the stencil buffer. The initial value is 0.
* @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial
*             value is all 1's.
* @description
* 	Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into
* using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the
* screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining,
* and constructive solid geometry rendering.<br>
* 	The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and
* the value in the stencil buffer. To enable and disable the test, call glEnable and  glDisable with argument GL_STENCIL_TEST.
* To specify actions based on the outcome of the stencil test, call glStencilOp or glStencilOpSeparate.<br>
* 	There can be two separate sets of func, ref, and mask parameters; one affects back-facing polygons, and the other affects
* front-facing polygons as well as other non-polygon primitives. glStencilFunc sets both front and back stencil state to
* the same values. Use glStencilFuncSeparate to set front and back stencil state to different values.<br>
* 	func is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the
* following list. ref is an integer reference value that is used in the stencil comparison. It is clamped to the range
* 0 2n -1 , where n is the number of bitplanes in the stencil buffer. mask is bitwise ANDed with both the reference value
* and the stored stencil value, with the ANDed values participating in the comparison.<br>
* 	If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect
* of each comparison function that can be specified by func. Only if the comparison succeeds is the pixel passed through
* to the next stage in the rasterization process (see glStencilOp). All tests treat stencil values as unsigned integers in
* the range 0 2n -1 , where n is the number of bitplanes in the stencil buffer.<br>
* 	The following values are accepted by func:<br>
* 	Always fails.<br>
* 	Passes if ( ref & mask ) < ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) <= ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) > ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) >= ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) = ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) != ( stencil & mask ).<br>
* 	Always passes.<br>
*
* @note Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil test always passes.
* @note glStencilFunc is the same as calling glStencilFuncSeparate with face set to GL_FRONT_AND_BACK.
*
* @errors GL_INVALID_ENUM is generated if func is not one of the eight accepted values.
*
*/
#define glStencilFunc glad_glStencilFunc
GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
/**
* @name glStencilFuncSeparate - set front and/or back function and reference value for stencil testing
* @usage
* @code void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask); @endcode
* @param face Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: <b>GL_FRONT</b>, <b>GL_BACK</b>,
*             and <b>GL_FRONT_AND_BACK</b>.
* @param func Specifies the test function. Eight symbolic constants are valid: <b>GL_NEVER</b>, <b>GL_LESS</b>, <b>GL_LEQUAL</b>, <b>GL_GREATER</b>,
*             <b>GL_GEQUAL</b>, <b>GL_EQUAL</b>, <b>GL_NOTEQUAL</b>, and <b>GL_ALWAYS</b>. The initial value is <b>GL_ALWAYS</b>.
* @param ref Specifies the reference value for the stencil test. <em class="parameter"><b>ref</b></em> is clamped to the range <math
*            overflow="scroll">
<mfenced close="]" open="[">
<mn>0</mn>
<mrow>
<msup><mn>2</mn>
<mi mathvariant="italic">n</mi>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfenced>
</math>,
*            where <math overflow="scroll"><mi mathvariant="italic">n</mi></math>
*            is the number of bitplanes in the stencil buffer. The initial value is 0.
* @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial
*             value is all 1's.
* @description
* 	Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using
* GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen.
* Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining,
* and constructive solid geometry rendering.<br>
* 	The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and
* the value in the stencil buffer. To enable and disable the test, call glEnable and  glDisable with argument GL_STENCIL_TEST.
* To specify actions based on the outcome of the stencil test, call glStencilOp or glStencilOpSeparate.<br>
* 	There can be two separate sets of func, ref, and mask parameters; one affects back-facing polygons, and the other affects
* front-facing polygons as well as other non-polygon primitives. glStencilFunc sets both front and back stencil state to
* the same values, as if glStencilFuncSeparate were called with face set to GL_FRONT_AND_BACK.<br>
* 	func is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the
* following list. ref is an integer reference value that is used in the stencil comparison. It is clamped to the range
* 0 2n -1 , where n is the number of bitplanes in the stencil buffer. mask is bitwise ANDed with both the reference value
* and the stored stencil value, with the ANDed values participating in the comparison.<br>
* 	If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect
* of each comparison function that can be specified by func. Only if the comparison succeeds is the pixel passed through
* to the next stage in the rasterization process (see glStencilOp). All tests treat stencil values as unsigned integers in
* the range 0 2n -1 , where n is the number of bitplanes in the stencil buffer.<br>
* 	The following values are accepted by func:<br>
* 	Always fails.<br>
* 	Passes if ( ref & mask ) < ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) <= ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) > ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) >= ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) = ( stencil & mask ).<br>
* 	Passes if ( ref & mask ) != ( stencil & mask ).<br>
* 	Always passes.<br>
*
* @note Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil test always passes.
*
* @errors GL_INVALID_ENUM is generated if func is not one of the eight accepted values.
*
*/
#define glStencilFuncSeparate glad_glStencilFuncSeparate
GLAD_API_CALL PFNGLSTENCILMASKPROC glad_glStencilMask;
/**
* @name glStencilMask - control the front and back writing of individual bits in the stencil planes
* @usage
* @code void glStencilMask(GLuint mask); @endcode
* @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all
*             1's.
* @description
* 	glStencilMask controls the writing of individual bits in the stencil planes. The least significant n bits of mask, where
* n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to
* the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all
* bits are enabled for writing.<br>
* 	There can be two separate mask writemasks; one affects back-facing polygons, and the other affects front-facing polygons
* as well as other non-polygon primitives. glStencilMask sets both front and back stencil writemasks to the same values.
* Use glStencilMaskSeparate to set front and back stencil writemasks to different values.<br>
*
* @note glStencilMask is the same as calling glStencilMaskSeparate with face set to GL_FRONT_AND_BACK.
*
*
*/
#define glStencilMask glad_glStencilMask
GLAD_API_CALL PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
/**
* @name glStencilMaskSeparate - control the front and/or back writing of individual bits in the stencil planes
* @usage
* @code void glStencilMaskSeparate(GLenum face, GLuint mask); @endcode
* @param face Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: <b>GL_FRONT</b>,
*             <b>GL_BACK</b>, and <b>GL_FRONT_AND_BACK</b>.
* @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all
*             1's.
* @description
* 	glStencilMaskSeparate controls the writing of individual bits in the stencil planes. The least significant n bits of mask,
* where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to
* write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially,
* all bits are enabled for writing.<br>
* 	There can be two separate mask writemasks; one affects back-facing polygons, and the other affects front-facing polygons
* as well as other non-polygon primitives. glStencilMask sets both front and back stencil writemasks to the same values,
* as if glStencilMaskSeparate were called with face set to GL_FRONT_AND_BACK.<br>
*
*
* @errors GL_INVALID_ENUM is generated if face is not one of the accepted tokens.
*
*/
#define glStencilMaskSeparate glad_glStencilMaskSeparate
GLAD_API_CALL PFNGLSTENCILOPPROC glad_glStencilOp;
/**
* @name glStencilOp - set front and back stencil test actions
* @usage
* @code void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass); @endcode
* @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: <b>GL_KEEP</b>, <b>GL_ZERO</b>,
*              <b>GL_REPLACE</b>, <b>GL_INCR</b>, <b>GL_INCR_WRAP</b>, <b>GL_DECR</b>, <b>GL_DECR_WRAP</b>, and <b>GL_INVERT</b>.
*              The initial value is <b>GL_KEEP</b>.
* @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. <em class="parameter"><b>dpfail</b></em>
*               accepts the same symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either
*               there is no depth buffer or depth testing is not enabled. <em class="parameter"><b>dppass</b></em> accepts the same
*               symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @description
* 	Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using
* GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen.
* Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining,
* and constructive solid geometry rendering.<br>
* 	The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil
* buffer and a reference value. To enable and disable the test, call glEnable and  glDisable with argument GL_STENCIL_TEST;
* to control it, call glStencilFunc or glStencilFuncSeparate.<br>
* 	There can be two separate sets of sfail, dpfail, and dppass parameters; one affects back-facing polygons, and the other
* affects front-facing polygons as well as other non-polygon primitives. glStencilOp sets both front and back stencil state
* to the same values. Use glStencilOpSeparate to set front and back stencil state to different values.<br>
* 	glStencilOp takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If
* the stencil test fails, no change is made to the pixel's color or depth buffers, and sfail specifies what happens to the
* stencil buffer contents. The following eight actions are possible.<br>
* 	Keeps the current value.<br>
* 	Sets the stencil buffer value to 0.<br>
* 	Sets the stencil buffer value to ref, as specified by glStencilFunc.<br>
* 	Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.<br>
* 	Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable
* unsigned value.<br>
* 	Decrements the current stencil buffer value. Clamps to 0.<br>
* 	Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when
* decrementing a stencil buffer value of zero.<br>
* 	Bitwise inverts the current stencil buffer value.<br>
* 	Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2n
* -1 , where n is the value returned by querying GL_STENCIL_BITS.<br>
* 	The other two arguments to glStencilOp specify stencil buffer actions that depend on whether subsequent depth buffer tests
* succeed (dppass) or fail (dpfail) (see glDepthFunc). The actions are specified using the same eight symbolic constants
* as sfail. Note that dpfail is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these
* cases, sfail and dppass specify stencil action when the stencil test fails and passes, respectively.<br>
*
* @note Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil tests always pass, regardless of any call to glStencilOp.
* @note glStencilOp is the same as calling glStencilOpSeparate with face set to GL_FRONT_AND_BACK.
*
* @errors GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the defined constant values.
*
*/
#define glStencilOp glad_glStencilOp
GLAD_API_CALL PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
/**
* @name glStencilOpSeparate - set front and/or back stencil test actions
* @usage
* @code void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass); @endcode
* @param face Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: <b>GL_FRONT</b>, <b>GL_BACK</b>,
*             and <b>GL_FRONT_AND_BACK</b>.
* @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: <b>GL_KEEP</b>, <b>GL_ZERO</b>,
*              <b>GL_REPLACE</b>, <b>GL_INCR</b>, <b>GL_INCR_WRAP</b>, <b>GL_DECR</b>, <b>GL_DECR_WRAP</b>, and <b>GL_INVERT</b>.
*              The initial value is <b>GL_KEEP</b>.
* @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. <em class="parameter"><b>dpfail</b></em>
*               accepts the same symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either
*               there is no depth buffer or depth testing is not enabled. <em class="parameter"><b>dppass</b></em> accepts the same
*               symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @description
* 	Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using
* GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen.
* Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining,
* and constructive solid geometry rendering.<br>
* 	The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil
* buffer and a reference value. To enable and disable the test, call glEnable and  glDisable with argument GL_STENCIL_TEST;
* to control it, call glStencilFunc or glStencilFuncSeparate.<br>
* 	There can be two separate sets of sfail, dpfail, and dppass parameters; one affects back-facing polygons, and the other
* affects front-facing polygons as well as other non-polygon primitives. glStencilOp sets both front and back stencil state
* to the same values, as if glStencilOpSeparate were called with face set to GL_FRONT_AND_BACK.<br>
* 	glStencilOpSeparate takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled.
* If the stencil test fails, no change is made to the pixel's color or depth buffers, and sfail specifies what happens
* to the stencil buffer contents. The following eight actions are possible.<br>
* 	Keeps the current value.<br>
* 	Sets the stencil buffer value to 0.<br>
* 	Sets the stencil buffer value to ref, as specified by glStencilFunc.<br>
* 	Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.<br>
* 	Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable
* unsigned value.<br>
* 	Decrements the current stencil buffer value. Clamps to 0.<br>
* 	Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when
* decrementing a stencil buffer value of zero.<br>
* 	Bitwise inverts the current stencil buffer value.<br>
* 	Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2n
* -1 , where n is the value returned by querying GL_STENCIL_BITS.<br>
* 	The other two arguments to glStencilOpSeparate specify stencil buffer actions that depend on whether subsequent depth buffer
* tests succeed (dppass) or fail (dpfail) (see glDepthFunc). The actions are specified using the same eight symbolic
* constants as sfail. Note that dpfail is ignored when there is no depth buffer, or when the depth buffer is not enabled.
* In these cases, sfail and dppass specify stencil action when the stencil test fails and passes, respectively.<br>
*
* @note Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil test always passes.
*
* @errors GL_INVALID_ENUM is generated if face is any value other than GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
* @errors GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the eight defined constant values.
*
*/
#define glStencilOpSeparate glad_glStencilOpSeparate
GLAD_API_CALL PFNGLTEXBUFFERPROC glad_glTexBuffer;
/**
* @name glTexBuffer, glTextureBuffer - attach a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer); @endcode
* @code void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexBuffer</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBuffer</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
* @description
* 	glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a specified texture object, and
* specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.<br>
* 	If buffer is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If
* buffer is non-zero, it must be the name of an existing buffer object.<br>
* 	internalformat specifies the storage format, and must be one of the following sized internal formats:<br>
* 	When a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array.
* The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times
* sizeof(base\_type) } } \right\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value
* of GL_BUFFER_SIZE for buffer), and $components$ and $base\_type$ are the element count and base data type for elements,
* as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent
* limit GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer texture is accessed in a shader, the results of a texel
* fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels
* in the texel array.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glTexBuffer if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBuffer if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBuffer if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
*
*/
#define glTexBuffer glad_glTexBuffer
GLAD_API_CALL PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;
/**
* @name glTexBufferRange, glTextureBufferRange - attach a range of a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size); @endcode
* @code void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexBufferRange</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBufferRange</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
* @param offset Specifies the offset of the start of the range of the buffer's data store to attach.
* @param size Specifies the size of the range of the buffer's data store to attach.
* @description
* 	glTexBufferRange and glTextureBufferRange attach a range of the data store of a specified buffer object to a specified
* texture object, and specify the storage format for the texture image found in the buffer object. The texture object must
* be a buffer texture.<br>
* 	If buffer is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If
* buffer is non-zero, it must be the name of an existing buffer object.<br>
* 	The start and size of the range are specified by offset and size respectively, both measured in basic machine units. offset
* must be greater than or equal to zero, size must be greater than zero, and the sum of offset and size must not exceed
* the value of GL_BUFFER_SIZE for buffer. Furthermore, offset must be an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.<br>
* 	internalformat specifies the storage format, and must be one of the following sized internal formats:<br>
* 	When a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store
* is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor
* { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $components$ and $base\_type$ are the
* element count and base data type for elements, as specified in the table above. The number of texels in the texel array
* is then clamped to the value of the implementation-dependent limit GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer texture is
* accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater
* than or equal to the clamped number of texels in the texel array.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glTexBufferRange if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBufferRange if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBufferRange if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset is negative, if size is less than or equal to zero, or if offset + size is greater
*         than the value of GL_BUFFER_SIZE for buffer.
* @errors GL_INVALID_VALUE is generated if offset is not an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.
*
*/
#define glTexBufferRange glad_glTexBufferRange
GLAD_API_CALL PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
/**
* @name glTexImage1D - specify a one-dimensional texture image
* @usage
* @code void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_1D</b> or <b>GL_PROXY_TEXTURE_1D</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the
*                       sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
* @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
*              The height of the 1D texture image is 1.
* @param border This value must be 0.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_RG_INTEGER</b>, <b>GL_RGB_INTEGER</b>,
*               <b>GL_BGR_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGRA_INTEGER</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>,
*             <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
*             <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param data Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To
* enable and disable one-dimensional texturing, call glEnable and  glDisable with argument GL_TEXTURE_1D.<br>
* 	Texture images are defined with glTexImage1D. The arguments describe the parameters of the texture image, such as width,
* width of the border, level-of-detail number (see glTexParameter), and the internal resolution and format used to store
* the image. The last three arguments describe how the image is represented in memory.<br>
* 	If target is GL_PROXY_TEXTURE_1D, no data is read from data, but all of the texture image state is recalculated, checked
* for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture
* of the requested texture size, it sets all of the image state to 0, but does not generate an error (see glGetError). To
* query for an entire mipmap array, use an image array level greater than or equal to 1.<br>
* 	If target is GL_TEXTURE_1D, data is read from data as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision
* floating-point values, depending on type. These values are grouped into sets of one, two, three, or four values,
* depending on format, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined
* by GL_UNPACK_LSB_FIRST (see glPixelStore).<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
* 	The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through
* the remaining texels in the texture array. The final element corresponds to the right end of the texture array.<br>
* 	format determines the composition of each element in data. It can assume one of these symbolic values:<br>
* 	Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element is a single red/green double The GL converts it to floating point and assembles it into an RGBA element by
* attaching 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element contains all four components. Each component clamped to the range [0,1].<br>
* 	Each element is a single depth value. The GL converts it to floating point and clamps to the range [0,1].<br>
* 	If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution
* and format with internalformat. The GL will choose an internal representation that closely approximates that requested
* by internalformat, but it may not match exactly. (The representations specified by GL_RED, GL_RG, GL_RGB and GL_RGBA
* must match exactly.)<br>
* 	internalformat may be one of the base internal formats shown in Table 1, below<br>
* 	internalformat may also be one of the sized internal formats shown in Table 2, below<br>
* 	Finally, internalformat may also be one of the generic or compressed texture formats shown in Table 3 below<br>
* 	If the internalformat parameter is one of the generic compressed formats, GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB,
* or GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal
* format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not
* compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.<br>
* 	If the internalformat parameter is GL_SRGB, GL_SRGB8, GL_SRGB_ALPHAor GL_SRGB8_ALPHA8, the texture is treated as if the
* red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion
* from the sRGB encoded component cs to a linear component cl is:<br>
* 	cl = { cs 12.92 if cs ≤0.04045 ( cs +0.055 1.055 ) 2.4 if cs >0.04045<br>
* 	Assume cs is the sRGB component in the range [0,1].<br>
* 	Use the GL_PROXY_TEXTURE_1D target to try out a resolution and format. The implementation will update and recompute its
* best match for the requested storage resolution and format. To then query this state, call glGetTexLevelParameter. If the
* texture cannot be accommodated, texture state is set to 0.<br>
* 	A one-component texture image uses only the red component of the RGBA color from data. A two-component image uses the R
* and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.<br>
* 	Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result.
*  See glTexParameter for details on texture comparison.<br>
*
* @note glPixelStore modes affect texture images.
* @note data may be a null pointer. In this case texture memory is allocated to accommodate a texture of width width. You can then
*       download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized
*       portion of the texture image to a primitive.
* @note glTexImage1D specifies the one-dimensional texture for the current texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX may be used for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.  Format constants other than GL_STENCIL_INDEX
*         are accepted.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not one of the accepted resolution and format symbolic constants.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalformat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,
*         GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32, and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexImage1D glad_glTexImage1D
GLAD_API_CALL PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
/**
* @name glTexImage2D - specify a two-dimensional texture image
* @usage
* @code void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_PROXY_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image. If <em class="parameter"><b>target</b></em> is <b>GL_TEXTURE_RECTANGLE</b>
*              or <b>GL_PROXY_TEXTURE_RECTANGLE</b>, <em class="parameter"><b>level</b></em> must be 0.
* @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the
*                       sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
* @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
* @param height Specifies the height of the texture image, or the number of layers in a texture array, in the case of the <b>GL_TEXTURE_1D_ARRAY</b>
*               and <b>GL_PROXY_TEXTURE_1D_ARRAY</b> targets. All implementations support 2D texture images that are at least
*               1024 texels high, and texture arrays that are at least 256 layers deep.
* @param border This value must be 0.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_RG_INTEGER</b>, <b>GL_RGB_INTEGER</b>,
*               <b>GL_BGR_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGRA_INTEGER</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>,
*             <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
*             <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param data Specifies a pointer to the image data in memory.
* @description
* 	Texturing allows elements of an image array to be read by shaders.<br>
* 	To define texture images, call glTexImage2D. The arguments describe the parameters of the texture image, such as height,
* width, width of the border, level-of-detail number (see glTexParameter), and number of color components provided. The
* last three arguments describe how the image is represented in memory.<br>
* 	If target is GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_PROXY_TEXTURE_RECTANGLE,
* no data is read from data, but all of the texture image state is recalculated, checked for consistency, and checked against
* the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets
* all of the image state to 0, but does not generate an error (see glGetError). To query for an entire mipmap array, use
* an image array level greater than or equal to 1.<br>
* 	If target is GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE or one of the GL_TEXTURE_CUBE_MAP targets, data is read from data as a
* sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on type.
* These values are grouped into sets of one, two, three, or four values, depending on format, to form elements. Each data
* byte is treated as eight 1-bit elements, with bit ordering determined by GL_UNPACK_LSB_FIRST (see glPixelStore).<br>
* 	If target is GL_TEXTURE_1D_ARRAY, data is interpreted as an array of one-dimensional images.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
* 	The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right
* through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture
* image. The final element corresponds to the upper right corner of the texture image.<br>
* 	format determines the composition of each element in data. It can assume one of these symbolic values:<br>
* 	Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element is a red/green double. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element contains all four components. Each component is clamped to the range [0,1].<br>
* 	Each element is a single depth value. The GL converts it to floating point and clamps to the range [0,1].<br>
* 	Each element is a pair of depth and stencil values. The depth component of the pair is interpreted as in GL_DEPTH_COMPONENT.
* The stencil component is interpreted based on specified the depth + stencil internal format.<br>
* 	If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution
* and format with internalformat. The GL will choose an internal representation that closely approximates that requested
* by internalformat, but it may not match exactly. (The representations specified by GL_RED, GL_RG, GL_RGB, and GL_RGBA
* must match exactly.)<br>
* 	internalformat may be one of the base internal formats shown in Table 1, below<br>
* 	internalformat may also be one of the sized internal formats shown in Table 2, below<br>
* 	Finally, internalformat may also be one of the generic or compressed texture formats shown in Table 3 below<br>
* 	If the internalformat parameter is one of the generic compressed formats, GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB,
* or GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal
* format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not
* compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.<br>
* 	If the internalformat parameter is GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8, the texture is treated as if the
* red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion
* from the sRGB encoded component cs to a linear component cl is:<br>
* 	cl = { cs 12.92 if cs ≤0.04045 ( cs +0.055 1.055 ) 2.4 if cs >0.04045<br>
* 	Assume cs is the sRGB component in the range [0,1].<br>
* 	Use the GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP target
* to try out a resolution and format. The implementation will update and recompute its best match for the requested storage
* resolution and format. To then query this state, call glGetTexLevelParameter. If the texture cannot be accommodated,
* texture state is set to 0.<br>
* 	A one-component texture image uses only the red component of the RGBA color extracted from data. A two-component image
* uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA
* components.<br>
* 	Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result.
* See glTexParameter for details on texture comparison.<br>
*
* @note The glPixelStore mode affects texture images.
* @note data may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width width and height
*       height. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to
*       apply an uninitialized portion of the texture image to a primitive.
* @note glTexImage2D specifies the two-dimensional texture for the current texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX may be used for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D,
*         GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
*         or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
* @errors GL_INVALID_ENUM is generated if target is one of the six cube map 2D image targets and the width and height parameters are
*         not equal.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than
*         0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than 0 or
*         greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not one of the accepted resolution and format symbolic constants.
* @errors GL_INVALID_VALUE is generated if width or height is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV, and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV, and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_RECTANGLE,
*         and internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalformat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,
*         GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32F, and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_VALUE is generated if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE and level is not 0.
*
*/
#define glTexImage2D glad_glTexImage2D
GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
/**
* @name glTexImage2DMultisample - establish the data storage, format, dimensions, and number of samples of a multisample texture's image
* @usage
* @code void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target of the operation. <em class="parameter"><b>target</b></em> must be <b>GL_TEXTURE_2D_MULTISAMPLE</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE</b>.
* @param samples The number of samples in the multisample texture's image.
* @param internalformat The internal format to be used to store the multisample texture's image. <em class="parameter"><b>internalformat</b></em>
*                       must specify a color-renderable, depth-renderable, or stencil-renderable format.
* @param width The width of the multisample texture's image, in texels.
* @param height The height of the multisample texture's image, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @description
* 	glTexImage2DMultisample establishes the data storage, format, dimensions and number of samples of a multisample texture's
* image.<br>
* 	target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. width and height are the dimensions in texels
* of the texture, and must be in the range zero to the value of GL_MAX_TEXTURE_SIZE minus one. samples specifies the number
* of samples in the image and must be in the range zero to the value of GL_MAX_SAMPLES minus one.<br>
* 	internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.<br>
* 	If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the same number of samples for all
* texels in the image, and the sample locations will not depend on the internal format or size of the image.<br>
* 	When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch
* and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling
* instructions are allowed on the multisample texture targets.<br>
*
* @note glTexImage2DMultisample is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than
*         the value of GL_MAX_DEPTH_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of
*         GL_MAX_COLOR_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES.
* @errors GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
*
*/
#define glTexImage2DMultisample glad_glTexImage2DMultisample
GLAD_API_CALL PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
/**
* @name glTexImage3D - specify a three-dimensional texture image
* @usage
* @code void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data); @endcode
* @param target Specifies the target texture. Must be one of <b>GL_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_TEXTURE_2D_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_ARRAY</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <math overflow="scroll"><mi mathvariant="italic">n</mi></math>
*              is the <math overflow="scroll">
<msup><mi mathvariant="italic">n</mi>
<mi mathvariant="italic">th</mi>
</msup>
</math>
*              mipmap reduction image.
* @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the
*                       sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
* @param width Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
* @param height Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
* @param depth Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture
*              images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
* @param border This value must be 0.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_RG_INTEGER</b>, <b>GL_RGB_INTEGER</b>,
*               <b>GL_BGR_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGRA_INTEGER</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>,
*             <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
*             <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param data Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To
* enable and disable three-dimensional texturing, call glEnable and  glDisable with argument GL_TEXTURE_3D.<br>
* 	To define texture images, call glTexImage3D. The arguments describe the parameters of the texture image, such as height,
* width, depth, width of the border, level-of-detail number (see glTexParameter), and number of color components provided.
* The last three arguments describe how the image is represented in memory.<br>
* 	If target is GL_PROXY_TEXTURE_3D, no data is read from data, but all of the texture image state is recalculated, checked
* for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture
* of the requested texture size, it sets all of the image state to 0, but does not generate an error (see glGetError). To
* query for an entire mipmap array, use an image array level greater than or equal to 1.<br>
* 	If target is GL_TEXTURE_3D, data is read from data as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision
* floating-point values, depending on type. These values are grouped into sets of one, two, three, or four values,
* depending on format, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined
* by GL_UNPACK_LSB_FIRST (see glPixelStore).<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, data is treated as a byte offset into the buffer object's data store.<br>
* 	The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right
* through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture
* image. The final element corresponds to the upper right corner of the texture image.<br>
* 	format determines the composition of each element in data. It can assume one of these symbolic values:<br>
* 	Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element is a red and green pair. The GL converts each to floating point and assembles it into an RGBA element by attaching
* 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching
* 1 for alpha. Each component is clamped to the range [0,1].<br>
* 	Each element contains all four components. Each component is clamped to the range [0,1].<br>
* 	If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution
* and format with internalformat. The GL will choose an internal representation that closely approximates that requested
* by internalformat, but it may not match exactly. (The representations specified by GL_RED, GL_RG, GL_RGB, and GL_RGBA
* must match exactly.)<br>
* 	internalformat may be one of the base internal formats shown in Table 1, below<br>
* 	internalformat may also be one of the sized internal formats shown in Table 2, below<br>
* 	Finally, internalformat may also be one of the generic or compressed texture formats shown in Table 3 below<br>
* 	If the internalformat parameter is one of the generic compressed formats, GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB,
* or GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal
* format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not
* compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.<br>
* 	If the internalformat parameter is GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8, the texture is treated as if the
* red, green, blue, or luminance components are encoded in the sRGB color space.    Any alpha component is left unchanged.
*  The conversion from the sRGB encoded component cs to a linear component cl is:<br>
* 	cl = { cs 12.92 if cs ≤0.04045 ( cs +0.055 1.055 ) 2.4 if cs >0.04045<br>
* 	Assume cs is the sRGB component in the range [0,1].<br>
* 	Use the GL_PROXY_TEXTURE_3D target to try out a resolution and format. The implementation will update and recompute its
* best match for the requested storage resolution and format. To then query this state, call glGetTexLevelParameter. If the
* texture cannot be accommodated, texture state is set to 0.<br>
* 	A one-component texture image uses only the red component of the RGBA color extracted from data. A two-component image
* uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA
* components.<br>
*
* @note The glPixelStore mode affects texture images.
* @note data may be a null pointer. In this case texture memory is allocated to accommodate a texture of width width, height height,
*       and depth depth. You can then download subtextures to initialize this texture memory. The image is undefined if the
*       user tries to apply an uninitialized portion of the texture image to a primitive.
* @note glTexImage3D specifies the three-dimensional texture for the current texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX may be used for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.  Format constants other than GL_STENCIL_INDEX
*         and GL_DEPTH_COMPONENT are accepted.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not one of the accepted resolution and format symbolic constants.
* @errors GL_INVALID_VALUE is generated if width, height, or depth is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format or internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24,
*         or GL_DEPTH_COMPONENT32.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexImage3D glad_glTexImage3D
GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
/**
* @name glTexImage3DMultisample - establish the data storage, format, dimensions, and number of samples of a multisample texture's image
* @usage
* @code void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target of the operation. <em class="parameter"><b>target</b></em> must be <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param samples The number of samples in the multisample texture's image.
* @param internalformat The internal format to be used to store the multisample texture's image. <em class="parameter"><b>internalformat</b></em>
*                       must specify a color-renderable, depth-renderable, or stencil-renderable format.
* @param width The width of the multisample texture's image, in texels.
* @param height The height of the multisample texture's image, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @description
* 	glTexImage3DMultisample establishes the data storage, format, dimensions and number of samples of a multisample texture's
* image.<br>
* 	target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. width and heightare the dimensions
* in texels of the texture, and must be in the range zero to the value of GL_MAX_TEXTURE_SIZE minus one. depth is the
* number of array slices in the array texture's image. samples specifies the number of samples in the image and must be in
* the range zero to the value of GL_MAX_SAMPLES minus one.<br>
* 	internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.<br>
* 	If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the same number of samples for all
* texels in the image, and the sample locations will not depend on the internal format or size of the image.<br>
* 	When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch
* and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling
* instructions are allowed on the multisample texture targets.<br>
*
* @note glTexImage2DMultisample is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than
*         the value of GL_MAX_DEPTH_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of
*         GL_MAX_COLOR_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES.
* @errors GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if depth is negative or is greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
*
*/
#define glTexImage3DMultisample glad_glTexImage3DMultisample
GLAD_API_CALL PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
// Unable to find the docs for this function!
#define glTexParameterIiv glad_glTexParameterIiv
GLAD_API_CALL PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
// Unable to find the docs for this function!
#define glTexParameterIuiv glad_glTexParameterIuiv
GLAD_API_CALL PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
// Unable to find the docs for this function!
#define glTexParameterf glad_glTexParameterf
GLAD_API_CALL PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
// Unable to find the docs for this function!
#define glTexParameterfv glad_glTexParameterfv
GLAD_API_CALL PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
// Unable to find the docs for this function!
#define glTexParameteri glad_glTexParameteri
GLAD_API_CALL PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
// Unable to find the docs for this function!
#define glTexParameteriv glad_glTexParameteriv
GLAD_API_CALL PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;
/**
* @name glTexStorage1D, glTextureStorage1D - simultaneously specify storage for all levels of a one-dimensional texture
* @usage
* @code void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @code void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage1D</b>. Must be one of <b>GL_TEXTURE_1D</b>
*               or <b>GL_PROXY_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @description
* 	glTexStorage1D and glTextureStorage1D specify the storage requirements for all levels of a one-dimensional texture simultaneously.
* Once a texture is specified with this command, the format and dimensions of all levels become immutable unless
* it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change.
* Such a texture is referred to as an immutable-format texture.<br>
* 	Calling glTexStorage1D is equivalent, assuming no errors are generated, to executing the following pseudo-code:<br>
* 	Calling glTextureStorage1D is equivalent to the above pseudo-code, where target is the effective target of texture and
* it is as if texture were bound to target for the purposes of glTexImage1D.<br>
* 	Since no texture data is actually provided, the values used in the pseudo-code for format and type are irrelevant and may
* be considered to be any values that are legal for the chosen internalformat enumerant. internalformat must be one of
* the sized internal formats given in Table 1 below, one of the sized depth-component formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24,
* or GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8,
* or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
* GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
* No further changes to the dimensions or format of the texture object may be made. Using any command
* that might alter the dimensions or format of the texture object (such as glTexImage1D or another call to glTexStorage1D)
* will result in the generation of a GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions
* or format of the object.<br>
*
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage1D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if levels is greater than log2 width +1 .
*
*/
#define glTexStorage1D glad_glTexStorage1D
GLAD_API_CALL PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;
/**
* @name glTexStorage2D, glTextureStorage2D - simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
* @usage
* @code void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2D</b>. Must be one of <b>GL_TEXTURE_2D</b>,
*               <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_PROXY_TEXTURE_RECTANGLE</b>, or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @description
* 	glTexStorage2D and glTextureStorage2D specify the storage requirements for all levels of a two-dimensional texture or one-dimensional
* texture array simultaneously. Once a texture is specified with this command, the format and dimensions of
* all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its
* storage requirements may not change. Such a texture is referred to as an immutable-format texture.<br>
* 	The behavior of glTexStorage2D depends on the target parameter. When target is GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_RECTANGLE,
* GL_PROXY_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_CUBE_MAP, calling glTexStorage2D is equivalent, assuming
* no errors are generated, to executing the following pseudo-code:<br>
* 	When target is GL_TEXTURE_CUBE_MAP, glTexStorage2D is equivalent to:<br>
* 	When target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY, glTexStorage2D is equivalent to:<br>
* 	Calling glTextureStorage2D is equivalent to the above pseudo-code, where target is the effective target of texture and
* it is as if texture were bound to target for the purposes of glTexImage2D.<br>
* 	Since no texture data is actually provided, the values used in the pseudo-code for format and type are irrelevant and may
* be considered to be any values that are legal for the chosen internalformat enumerant. internalformat must be one of
* the sized internal formats given in Table 1 below, one of the sized depth-component formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24,
* or GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8,
* or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
* GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
* No further changes to the dimensions or format of the texture object may be made. Using any command
* that might alter the dimensions or format of the texture object (such as glTexImage2D or another call to glTexStorage2D)
* will result in the generation of a GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions
* or format of the object.<br>
*
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than
*         log2 width +1 .
* @errors GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater
*         than log2 max width, height +1 .
*
*/
#define glTexStorage2D glad_glTexStorage2D
GLAD_API_CALL PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;
/**
* @name glTexStorage2DMultisample, glTextureStorage2DMultisample - specify storage for a two-dimensional multisample texture
* @usage
* @code void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @description
* 	glTexStorage2DMultisample and glTextureStorage2DMultisample specify the storage requirements for a two-dimensional multisample
* texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is
* a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such
* a texture is referred to as an immutable-format texture.<br>
* 	samples specifies the number of samples to be used for the texture and must be greater than zero and less than or equal
* to the value of GL_MAX_SAMPLES. internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
* width and height specify the width and height, respectively, of the texture. If fixedsamplelocations is GL_TRUE, the
* image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations
* will not depend on the internal format or size of the image.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTexStorage2DMultisample glad_glTexStorage2DMultisample
GLAD_API_CALL PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;
/**
* @name glTexStorage3D, glTextureStorage3D - simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
* @usage
* @code void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @code void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3D</b>. Must be one of <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_2D_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in texels.
* @description
* 	glTexStorage3D and glTextureStorage3D specify the storage requirements for all levels of a three-dimensional, two-dimensional
* array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions
* of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however,
* its storage requirements may not change. Such a texture is referred to as an immutable-format texture.<br>
* 	The behavior of glTexStorage3D depends on the target parameter. When target is GL_TEXTURE_3D, or GL_PROXY_TEXTURE_3D, calling
* glTexStorage3D is equivalent, assuming no errors are generated, to executing the following pseudo-code:<br>
* 	When target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY,
* glTexStorage3D is equivalent to:<br>
* 	Calling glTextureStorage3D is equivalent to the above pseudo-code, where target is the effective target of texture and
* it is as if texture were bound to target for the purposes of glTexImage3D.<br>
* 	Since no texture data is actually provided, the values used in the pseudo-code for format and type are irrelevant and may
* be considered to be any values that are legal for the chosen internalformat enumerant. internalformat must be one of
* the sized internal formats given in Table 1 below, one of the sized depth-component formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24,
* or GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8,
* or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
* GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
* No further changes to the dimensions or format of the texture object may be made. Using any command
* that might alter the dimensions or format of the texture object (such as glTexImage3D or another call to glTexStorage3D)
* will result in the generation of a GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions
* or format of the object.<br>
*
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height, depth or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D and levels is greater than log2 max
*         width, height, depth +1 .
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXURE_CUBE_MAP_ARRAY,
*         or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is greater than log2 max width, height +1 .
*
*/
#define glTexStorage3D glad_glTexStorage3D
GLAD_API_CALL PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;
/**
* @name glTexStorage3DMultisample, glTextureStorage3DMultisample - specify storage for a two-dimensional multisample array texture
* @usage
* @code void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in layers.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @description
* 	glTexStorage3DMultisample and glTextureStorage3DMultisample specify the storage requirements for a two-dimensional multisample
* array texture. Once a texture is specified with this command, its format and dimensions become immutable unless
* it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change.
* Such a texture is referred to as an immutable-format texture.<br>
* 	samples specifies the number of samples to be used for the texture and must be greater than zero and less than or equal
* to the value of GL_MAX_SAMPLES. internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
* width and height specify the width and height, respectively, of the texture and depth specifies the depth (or the number
* of layers) of the texture. If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the
* same number of samples for all texels in the image, and the sample locations will not depend on the internal format or
* size of the image.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if depth is less than 1 or greater than the value of GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTexStorage3DMultisample glad_glTexStorage3DMultisample
GLAD_API_CALL PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
/**
* @name glTexSubImage1D, glTextureSubImage1D - specify a one-dimensional texture subimage
* @usage
* @code void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage1D</b>. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To
* enable or disable one-dimensional texturing, call glEnable and  glDisable with argument GL_TEXTURE_1D.<br>
* 	glTexSubImage1D and glTextureSubImage1D redefine a contiguous subregion of an existing one-dimensional texture image. The
* texels referenced by pixels replace the portion of the existing texture array with x indices xoffset and xoffset+width-1
* , inclusive. This region may not include any texels outside the range of the texture array as it was originally specified.
* It is not an error to specify a subtexture with width of 0, but such a specification has no effect.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, pixels is treated as a byte offset into the buffer object's data store.<br>
*
* @note glPixelStore modes affect texture images.
* @note glTexSubImage1D and glTextureSubImage1D specify a one-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the allowable values.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , or if xoffset+width > w-b , where w is the GL_TEXTURE_WIDTH, and b is the
*         width of the GL_TEXTURE_BORDER of the texture image being modified. Note that w includes twice the border width.
* @errors GL_INVALID_VALUE is generated if width is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexSubImage1D glad_glTexSubImage1D
GLAD_API_CALL PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
/**
* @name glTexSubImage2D, glTextureSubImage2D - specify a two-dimensional texture subimage
* @usage
* @code void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage2D</b>. Must be <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or <b>GL_TEXTURE_1D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.<br>
* 	glTexSubImage2D and glTextureSubImage2D redefine a contiguous subregion of an existing two-dimensional or one-dimensional
* array texture image. The texels referenced by pixels replace the portion of the existing texture array with x indices
* xoffset and xoffset+width-1 , inclusive, and y indices yoffset and yoffset+height-1 , inclusive. This region may not include
* any texels outside the range of the texture array as it was originally specified. It is not an error to specify a
* subtexture with zero width or height, but such a specification has no effect.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, pixels is treated as a byte offset into the buffer object's data store.<br>
*
* @note glPixelStore modes affect texture images.
* @note glTexSubImage2D and glTextureSubImage3D specify a two-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , where w is
*         the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that
*         w and h include twice the border width.
* @errors GL_INVALID_VALUE is generated if width or height is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexSubImage2D glad_glTexSubImage2D
GLAD_API_CALL PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
/**
* @name glTexSubImage3D, glTextureSubImage3D - specify a three-dimensional texture subimage
* @usage
* @code void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage3D</b>. Must be <b>GL_TEXTURE_3D</b> or <b>GL_TEXTURE_2D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.<br>
* 	glTexSubImage3D and glTextureSubImage3D redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl
* array texture image. The texels referenced by pixels replace the portion of the existing texture array with x indices
* xoffset and xoffset+width-1 , inclusive, y indices yoffset and yoffset+height-1 , inclusive, and z indices zoffset and
* zoffset+depth-1 , inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional
* array textures, the z index refers to the slice index. This region may not include any texels outside the range of
* the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or
* depth but such a specification has no effect.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, pixels is treated as a byte offset into the buffer object's data store.<br>
*
* @note The glPixelStore modes affect texture images.
* @note glTexSubImage3D and glTextureSubImage3D specify a three-dimensional or two-dimensional array subtexture for the current
*       texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , or zoffset<
*         -b , or zoffset+depth > d-b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and
*         b is the border width of the texture image being modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_VALUE is generated if width, height, or depth is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexSubImage3D glad_glTexSubImage3D
GLAD_API_CALL PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;
/**
* @name glTextureBarrier - controls the ordering of reads and writes to rendered fragments across drawing commands
* @usage
* @code void glTextureBarrier(void); @endcode
* @description
* 	The values of rendered fragments are undefined when a shader stage fetches texels and the same texels are written via fragment
* shader outputs, even if the reads and writes are not in the same drawing command. To safely read the result of a
* written texel via a texel fetch in a subsequent drawing command, call glTextureBarrier between the two drawing commands
* to guarantee that writes have completed and caches have been invalidated before subsequent drawing commands are executed.<br>
*
* @note The situation described above is referred to as a rendering feedback loop and is discussed in more detail in section 9.3
*       of the OpenGL 4.5 Specification.
*
* @errors None.
*
*/
#define glTextureBarrier glad_glTextureBarrier
GLAD_API_CALL PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;
/**
* @name glTexBuffer, glTextureBuffer - attach a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer); @endcode
* @code void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexBuffer</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBuffer</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
* @description
* 	glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a specified texture object, and
* specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.<br>
* 	If buffer is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If
* buffer is non-zero, it must be the name of an existing buffer object.<br>
* 	internalformat specifies the storage format, and must be one of the following sized internal formats:<br>
* 	When a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array.
* The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times
* sizeof(base\_type) } } \right\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value
* of GL_BUFFER_SIZE for buffer), and $components$ and $base\_type$ are the element count and base data type for elements,
* as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent
* limit GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer texture is accessed in a shader, the results of a texel
* fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels
* in the texel array.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glTexBuffer if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBuffer if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBuffer if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
*
*/
#define glTextureBuffer glad_glTextureBuffer
GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;
/**
* @name glTexBufferRange, glTextureBufferRange - attach a range of a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size); @endcode
* @code void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexBufferRange</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBufferRange</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
* @param offset Specifies the offset of the start of the range of the buffer's data store to attach.
* @param size Specifies the size of the range of the buffer's data store to attach.
* @description
* 	glTexBufferRange and glTextureBufferRange attach a range of the data store of a specified buffer object to a specified
* texture object, and specify the storage format for the texture image found in the buffer object. The texture object must
* be a buffer texture.<br>
* 	If buffer is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If
* buffer is non-zero, it must be the name of an existing buffer object.<br>
* 	The start and size of the range are specified by offset and size respectively, both measured in basic machine units. offset
* must be greater than or equal to zero, size must be greater than zero, and the sum of offset and size must not exceed
* the value of GL_BUFFER_SIZE for buffer. Furthermore, offset must be an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.<br>
* 	internalformat specifies the storage format, and must be one of the following sized internal formats:<br>
* 	When a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store
* is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor
* { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $components$ and $base\_type$ are the
* element count and base data type for elements, as specified in the table above. The number of texels in the texel array
* is then clamped to the value of the implementation-dependent limit GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer texture is
* accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater
* than or equal to the clamped number of texels in the texel array.<br>
*
*
* @errors GL_INVALID_ENUM is generated by glTexBufferRange if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBufferRange if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBufferRange if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset is negative, if size is less than or equal to zero, or if offset + size is greater
*         than the value of GL_BUFFER_SIZE for buffer.
* @errors GL_INVALID_VALUE is generated if offset is not an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.
*
*/
#define glTextureBufferRange glad_glTextureBufferRange
GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;
// Unable to find the docs for this function!
#define glTextureParameterIiv glad_glTextureParameterIiv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;
// Unable to find the docs for this function!
#define glTextureParameterIuiv glad_glTextureParameterIuiv
GLAD_API_CALL PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;
// Unable to find the docs for this function!
#define glTextureParameterf glad_glTextureParameterf
GLAD_API_CALL PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;
// Unable to find the docs for this function!
#define glTextureParameterfv glad_glTextureParameterfv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;
// Unable to find the docs for this function!
#define glTextureParameteri glad_glTextureParameteri
GLAD_API_CALL PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;
// Unable to find the docs for this function!
#define glTextureParameteriv glad_glTextureParameteriv
GLAD_API_CALL PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;
/**
* @name glTexStorage1D, glTextureStorage1D - simultaneously specify storage for all levels of a one-dimensional texture
* @usage
* @code void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @code void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage1D</b>. Must be one of <b>GL_TEXTURE_1D</b>
*               or <b>GL_PROXY_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @description
* 	glTexStorage1D and glTextureStorage1D specify the storage requirements for all levels of a one-dimensional texture simultaneously.
* Once a texture is specified with this command, the format and dimensions of all levels become immutable unless
* it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change.
* Such a texture is referred to as an immutable-format texture.<br>
* 	Calling glTexStorage1D is equivalent, assuming no errors are generated, to executing the following pseudo-code:<br>
* 	Calling glTextureStorage1D is equivalent to the above pseudo-code, where target is the effective target of texture and
* it is as if texture were bound to target for the purposes of glTexImage1D.<br>
* 	Since no texture data is actually provided, the values used in the pseudo-code for format and type are irrelevant and may
* be considered to be any values that are legal for the chosen internalformat enumerant. internalformat must be one of
* the sized internal formats given in Table 1 below, one of the sized depth-component formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24,
* or GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8,
* or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
* GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
* No further changes to the dimensions or format of the texture object may be made. Using any command
* that might alter the dimensions or format of the texture object (such as glTexImage1D or another call to glTexStorage1D)
* will result in the generation of a GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions
* or format of the object.<br>
*
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage1D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if levels is greater than log2 width +1 .
*
*/
#define glTextureStorage1D glad_glTextureStorage1D
GLAD_API_CALL PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;
/**
* @name glTexStorage2D, glTextureStorage2D - simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
* @usage
* @code void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2D</b>. Must be one of <b>GL_TEXTURE_2D</b>,
*               <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_PROXY_TEXTURE_RECTANGLE</b>, or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @description
* 	glTexStorage2D and glTextureStorage2D specify the storage requirements for all levels of a two-dimensional texture or one-dimensional
* texture array simultaneously. Once a texture is specified with this command, the format and dimensions of
* all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its
* storage requirements may not change. Such a texture is referred to as an immutable-format texture.<br>
* 	The behavior of glTexStorage2D depends on the target parameter. When target is GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_RECTANGLE,
* GL_PROXY_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_CUBE_MAP, calling glTexStorage2D is equivalent, assuming
* no errors are generated, to executing the following pseudo-code:<br>
* 	When target is GL_TEXTURE_CUBE_MAP, glTexStorage2D is equivalent to:<br>
* 	When target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY, glTexStorage2D is equivalent to:<br>
* 	Calling glTextureStorage2D is equivalent to the above pseudo-code, where target is the effective target of texture and
* it is as if texture were bound to target for the purposes of glTexImage2D.<br>
* 	Since no texture data is actually provided, the values used in the pseudo-code for format and type are irrelevant and may
* be considered to be any values that are legal for the chosen internalformat enumerant. internalformat must be one of
* the sized internal formats given in Table 1 below, one of the sized depth-component formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24,
* or GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8,
* or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
* GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
* No further changes to the dimensions or format of the texture object may be made. Using any command
* that might alter the dimensions or format of the texture object (such as glTexImage2D or another call to glTexStorage2D)
* will result in the generation of a GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions
* or format of the object.<br>
*
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than
*         log2 width +1 .
* @errors GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater
*         than log2 max width, height +1 .
*
*/
#define glTextureStorage2D glad_glTextureStorage2D
GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;
/**
* @name glTexStorage2DMultisample, glTextureStorage2DMultisample - specify storage for a two-dimensional multisample texture
* @usage
* @code void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @description
* 	glTexStorage2DMultisample and glTextureStorage2DMultisample specify the storage requirements for a two-dimensional multisample
* texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is
* a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such
* a texture is referred to as an immutable-format texture.<br>
* 	samples specifies the number of samples to be used for the texture and must be greater than zero and less than or equal
* to the value of GL_MAX_SAMPLES. internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
* width and height specify the width and height, respectively, of the texture. If fixedsamplelocations is GL_TRUE, the
* image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations
* will not depend on the internal format or size of the image.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTextureStorage2DMultisample glad_glTextureStorage2DMultisample
GLAD_API_CALL PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;
/**
* @name glTexStorage3D, glTextureStorage3D - simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
* @usage
* @code void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @code void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3D</b>. Must be one of <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_2D_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in texels.
* @description
* 	glTexStorage3D and glTextureStorage3D specify the storage requirements for all levels of a three-dimensional, two-dimensional
* array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions
* of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however,
* its storage requirements may not change. Such a texture is referred to as an immutable-format texture.<br>
* 	The behavior of glTexStorage3D depends on the target parameter. When target is GL_TEXTURE_3D, or GL_PROXY_TEXTURE_3D, calling
* glTexStorage3D is equivalent, assuming no errors are generated, to executing the following pseudo-code:<br>
* 	When target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY,
* glTexStorage3D is equivalent to:<br>
* 	Calling glTextureStorage3D is equivalent to the above pseudo-code, where target is the effective target of texture and
* it is as if texture were bound to target for the purposes of glTexImage3D.<br>
* 	Since no texture data is actually provided, the values used in the pseudo-code for format and type are irrelevant and may
* be considered to be any values that are legal for the chosen internalformat enumerant. internalformat must be one of
* the sized internal formats given in Table 1 below, one of the sized depth-component formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24,
* or GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats, GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8,
* or the stencil-only format, GL_STENCIL_INDEX8. Upon success, the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
* GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT may be discovered by calling glGetTexParameter with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
* No further changes to the dimensions or format of the texture object may be made. Using any command
* that might alter the dimensions or format of the texture object (such as glTexImage3D or another call to glTexStorage3D)
* will result in the generation of a GL_INVALID_OPERATION error, even if it would not, in fact, alter the dimensions
* or format of the object.<br>
*
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height, depth or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D and levels is greater than log2 max
*         width, height, depth +1 .
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXURE_CUBE_MAP_ARRAY,
*         or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is greater than log2 max width, height +1 .
*
*/
#define glTextureStorage3D glad_glTextureStorage3D
GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;
/**
* @name glTexStorage3DMultisample, glTextureStorage3DMultisample - specify storage for a two-dimensional multisample array texture
* @usage
* @code void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in layers.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @description
* 	glTexStorage3DMultisample and glTextureStorage3DMultisample specify the storage requirements for a two-dimensional multisample
* array texture. Once a texture is specified with this command, its format and dimensions become immutable unless
* it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change.
* Such a texture is referred to as an immutable-format texture.<br>
* 	samples specifies the number of samples to be used for the texture and must be greater than zero and less than or equal
* to the value of GL_MAX_SAMPLES. internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
* width and height specify the width and height, respectively, of the texture and depth specifies the depth (or the number
* of layers) of the texture. If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the
* same number of samples for all texels in the image, and the sample locations will not depend on the internal format or
* size of the image.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if depth is less than 1 or greater than the value of GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTextureStorage3DMultisample glad_glTextureStorage3DMultisample
GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;
/**
* @name glTexSubImage1D, glTextureSubImage1D - specify a one-dimensional texture subimage
* @usage
* @code void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage1D</b>. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To
* enable or disable one-dimensional texturing, call glEnable and  glDisable with argument GL_TEXTURE_1D.<br>
* 	glTexSubImage1D and glTextureSubImage1D redefine a contiguous subregion of an existing one-dimensional texture image. The
* texels referenced by pixels replace the portion of the existing texture array with x indices xoffset and xoffset+width-1
* , inclusive. This region may not include any texels outside the range of the texture array as it was originally specified.
* It is not an error to specify a subtexture with width of 0, but such a specification has no effect.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, pixels is treated as a byte offset into the buffer object's data store.<br>
*
* @note glPixelStore modes affect texture images.
* @note glTexSubImage1D and glTextureSubImage1D specify a one-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the allowable values.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , or if xoffset+width > w-b , where w is the GL_TEXTURE_WIDTH, and b is the
*         width of the GL_TEXTURE_BORDER of the texture image being modified. Note that w includes twice the border width.
* @errors GL_INVALID_VALUE is generated if width is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTextureSubImage1D glad_glTextureSubImage1D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;
/**
* @name glTexSubImage2D, glTextureSubImage2D - specify a two-dimensional texture subimage
* @usage
* @code void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage2D</b>. Must be <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or <b>GL_TEXTURE_1D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.<br>
* 	glTexSubImage2D and glTextureSubImage2D redefine a contiguous subregion of an existing two-dimensional or one-dimensional
* array texture image. The texels referenced by pixels replace the portion of the existing texture array with x indices
* xoffset and xoffset+width-1 , inclusive, and y indices yoffset and yoffset+height-1 , inclusive. This region may not include
* any texels outside the range of the texture array as it was originally specified. It is not an error to specify a
* subtexture with zero width or height, but such a specification has no effect.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, pixels is treated as a byte offset into the buffer object's data store.<br>
*
* @note glPixelStore modes affect texture images.
* @note glTexSubImage2D and glTextureSubImage3D specify a two-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , where w is
*         the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that
*         w and h include twice the border width.
* @errors GL_INVALID_VALUE is generated if width or height is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTextureSubImage2D glad_glTextureSubImage2D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;
/**
* @name glTexSubImage3D, glTextureSubImage3D - specify a three-dimensional texture subimage
* @usage
* @code void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage3D</b>. Must be <b>GL_TEXTURE_3D</b> or <b>GL_TEXTURE_2D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @description
* 	Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.<br>
* 	glTexSubImage3D and glTextureSubImage3D redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl
* array texture image. The texels referenced by pixels replace the portion of the existing texture array with x indices
* xoffset and xoffset+width-1 , inclusive, y indices yoffset and yoffset+height-1 , inclusive, and z indices zoffset and
* zoffset+depth-1 , inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional
* array textures, the z index refers to the slice index. This region may not include any texels outside the range of
* the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or
* depth but such a specification has no effect.<br>
* 	If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image
* is specified, pixels is treated as a byte offset into the buffer object's data store.<br>
*
* @note The glPixelStore modes affect texture images.
* @note glTexSubImage3D and glTextureSubImage3D specify a three-dimensional or two-dimensional array subtexture for the current
*       texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , or zoffset<
*         -b , or zoffset+depth > d-b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and
*         b is the border width of the texture image being modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_VALUE is generated if width, height, or depth is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTextureSubImage3D glad_glTextureSubImage3D
GLAD_API_CALL PFNGLTEXTUREVIEWPROC glad_glTextureView;
/**
* @name glTextureView - initialize a texture as a data alias of another texture's data store
* @usage
* @code void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers); @endcode
* @param texture Specifies the texture object to be initialized as a view.
* @param target Specifies the target to be used for the newly initialized texture.
* @param origtexture Specifies the name of a texture object of which to make a view.
* @param internalformat Specifies the internal format for the newly created view.
* @param minlevel Specifies lowest level of detail of the view.
* @param numlevels Specifies the number of levels of detail to include in the view.
* @param minlayer Specifies the index of the first layer to include in the view.
* @param numlayers Specifies the number of layers to include in the view.
* @description
* 	glTextureView initializes a texture object as an alias, or view of another texture object, sharing some or all of the parent
* texture's data store with the initialized texture. texture specifies a name previously reserved by a successful call
* to glGenTextures but that has not yet been bound or given a target. target specifies the target for the newly initialized
* texture and must be compatible with the target of the parent texture, given in origtexture as specified in the following
* table:<br>
* 	The value of GL_TEXTURE_IMMUTABLE_FORMAT for origtexture must be GL_TRUE. After initialization, texture inherits the data
* store of the parent texture, origtexture and is usable as a normal texture object with target target. Data in the shared
* store is reinterpreted with the new internal format specified by internalformat. internalformat must be compatible with
* the internal format of the parent texture as specified in the following table:<br>
* 	If the original texture is an array or has multiple mipmap levels, the parameters minlayer, numlayers, minlevel, and numlevels
* control which of those slices and levels are considered part of the texture. The minlevel and minlayer parameters
* are relative to the view of the original texture. If numlayers or numlevels extend beyond the original texture, they are
* clamped to the max extent of the original texture.<br>
* 	If the new texture's target is GL_TEXTURE_CUBE_MAP, the clamped numlayers must be equal to 6. If the new texture's target
* is GL_TEXTURE_CUBE_MAP_ARRAY, then numlayers counts layer-faces rather than layers, and the clamped numlayers must be
* a multiple of 6. If the new texture's target is GL_TEXTURE_CUBE_MAP or GL_TEXTURE_CUBE_MAP_ARRAY, the width and height
* of the original texture's levels must be equal.<br>
* 	When the original texture's target is GL_TEXTURE_CUBE_MAP, the layer parameters are interpreted in the same order as if
* it were a GL_TEXTURE_CUBE_MAP_ARRAY with 6 layer-faces.<br>
* 	If target is GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_2D_MULTISAMPLE, numlayers
* must equal 1.<br>
* 	The dimensions of the original texture must be less than or equal to the maximum supported dimensions of the new target.
* For example, if the original texture has a GL_TEXTURE_2D_ARRAY target and its width is greater than GL_MAX_CUBE_MAP_TEXTURE_SIZE,
* an error will be generated if glTextureView is called to create a GL_TEXTURE_CUBE_MAP view.<br>
* 	Texture commands that take a level or layer parameter, such as glTexSubImage2D, interpret that parameter to be relative
* to the view of the texture. i.e. the mipmap level of the data store that would be updated via glTexSubImage2D would be
* the sum of level and the value of GL_TEXTURE_VIEW_MIN_LEVEL.<br>
*
*
* @errors GL_INVALID_VALUE is generated if minlayer or minlevel are larger than the greatest layer or level of origtexture.
* @errors GL_INVALID_OPERATION is generated if target is not compatible with the target of origtexture.
* @errors GL_INVALID_OPERATION is generated if the dimensions of origtexture are greater than the maximum supported dimensions for
*         target.
* @errors GL_INVALID_OPERATION is generated if internalformat is not compatible with the internal format of origtexture.
* @errors GL_INVALID_OPERATION is generated if texture has already been bound or otherwise given a target.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for origtexture is not GL_TRUE.
* @errors GL_INVALID_OPERATION is generated if origtexture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generaged if target is GL_TEXTURE_CUBE_MAP and numlayers is not 6, or if target is GL_TEXTURE_CUBE_MAP_ARRAY
*         and numlayers is not an integer multiple of 6.
* @errors GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_2D_MULTISAMPLE
*         and numlayers does not equal 1.
* @errors GL_INVALID_VALUE is generated if texture zero or is not the name of a texture previously returned from a successful call
*         to glGenTextures.
*
*/
#define glTextureView glad_glTextureView
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;
/**
* @name glTransformFeedbackBufferBase - bind a buffer object to a transform feedback buffer object
* @usage
* @code void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer); @endcode
* @param xfb Name of the transform feedback buffer object.
* @param index Index of the binding point within <em class="parameter"><b>xfb</b></em>.
* @param buffer Name of the buffer object to bind to the specified binding point.
* @description
* 	glTransformFeedbackBufferBase binds the buffer object buffer to the binding point at index index of the transform feedback
* object xfb.<br>
*
* @note Calling glTransformFeedbackBufferBase is equivalent to calling glTransformFeedbackBufferRange with offset zero and size
*       equal to the size of buffer.
*
* @errors GL_INVALID_OPERATION is generated if xfb is not the name of an existing transform feedback object.
* @errors GL_INVALID_VALUE is generated if in buffer is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of transform feedback buffer binding points
*         (the value of GL_TRANSFORM_FEEDBACK_BUFFER_BINDING).
*
*/
#define glTransformFeedbackBufferBase glad_glTransformFeedbackBufferBase
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;
/**
* @name glTransformFeedbackBufferRange - bind a range within a buffer object to a transform feedback buffer object
* @usage
* @code void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size); @endcode
* @param xfb Name of the transform feedback buffer object.
* @param index Index of the binding point within <em class="parameter"><b>xfb</b></em>.
* @param buffer Name of the buffer object to bind to the specified binding point.
* @param offset The starting offset in basic machine units into the buffer object.
* @param size The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed
*             target.
* @description
* 	glTransformFeedbackBufferRange binds a range of the buffer object buffer represented by offset and size to the binding
* point at index index of the transform feedback object xfb.<br>
* 	offset specifies the offset in basic machine units into the buffer object buffer and size specifies the amount of data
* that can be read from the buffer object while used as an indexed target.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if xfb is not the name of an existing transform feedback object.
* @errors GL_INVALID_VALUE is generated if in buffer is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of transform feedback buffer binding points
*         (the value of GL_TRANSFORM_FEEDBACK_BUFFER_BINDING).
* @errors GL_INVALID_VALUE is generated if offset is negative.
* @errors GL_INVALID_VALUE is generated if buffer is non-zero and either size is less than or equal to zero, or offset + size is greater
*         than the value of GL_BUFFER_SIZE for buffer.
*
*/
#define glTransformFeedbackBufferRange glad_glTransformFeedbackBufferRange
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
/**
* @name glTransformFeedbackVaryings - specify values to record in transform feedback buffers
* @usage
* @code void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char **varyings, GLenum bufferMode); @endcode
* @param program The name of the target program object.
* @param count The number of varying variables used for transform feedback.
* @param varyings An array of <em class="parameter"><b>count</b></em> zero-terminated strings specifying the names of the varying variables
*                 to use for transform feedback.
* @param bufferMode Identifies the mode used to capture the varying variables when transform feedback is active. <em class="parameter"><b>bufferMode</b></em>
*                   must be <b>GL_INTERLEAVED_ATTRIBS</b> or <b>GL_SEPARATE_ATTRIBS</b>.
* @description
* 	The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are specified using glTransformFeedbackVaryings.
* When a geometry shader is active, transform feedback records the values of selected geometry shader
* output variables from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are recorded.<br>
* 	The state set by glTranformFeedbackVaryings is stored and takes effect next time glLinkProgram is called on program. When
* glLinkProgram is called, program is linked so that the values of the specified varying variables for the vertices of
* each primitive generated by the GL are written to a single buffer object if bufferMode is GL_INTERLEAVED_ATTRIBS or multiple
* buffer objects if bufferMode is GL_SEPARATE_ATTRIBS.<br>
* 	glTransformFeedbackVaryings can also special identifiers if bufferMode is GL_INTERLEAVED_ATTRIBS:<br>
* 	Subsequent variables in varyings will be assigned to the next buffer binding point.<br>
* 	Where # may be 1, 2, 3, or 4. The variable is treated as having this number of components, but the contents of the memory
* are preserved under feedback operations.<br>
* 	In addition to the errors generated by glTransformFeedbackVaryings, the program program will fail to link if:<br>
* 	The count specified by glTransformFeedbackVaryings is non-zero, but the program object has no vertex or geometry shader.<br>
* 	Any variable name specified in the varyings array is not declared as an output in the vertex shader (or the geometry shader,
* if active), or is not one of the special identifiers listed above.<br>
* 	Special identifiers appear in a varyings array where bufferMode is not GL_INTERLEAVED_ATTRIBS.<br>
* 	Any two entries in the varyings array, which are not one of the special varyings above, specify the same varying variable.<br>
* 	Discounting any special identifiers, the total number of components to capture in any varying variable in varyings is greater
* than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS and the buffer mode is GL_SEPARATE_ATTRIBS.<br>
* 	The total number of components to capture is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
* and the buffer mode is GL_INTERLEAVED_ATTRIBS.<br>
*
* @note glGetTransformFeedbackVarying is available only if the GL version is 3.0 or greater.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object.
* @errors GL_INVALID_VALUE is generated if bufferMode is GL_SEPARATE_ATTRIBS and count is greater than the implementation-dependent
*         limit GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
*
*/
#define glTransformFeedbackVaryings glad_glTransformFeedbackVaryings
GLAD_API_CALL PFNGLUNIFORM1DPROC glad_glUniform1d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1d glad_glUniform1d
GLAD_API_CALL PFNGLUNIFORM1DVPROC glad_glUniform1dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1dv glad_glUniform1dv
GLAD_API_CALL PFNGLUNIFORM1FPROC glad_glUniform1f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1f glad_glUniform1f
GLAD_API_CALL PFNGLUNIFORM1FVPROC glad_glUniform1fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1fv glad_glUniform1fv
GLAD_API_CALL PFNGLUNIFORM1IPROC glad_glUniform1i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1i glad_glUniform1i
GLAD_API_CALL PFNGLUNIFORM1IVPROC glad_glUniform1iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1iv glad_glUniform1iv
GLAD_API_CALL PFNGLUNIFORM1UIPROC glad_glUniform1ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1ui glad_glUniform1ui
GLAD_API_CALL PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1uiv glad_glUniform1uiv
GLAD_API_CALL PFNGLUNIFORM2DPROC glad_glUniform2d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2d glad_glUniform2d
GLAD_API_CALL PFNGLUNIFORM2DVPROC glad_glUniform2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2dv glad_glUniform2dv
GLAD_API_CALL PFNGLUNIFORM2FPROC glad_glUniform2f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2f glad_glUniform2f
GLAD_API_CALL PFNGLUNIFORM2FVPROC glad_glUniform2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2fv glad_glUniform2fv
GLAD_API_CALL PFNGLUNIFORM2IPROC glad_glUniform2i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2i glad_glUniform2i
GLAD_API_CALL PFNGLUNIFORM2IVPROC glad_glUniform2iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2iv glad_glUniform2iv
GLAD_API_CALL PFNGLUNIFORM2UIPROC glad_glUniform2ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2ui glad_glUniform2ui
GLAD_API_CALL PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2uiv glad_glUniform2uiv
GLAD_API_CALL PFNGLUNIFORM3DPROC glad_glUniform3d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3d glad_glUniform3d
GLAD_API_CALL PFNGLUNIFORM3DVPROC glad_glUniform3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3dv glad_glUniform3dv
GLAD_API_CALL PFNGLUNIFORM3FPROC glad_glUniform3f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3f glad_glUniform3f
GLAD_API_CALL PFNGLUNIFORM3FVPROC glad_glUniform3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3fv glad_glUniform3fv
GLAD_API_CALL PFNGLUNIFORM3IPROC glad_glUniform3i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3i glad_glUniform3i
GLAD_API_CALL PFNGLUNIFORM3IVPROC glad_glUniform3iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3iv glad_glUniform3iv
GLAD_API_CALL PFNGLUNIFORM3UIPROC glad_glUniform3ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3ui glad_glUniform3ui
GLAD_API_CALL PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3uiv glad_glUniform3uiv
GLAD_API_CALL PFNGLUNIFORM4DPROC glad_glUniform4d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4d glad_glUniform4d
GLAD_API_CALL PFNGLUNIFORM4DVPROC glad_glUniform4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4dv glad_glUniform4dv
GLAD_API_CALL PFNGLUNIFORM4FPROC glad_glUniform4f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4f glad_glUniform4f
GLAD_API_CALL PFNGLUNIFORM4FVPROC glad_glUniform4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4fv glad_glUniform4fv
GLAD_API_CALL PFNGLUNIFORM4IPROC glad_glUniform4i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4i glad_glUniform4i
GLAD_API_CALL PFNGLUNIFORM4IVPROC glad_glUniform4iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4iv glad_glUniform4iv
GLAD_API_CALL PFNGLUNIFORM4UIPROC glad_glUniform4ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4ui glad_glUniform4ui
GLAD_API_CALL PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4uiv glad_glUniform4uiv
GLAD_API_CALL PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
/**
* @name glUniformBlockBinding - assign a binding point to an active uniform block
* @usage
* @code void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding); @endcode
* @param program The name of a program object containing the active uniform block whose binding to assign.
* @param uniformBlockIndex The index of the active uniform block within <em class="parameter"><b>program</b></em> whose binding to assign.
* @param uniformBlockBinding Specifies the binding point to which to bind the uniform block with index <em class="parameter"><b>uniformBlockIndex</b></em>
*                            within <em class="parameter"><b>program</b></em>.
* @description
* 	Binding points for active uniform blocks are assigned using glUniformBlockBinding. Each of a program's active uniform blocks
* has a corresponding uniform buffer binding point. program is the name of a program object for which the command glLinkProgram
* has been issued in the past.<br>
* 	If successful, glUniformBlockBinding specifies that program will use the data store of the buffer object bound to the binding
* point uniformBlockBinding to extract the values of the uniforms in the uniform block identified by uniformBlockIndex.<br>
* 	When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform
* blocks is reset to zero.<br>
*
* @note glUniformBlockBinding is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_VALUE is generated if uniformBlockIndex is not an active uniform block index of program.
* @errors GL_INVALID_VALUE is generated if uniformBlockBinding is greater than or equal to the value of GL_MAX_UNIFORM_BUFFER_BINDINGS.
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object generated by the GL.
*
*/
#define glUniformBlockBinding glad_glUniformBlockBinding
GLAD_API_CALL PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2dv glad_glUniformMatrix2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2fv glad_glUniformMatrix2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x3dv glad_glUniformMatrix2x3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x3fv glad_glUniformMatrix2x3fv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x4dv glad_glUniformMatrix2x4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x4fv glad_glUniformMatrix2x4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3dv glad_glUniformMatrix3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3fv glad_glUniformMatrix3fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x2dv glad_glUniformMatrix3x2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x2fv glad_glUniformMatrix3x2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x4dv glad_glUniformMatrix3x4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x4fv glad_glUniformMatrix3x4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4dv glad_glUniformMatrix4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4fv glad_glUniformMatrix4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x2dv glad_glUniformMatrix4x2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x2fv glad_glUniformMatrix4x2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x3dv glad_glUniformMatrix4x3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @description
* 	glUniform modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to
* be modified is specified by location, which should be a value returned by glGetUniformLocation. glUniform operates on the
* program object that was made part of current state by calling glUseProgram.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui} are used to change the value of the uniform variable specified by location using
* the values passed as arguments. The number specified in the command should match the number of components in the data
* type of the specified uniform variable (e.g., 1 for float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
* The suffix f indicates that floating-point values are being passed; the suffix i indicates that integer values are being
* passed; the suffix ui indicates that unsigned integer values are being passed, and this type should also match the
* data type of the specified uniform variable. The i variants of this function should be used to provide values for uniform
* variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui variants of this function should be used to
* provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The f variants should
* be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the i,
* ui or f variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these.
* The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.<br>
* 	All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully.
* They retain the values assigned to them by a call to glUniform  until the next successful link operation occurs on
* the program object, when they are once again initialized to 0.<br>
* 	The commands glUniform{1|2|3|4}{f|i|ui}v can be used to modify a single uniform variable or a uniform variable array. These
* commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array.
* A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used
* to modify an entire array or part of an array. When loading n elements starting at an arbitrary position m in a uniform
* variable array, elements m + n - 1 in the array will be replaced with the new values. If m + n - 1 is larger than the
* size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number
* specified in the name of the command indicates the number of components for each element in value, and it should match
* the number of components in the data type of the specified uniform variable (e.g., 1 for float, int, bool; 2 for vec2,
* ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform
* variable as described previously for glUniform{1|2|3|4}{f|i|ui}.<br>
* 	For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command
* (e.g., glUniform3f or glUniform3fv can be used to load a uniform variable array of type vec3). The number of elements
* of the uniform variable array to be modified is specified by count<br>
* 	The commands glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to modify a matrix or an array of matrices. The
* numbers in the command name are interpreted as the dimensionality of the matrix. The number 2 indicates a 2 × 2 matrix (i.e.,
* 4 values), the number 3 indicates a 3 × 3 matrix (i.e., 9 values), and the number 4 indicates a 4 × 4 matrix (i.e.,
* 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and
* the second number representing the number of rows.  For example, 2x4 indicates a 2 × 4 matrix with 2 columns and 4 rows
* (i.e., 8 values). If transpose is GL_FALSE, each matrix is assumed to be supplied in column major order. If transpose is
* GL_TRUE, each matrix is assumed to be supplied in row major order. The count argument indicates the number of matrices
* to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be
* used to modify an array of matrices.<br>
*
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x3fv glad_glUniformMatrix4x3fv
GLAD_API_CALL PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;
// Unable to find the docs for this function!
#define glUniformSubroutinesuiv glad_glUniformSubroutinesuiv
GLAD_API_CALL PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
/**
* @name glUnmapBuffer, glUnmapNamedBuffer - release the mapping of a buffer object's data store into the client's address space
* @usage
* @code GLboolean glUnmapBuffer(GLenum target); @endcode
* @code GLboolean glUnmapNamedBuffer(GLuint buffer); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glUnmapBuffer</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glUnmapNamedBuffer</b>.
* @description
* 	glUnmapBuffer and glUnmapNamedBuffer unmap (release) any mapping of a specified buffer object into the client's address
* space (see glMapBufferRange and glMapBuffer).<br>
* 	If a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated
* by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully
* mapped with GL_MAP_PERSISTENT_BIT (see glMapBufferRange). When a data store is unmapped, the mapped pointer becomes invalid.<br>
* 	glUnmapBuffer returns GL_TRUE unless the data store contents have become corrupt during the time the data store was mapped.
* This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes.
* In such situations, GL_FALSE is returned and the data store contents are undefined. An application must detect this
* rare condition and reinitialize the data store.<br>
* 	A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated
* with glBufferData).<br>
*
* @note If an error is generated, glUnmapBuffer returns GL_FALSE.
* @note The GL_ATOMIC_COUNTER_BUFFER target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glUnmapBuffer if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glUnmapBuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glUnmapNamedBuffer if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not in a mapped state.
*
*/
#define glUnmapBuffer glad_glUnmapBuffer
GLAD_API_CALL PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;
/**
* @name glUnmapBuffer, glUnmapNamedBuffer - release the mapping of a buffer object's data store into the client's address space
* @usage
* @code GLboolean glUnmapBuffer(GLenum target); @endcode
* @code GLboolean glUnmapNamedBuffer(GLuint buffer); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glUnmapBuffer</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glUnmapNamedBuffer</b>.
* @description
* 	glUnmapBuffer and glUnmapNamedBuffer unmap (release) any mapping of a specified buffer object into the client's address
* space (see glMapBufferRange and glMapBuffer).<br>
* 	If a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated
* by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully
* mapped with GL_MAP_PERSISTENT_BIT (see glMapBufferRange). When a data store is unmapped, the mapped pointer becomes invalid.<br>
* 	glUnmapBuffer returns GL_TRUE unless the data store contents have become corrupt during the time the data store was mapped.
* This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes.
* In such situations, GL_FALSE is returned and the data store contents are undefined. An application must detect this
* rare condition and reinitialize the data store.<br>
* 	A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated
* with glBufferData).<br>
*
* @note If an error is generated, glUnmapBuffer returns GL_FALSE.
* @note The GL_ATOMIC_COUNTER_BUFFER target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glUnmapBuffer if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glUnmapBuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glUnmapNamedBuffer if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not in a mapped state.
*
*/
#define glUnmapNamedBuffer glad_glUnmapNamedBuffer
GLAD_API_CALL PFNGLUSEPROGRAMPROC glad_glUseProgram;
/**
* @name glUseProgram - Installs a program object as part of current rendering state
* @usage
* @code void glUseProgram(GLuint program); @endcode
* @param program Specifies the handle of the program object whose executables are to be used as part of current rendering state.
* @description
* 	glUseProgram installs the program object specified by program as part of current rendering state. One or more executables
* are created in a program object by successfully attaching shader objects to it with glAttachShader, successfully compiling
* the shader objects with glCompileShader, and successfully linking the program object with glLinkProgram.<br>
* 	A program object will contain an executable that will run on the vertex processor if it contains one or more shader objects
* of type GL_VERTEX_SHADER that have been successfully compiled and linked. A program object will contain an executable
* that will run on the geometry processor if it contains one or more shader objects of type GL_GEOMETRY_SHADER that have
* been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment
* processor if it contains one or more shader objects of type GL_FRAGMENT_SHADER that have been successfully compiled
* and linked.<br>
* 	While a program object is in use, applications are free to modify attached shader objects, compile attached shader objects,
* attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables
* that are part of the current state. However, relinking the program object that is currently in use will install
* the program object as part of the current rendering state if the link operation was successful (see glLinkProgram ). If
* the program object currently in use is relinked unsuccessfully, its link status will be set to GL_FALSE, but the executables
* and associated state will remain part of the current state until a subsequent call to glUseProgram removes it from
* use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.<br>
* 	If program is zero, then the current rendering state refers to an invalid program object and the results of shader execution
* are undefined. However, this is not an error.<br>
* 	If program does not contain shader objects of type GL_FRAGMENT_SHADER, an executable will be installed on the vertex, and
* possibly geometry processors, but the results of fragment shader execution will be undefined.<br>
*
* @note Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the
*       server sides of the contexts share the same address space. If the name space is shared across contexts, any attached
*       objects and the data associated with those attached objects are shared as well.
* @note Applications are responsible for providing the synchronization across API calls when objects are accessed from different
*       execution threads.
*
* @errors GL_INVALID_VALUE is generated if program is neither 0 nor a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program could not be made part of current state.
* @errors GL_INVALID_OPERATION is generated if transform feedback mode is active.
*
*/
#define glUseProgram glad_glUseProgram
GLAD_API_CALL PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;
/**
* @name glUseProgramStages - bind stages of a program object to a program pipeline
* @usage
* @code void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program); @endcode
* @param pipeline Specifies the program pipeline object to which to bind stages from <em class="parameter"><b>program</b></em>.
* @param stages Specifies a set of program stages to bind to the program pipeline object.
* @param program Specifies the program object containing the shader executables to use in <em class="parameter"><b>pipeline</b></em>.
* @description
* 	glUseProgramStages binds executables from a program object associated with a specified set of shader stages to the program
* pipeline object given by pipeline. pipeline specifies the program pipeline object to which to bind the executables.
* stages contains a logical combination of bits indicating the shader stages to use within program with the program pipeline
* object pipeline. stages must be a logical combination of GL_VERTEX_SHADER_BIT, GL_TESS_CONTROL_SHADER_BIT, GL_TESS_EVALUATION_SHADER_BIT,
* GL_GEOMETRY_SHADER_BIT, GL_FRAGMENT_SHADER_BIT and GL_COMPUTE_SHADER_BIT. Additionally, the special
* value GL_ALL_SHADER_BITS may be specified to indicate that all executables contained in program should be installed in
* pipeline.<br>
* 	If program refers to a program object with a valid shader attached for an indicated shader stage, glUseProgramStages installs
* the executable code for that stage in the indicated program pipeline object pipeline. If program is zero, or refers
* to a program object with no valid shader executable for a given stage, it is as if the pipeline object has no programmable
* stage configured for the indicated shader stages. If stages contains bits other than those listed above, and is not
* equal to GL_ALL_SHADER_BITS, an error is generated.<br>
*
* @note The GL_COMPUTE_SHADER_BIT bit is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_VALUE is generated if shaders contains set bits that are not recognized, and is not the reserved value GL_ALL_SHADER_BITS.
* @errors GL_INVALID_OPERATION is generated if program refers to a program object that was not linked with its GL_PROGRAM_SEPARABLE
*         status set.
* @errors GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked.
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glUseProgramStages glad_glUseProgramStages
GLAD_API_CALL PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
/**
* @name glValidateProgram - Validates a program object
* @usage
* @code void glValidateProgram(GLuint program); @endcode
* @param program Specifies the handle of the program object to be validated.
* @description
* 	glValidateProgram checks to see whether the executables contained in program can execute given the current OpenGL state.
* The information generated by the validation process will be stored in program's information log. The validation information
* may consist of an empty string, or it may be a string containing information about how the current program object
* interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information
* about why the current program is inefficient, suboptimal, failing to execute, and so on.<br>
* 	The status of the validation operation will be stored as part of the program object's state. This value will be set to
* GL_TRUE if the validation succeeded, and GL_FALSE otherwise. It can be queried by calling glGetProgram with arguments program
* and GL_VALIDATE_STATUS. If validation is successful, program is guaranteed to execute given the current state. Otherwise,
* program is guaranteed to not execute.<br>
* 	This function is typically useful only during application development. The informational string stored in the information
* log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations
* to produce identical information strings.<br>
*
* @note This function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued
*       while programmable shaders are part of current state. The error GL_INVALID_OPERATION will be generated by any command
*       that triggers the rendering of geometry if:
* @note any two active samplers in the current program object are of different types, but refer to the same texture image unit,
* @note the number of active samplers in the program exceeds the maximum number of texture image units allowed.
* @note It may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are
*       issued. Therefore, applications are advised to make calls to glValidateProgram to detect these issues during application
*       development.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
*
*/
#define glValidateProgram glad_glValidateProgram
GLAD_API_CALL PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;
/**
* @name glValidateProgramPipeline - validate a program pipeline object against current GL state
* @usage
* @code void glValidateProgramPipeline(GLuint pipeline); @endcode
* @param pipeline Specifies the name of a program pipeline object to validate.
* @description
* 	glValidateProgramPipeline instructs the implementation to validate the shader executables contained in pipeline against
* the current GL state. The implementation may use this as an opportunity to perform any internal shader modifications that
* may be required to ensure correct operation of the installed shaders given the current GL state.<br>
* 	After a program pipeline has been validated, its validation status is set to GL_TRUE. The validation status of a program
* pipeline object may be queried by calling glGetProgramPipeline with parameter GL_VALIDATE_STATUS.<br>
* 	If pipeline is a name previously returned from a call to glGenProgramPipelines but that has not yet been bound by a call
* to glBindProgramPipeline, a new program pipeline object is created with name pipeline and the default state vector.<br>
*
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glValidateProgramPipeline glad_glValidateProgramPipeline
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;
/**
* @name glVertexAttribBinding - associate a vertex attribute and a vertex buffer binding for a vertex array object
* @usage
* @code void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex); @endcode
* @code void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttribBinding</b>.
* @param attribindex The index of the attribute to associate with a vertex buffer binding.
* @param bindingindex The index of the vertex buffer binding with which to associate the generic vertex attribute.
* @description
* 	glVertexAttribBinding and glVertexArrayAttribBinding establishes an association between the generic vertex attribute of
* a vertex array object whose index is given by attribindex, and a vertex buffer binding whose index is given by bindingindex.
* For glVertexAttribBinding, the vertex array object affected is that currently bound. For glVertexArrayAttribBinding,
* vaobj is the name of the vertex array object.<br>
* 	attribindex must be less than the value of GL_MAX_VERTEX_ATTRIBS and bindingindex must be less than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glVertexAttribBinding if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribBinding if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
*
*/
#define glVertexArrayAttribBinding glad_glVertexArrayAttribBinding
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @description
* 	glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat, as well as glVertexArrayAttribFormat, glVertexArrayAttribIFormat
* and glVertexArrayAttribLFormat specify the organization of data in vertex arrays. The first three calls
* operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID
* vaobj. attribindex specifies the index of the generic vertex attribute array whose data layout is being described, and
* must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
* 	size determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or
* GL_BGRA. type indicates the type of the data. If type is one of GL_BYTE, GL_SHORT, GL_INT, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT,
* and GL_DOUBLE indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values
* GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, and GL_UNSIGNED_INT indicate types GLubyte, GLushort, and GLuint, respectively;
* the values GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed or unsigned elements
* packed into a single GLuint; and the value GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values
* packed into a single GLuint.<br>
* 	glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for data associated with a generic attribute
* variable declared as 64-bit double precision components. For glVertexAttribLFormat and glVertexArrayAttribLFormat,
* type must be GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat, which will cause data declared
* as GL_DOUBLE to be converted to 32-bit representation, glVertexAttribLFormat and glVertexArrayAttribLFormat cause such
* data to be left in its natural, 64-bit representation.<br>
* 	For glVertexAttribFormat and glVertexArrayAttribFormat, if normalized is GL_TRUE, then integer data is normalized to the
* range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
* converted to floating point.<br>
* 	relativeoffset is the offset, measured in basic machine units of the first element relative to the start of the vertex
* buffer binding this attribute fetches from.<br>
* 	glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe vertex attribute layout for floating-point
* vertex attributes, glVertexAttribIFormat and glVertexArrayAttribIFormat should be used to describe vertex attribute layout
* for integer vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to describe the
* layout for 64-bit vertex attributes. Data for an array specified by glVertexAttribIFormat and glVertexArrayAttribIFormat
* will always be left as integer values; such data are referred to as pure integers.<br>
*
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexArrayAttribFormat glad_glVertexArrayAttribFormat
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @description
* 	glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat, as well as glVertexArrayAttribFormat, glVertexArrayAttribIFormat
* and glVertexArrayAttribLFormat specify the organization of data in vertex arrays. The first three calls
* operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID
* vaobj. attribindex specifies the index of the generic vertex attribute array whose data layout is being described, and
* must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
* 	size determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or
* GL_BGRA. type indicates the type of the data. If type is one of GL_BYTE, GL_SHORT, GL_INT, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT,
* and GL_DOUBLE indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values
* GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, and GL_UNSIGNED_INT indicate types GLubyte, GLushort, and GLuint, respectively;
* the values GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed or unsigned elements
* packed into a single GLuint; and the value GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values
* packed into a single GLuint.<br>
* 	glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for data associated with a generic attribute
* variable declared as 64-bit double precision components. For glVertexAttribLFormat and glVertexArrayAttribLFormat,
* type must be GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat, which will cause data declared
* as GL_DOUBLE to be converted to 32-bit representation, glVertexAttribLFormat and glVertexArrayAttribLFormat cause such
* data to be left in its natural, 64-bit representation.<br>
* 	For glVertexAttribFormat and glVertexArrayAttribFormat, if normalized is GL_TRUE, then integer data is normalized to the
* range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
* converted to floating point.<br>
* 	relativeoffset is the offset, measured in basic machine units of the first element relative to the start of the vertex
* buffer binding this attribute fetches from.<br>
* 	glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe vertex attribute layout for floating-point
* vertex attributes, glVertexAttribIFormat and glVertexArrayAttribIFormat should be used to describe vertex attribute layout
* for integer vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to describe the
* layout for 64-bit vertex attributes. Data for an array specified by glVertexAttribIFormat and glVertexArrayAttribIFormat
* will always be left as integer values; such data are referred to as pure integers.<br>
*
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexArrayAttribIFormat glad_glVertexArrayAttribIFormat
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @description
* 	glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat, as well as glVertexArrayAttribFormat, glVertexArrayAttribIFormat
* and glVertexArrayAttribLFormat specify the organization of data in vertex arrays. The first three calls
* operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID
* vaobj. attribindex specifies the index of the generic vertex attribute array whose data layout is being described, and
* must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
* 	size determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or
* GL_BGRA. type indicates the type of the data. If type is one of GL_BYTE, GL_SHORT, GL_INT, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT,
* and GL_DOUBLE indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values
* GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, and GL_UNSIGNED_INT indicate types GLubyte, GLushort, and GLuint, respectively;
* the values GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed or unsigned elements
* packed into a single GLuint; and the value GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values
* packed into a single GLuint.<br>
* 	glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for data associated with a generic attribute
* variable declared as 64-bit double precision components. For glVertexAttribLFormat and glVertexArrayAttribLFormat,
* type must be GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat, which will cause data declared
* as GL_DOUBLE to be converted to 32-bit representation, glVertexAttribLFormat and glVertexArrayAttribLFormat cause such
* data to be left in its natural, 64-bit representation.<br>
* 	For glVertexAttribFormat and glVertexArrayAttribFormat, if normalized is GL_TRUE, then integer data is normalized to the
* range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
* converted to floating point.<br>
* 	relativeoffset is the offset, measured in basic machine units of the first element relative to the start of the vertex
* buffer binding this attribute fetches from.<br>
* 	glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe vertex attribute layout for floating-point
* vertex attributes, glVertexAttribIFormat and glVertexArrayAttribIFormat should be used to describe vertex attribute layout
* for integer vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to describe the
* layout for 64-bit vertex attributes. Data for an array specified by glVertexAttribIFormat and glVertexArrayAttribIFormat
* will always be left as integer values; such data are referred to as pure integers.<br>
*
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexArrayAttribLFormat glad_glVertexArrayAttribLFormat
GLAD_API_CALL PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;
/**
* @name glVertexBindingDivisor, glVertexArrayBindingDivisor - modify the rate at which generic vertex attributes
advance
* @usage
* @code void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor); @endcode
* @code void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayBindingDivisor</b> function.
* @param bindingindex The index of the binding whose divisor to modify.
* @param divisor The new value for the instance step rate to apply.
* @description
* 	glVertexBindingDivisor and glVertexArrayBindingDivisor modify the rate at which generic vertex attributes advance when
* rendering multiple instances of primitives in a single draw command. If divisor is zero, the attributes using the buffer
* bound to bindingindex advance once per vertex. If divisor is non-zero, the attributes advance once per divisor instances
* of the set(s) of vertices being rendered. An attribute is referred to as instanced if the corresponding divisor value
* is non-zero.<br>
* 	glVertexBindingDivisor uses currently bound vertex array object , whereas glVertexArrayBindingDivisor updates state of
* the vertex array object with ID vaobj.<br>
*
*
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION by glVertexBindingDivisor is generated if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayBindingDivisor if vaobj is not the name of an existing vertex array object.
*
*/
#define glVertexArrayBindingDivisor glad_glVertexArrayBindingDivisor
GLAD_API_CALL PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;
/**
* @name glVertexArrayElementBuffer - configures element array buffer binding of a vertex array object
* @usage
* @code void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer); @endcode
* @param vaobj Specifies the name of the vertex array object.
* @param buffer Specifies the name of the buffer object to use for the element array buffer binding.
* @description
* 	glVertexArrayElementBuffer binds a buffer object with id buffer to the element array buffer bind point of a vertex array
* object with id vaobj. If buffer is zero, any existing element array buffer binding to vaobj is removed.<br>
*
*
* @errors GL_INVALID_OPERATION error is generated if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION error is generated if buffer is not zero or the name of an existing buffer object.
*
*/
#define glVertexArrayElementBuffer glad_glVertexArrayElementBuffer
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;
/**
* @name glBindVertexBuffer, glVertexArrayVertexBuffer - bind a buffer to a vertex buffer bind point
* @usage
* @code void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @code void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @param vaobj Specifies the name of the vertex array object to be used by <b>glVertexArrayVertexBuffer</b> function.
* @param bindingindex The index of the vertex buffer binding point to which to bind the buffer.
* @param buffer The name of a buffer to bind to the vertex buffer binding point.
* @param offset The offset of the first element of the buffer.
* @param stride The distance between elements within the buffer.
* @description
* 	glBindVertexBuffer and glVertexArrayVertexBuffer bind the buffer named buffer to the vertex buffer binding point whose
* index is given by bindingindex. glBindVertexBuffer modifies the binding of the currently bound vertex array object, whereas
* glVertexArrayVertexBuffer allows the caller to specify ID of the vertex array object with an argument named vaobj, for
* which the binding should be modified. offset and stride specify the offset of the first element within the buffer and
* the distance between elements within the buffer, respectively, and are both measured in basic machine units. bindingindex
* must be less than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. offset and stride must be greater than or equal to zero.
* If buffer is zero, then any buffer currently bound to the specified binding point is unbound.<br>
* 	If buffer is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized
* memory buffer and comprising all the state and with the same initial values as in case of glBindBuffer. buffer is
* then attached to the specified bindingindex of the vertex array object.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffer if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffer if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_VALUE is generated if offset or stride is less than zero, or if stride is greater than the value of GL_MAX_VERTEX_ATTRIB_STRIDE.
* @errors GL_INVALID_VALUE is generated if buffer is not zero or the name of an existing buffer object (as returned by glGenBuffers
*         or glCreateBuffers).
*
*/
#define glVertexArrayVertexBuffer glad_glVertexArrayVertexBuffer
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;
/**
* @name glBindVertexBuffers, glVertexArrayVertexBuffers - attach multiple buffer objects to a vertex array object
* @usage
* @code void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @code void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayVertexBuffers</b>.
* @param first Specifies the first vertex buffer binding point to which a buffer object is to be bound.
* @param count Specifies the number of buffers to bind.
* @param buffers Specifies the address of an array of names of existing buffer objects.
* @param offsets Specifies the address of an array of offsets to associate with the binding points.
* @param strides Specifies the address of an array of strides to associate with the binding points.
* @description
* 	glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer objects to a specified
* number of consecutive vertex buffer binding points units in a vertex array object. For glBindVertexBuffers, the vertex
* array object is the currently bound vertex array object. For glVertexArrayVertexBuffers, vaobj is the name of the vertex
* array object.<br>
* 	count existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If
* buffers is not NULL, it specifies an array of count values, each of which must be zero or the name of an existing buffer
* object. offsets and strides specify arrays of count values indicating the offset of the first element and stride between
* elements in each buffer, respectively. If buffers is NULL, each affected vertex buffer binding point from $first$ through
* $first + count - 1$ will be reset to have no bound buffer object. In this case, the offsets and strides associated
* with the binding points are set to default values, ignoring offsets and strides.<br>
* 	glBindVertexBuffers is equivalent (assuming no errors are generated) to:<br>
* 	except that buffers will not be created if they do not exist.<br>
* 	glVertexArrayVertexBuffers is equivalent to the pseudocode above, but replacing glBindVertexBuffers(args) with glVertexArrayVertexBuffers(vaobj,
* args).<br>
* 	The values specified in buffers, offsets, and strides will be checked separately for each vertex buffer binding point.
* When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and
* an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding
* values are valid.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffers if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffers if vaobj is not the name of the vertex array object.
* @errors GL_INVALID_OPERATION is generated if $first + count$ is greater than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if any value in offsets or strides is negative, or if a value is stride is greater than the
*         value of GL_MAX_VERTEX_ATTRIB_STRIDE.
*
*/
#define glVertexArrayVertexBuffers glad_glVertexArrayVertexBuffers
GLAD_API_CALL PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1d glad_glVertexAttrib1d
GLAD_API_CALL PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1dv glad_glVertexAttrib1dv
GLAD_API_CALL PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1f glad_glVertexAttrib1f
GLAD_API_CALL PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1fv glad_glVertexAttrib1fv
GLAD_API_CALL PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1s glad_glVertexAttrib1s
GLAD_API_CALL PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1sv glad_glVertexAttrib1sv
GLAD_API_CALL PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2d glad_glVertexAttrib2d
GLAD_API_CALL PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2dv glad_glVertexAttrib2dv
GLAD_API_CALL PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2f glad_glVertexAttrib2f
GLAD_API_CALL PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2fv glad_glVertexAttrib2fv
GLAD_API_CALL PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2s glad_glVertexAttrib2s
GLAD_API_CALL PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2sv glad_glVertexAttrib2sv
GLAD_API_CALL PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3d glad_glVertexAttrib3d
GLAD_API_CALL PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3dv glad_glVertexAttrib3dv
GLAD_API_CALL PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3f glad_glVertexAttrib3f
GLAD_API_CALL PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3fv glad_glVertexAttrib3fv
GLAD_API_CALL PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3s glad_glVertexAttrib3s
GLAD_API_CALL PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3sv glad_glVertexAttrib3sv
GLAD_API_CALL PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nbv glad_glVertexAttrib4Nbv
GLAD_API_CALL PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Niv glad_glVertexAttrib4Niv
GLAD_API_CALL PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nsv glad_glVertexAttrib4Nsv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nub glad_glVertexAttrib4Nub
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nubv glad_glVertexAttrib4Nubv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nuiv glad_glVertexAttrib4Nuiv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nusv glad_glVertexAttrib4Nusv
GLAD_API_CALL PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4bv glad_glVertexAttrib4bv
GLAD_API_CALL PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4d glad_glVertexAttrib4d
GLAD_API_CALL PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4dv glad_glVertexAttrib4dv
GLAD_API_CALL PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4f glad_glVertexAttrib4f
GLAD_API_CALL PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4fv glad_glVertexAttrib4fv
GLAD_API_CALL PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4iv glad_glVertexAttrib4iv
GLAD_API_CALL PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4s glad_glVertexAttrib4s
GLAD_API_CALL PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4sv glad_glVertexAttrib4sv
GLAD_API_CALL PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4ubv glad_glVertexAttrib4ubv
GLAD_API_CALL PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4uiv glad_glVertexAttrib4uiv
GLAD_API_CALL PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4usv glad_glVertexAttrib4usv
GLAD_API_CALL PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;
/**
* @name glVertexAttribBinding - associate a vertex attribute and a vertex buffer binding for a vertex array object
* @usage
* @code void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex); @endcode
* @code void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttribBinding</b>.
* @param attribindex The index of the attribute to associate with a vertex buffer binding.
* @param bindingindex The index of the vertex buffer binding with which to associate the generic vertex attribute.
* @description
* 	glVertexAttribBinding and glVertexArrayAttribBinding establishes an association between the generic vertex attribute of
* a vertex array object whose index is given by attribindex, and a vertex buffer binding whose index is given by bindingindex.
* For glVertexAttribBinding, the vertex array object affected is that currently bound. For glVertexArrayAttribBinding,
* vaobj is the name of the vertex array object.<br>
* 	attribindex must be less than the value of GL_MAX_VERTEX_ATTRIBS and bindingindex must be less than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.<br>
*
*
* @errors GL_INVALID_OPERATION is generated by glVertexAttribBinding if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribBinding if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
*
*/
#define glVertexAttribBinding glad_glVertexAttribBinding
GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
/**
* @name glVertexAttribDivisor - modify the rate at which generic vertex attributes advance during instanced rendering
* @usage
* @code void glVertexAttribDivisor(GLuint index, GLuint divisor); @endcode
* @param index Specify the index of the generic vertex attribute.
* @param divisor Specify the number of instances that will pass between updates of the generic attribute at slot <em class="parameter"><b>index</b></em>.
* @description
* 	glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering multiple instances of
* primitives in a single draw call. If divisor is zero, the attribute at slot index advances once per vertex. If divisor
* is non-zero, the attribute advances once per divisor instances of the set(s) of vertices being rendered.  An attribute is
* referred to as instanced if its GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero.<br>
* 	index must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
*
* @note glVertexAttribDivisor is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glVertexAttribDivisor glad_glVertexAttribDivisor
GLAD_API_CALL PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @description
* 	glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat, as well as glVertexArrayAttribFormat, glVertexArrayAttribIFormat
* and glVertexArrayAttribLFormat specify the organization of data in vertex arrays. The first three calls
* operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID
* vaobj. attribindex specifies the index of the generic vertex attribute array whose data layout is being described, and
* must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
* 	size determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or
* GL_BGRA. type indicates the type of the data. If type is one of GL_BYTE, GL_SHORT, GL_INT, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT,
* and GL_DOUBLE indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values
* GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, and GL_UNSIGNED_INT indicate types GLubyte, GLushort, and GLuint, respectively;
* the values GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed or unsigned elements
* packed into a single GLuint; and the value GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values
* packed into a single GLuint.<br>
* 	glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for data associated with a generic attribute
* variable declared as 64-bit double precision components. For glVertexAttribLFormat and glVertexArrayAttribLFormat,
* type must be GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat, which will cause data declared
* as GL_DOUBLE to be converted to 32-bit representation, glVertexAttribLFormat and glVertexArrayAttribLFormat cause such
* data to be left in its natural, 64-bit representation.<br>
* 	For glVertexAttribFormat and glVertexArrayAttribFormat, if normalized is GL_TRUE, then integer data is normalized to the
* range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
* converted to floating point.<br>
* 	relativeoffset is the offset, measured in basic machine units of the first element relative to the start of the vertex
* buffer binding this attribute fetches from.<br>
* 	glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe vertex attribute layout for floating-point
* vertex attributes, glVertexAttribIFormat and glVertexArrayAttribIFormat should be used to describe vertex attribute layout
* for integer vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to describe the
* layout for 64-bit vertex attributes. Data for an array specified by glVertexAttribIFormat and glVertexArrayAttribIFormat
* will always be left as integer values; such data are referred to as pure integers.<br>
*
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexAttribFormat glad_glVertexAttribFormat
GLAD_API_CALL PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1i glad_glVertexAttribI1i
GLAD_API_CALL PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1iv glad_glVertexAttribI1iv
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1ui glad_glVertexAttribI1ui
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1uiv glad_glVertexAttribI1uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2i glad_glVertexAttribI2i
GLAD_API_CALL PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2iv glad_glVertexAttribI2iv
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2ui glad_glVertexAttribI2ui
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2uiv glad_glVertexAttribI2uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3i glad_glVertexAttribI3i
GLAD_API_CALL PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3iv glad_glVertexAttribI3iv
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3ui glad_glVertexAttribI3ui
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3uiv glad_glVertexAttribI3uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4bv glad_glVertexAttribI4bv
GLAD_API_CALL PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4i glad_glVertexAttribI4i
GLAD_API_CALL PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4iv glad_glVertexAttribI4iv
GLAD_API_CALL PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4sv glad_glVertexAttribI4sv
GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4ubv glad_glVertexAttribI4ubv
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4ui glad_glVertexAttribI4ui
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4uiv glad_glVertexAttribI4uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4usv glad_glVertexAttribI4usv
GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @description
* 	glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat, as well as glVertexArrayAttribFormat, glVertexArrayAttribIFormat
* and glVertexArrayAttribLFormat specify the organization of data in vertex arrays. The first three calls
* operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID
* vaobj. attribindex specifies the index of the generic vertex attribute array whose data layout is being described, and
* must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
* 	size determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or
* GL_BGRA. type indicates the type of the data. If type is one of GL_BYTE, GL_SHORT, GL_INT, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT,
* and GL_DOUBLE indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values
* GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, and GL_UNSIGNED_INT indicate types GLubyte, GLushort, and GLuint, respectively;
* the values GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed or unsigned elements
* packed into a single GLuint; and the value GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values
* packed into a single GLuint.<br>
* 	glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for data associated with a generic attribute
* variable declared as 64-bit double precision components. For glVertexAttribLFormat and glVertexArrayAttribLFormat,
* type must be GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat, which will cause data declared
* as GL_DOUBLE to be converted to 32-bit representation, glVertexAttribLFormat and glVertexArrayAttribLFormat cause such
* data to be left in its natural, 64-bit representation.<br>
* 	For glVertexAttribFormat and glVertexArrayAttribFormat, if normalized is GL_TRUE, then integer data is normalized to the
* range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
* converted to floating point.<br>
* 	relativeoffset is the offset, measured in basic machine units of the first element relative to the start of the vertex
* buffer binding this attribute fetches from.<br>
* 	glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe vertex attribute layout for floating-point
* vertex attributes, glVertexAttribIFormat and glVertexArrayAttribIFormat should be used to describe vertex attribute layout
* for integer vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to describe the
* layout for 64-bit vertex attributes. Data for an array specified by glVertexAttribIFormat and glVertexArrayAttribIFormat
* will always be left as integer values; such data are referred to as pure integers.<br>
*
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexAttribIFormat glad_glVertexAttribIFormat
GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
/**
* @name glVertexAttribPointer - define an array of generic vertex attribute data
* @usage
* @code void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant
*             <b>GL_BGRA</b> is accepted by <b>glVertexAttribPointer</b>. The initial value is 4.
* @param type Specifies the data type of each component in the array. The symbolic constants <b>GL_BYTE</b>, <b>GL_UNSIGNED_BYTE</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_INT</b>, and <b>GL_UNSIGNED_INT</b> are accepted by <b>glVertexAttribPointer</b>
*             and <b>glVertexAttribIPointer</b>. Additionally <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_DOUBLE</b>, <b>GL_FIXED</b>,
*             <b>GL_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>
*             are accepted by <b>glVertexAttribPointer</b>. <b>GL_DOUBLE</b> is also accepted by <b>glVertexAttribLPointer</b> and
*             is the only token accepted by the <em class="parameter"><b>type</b></em> parameter for that function. The initial value
*             is <b>GL_FLOAT</b>.
* @param normalized For <b>glVertexAttribPointer</b>, specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted
*                   directly as fixed-point values (<b>GL_FALSE</b>) when they are accessed.
* @param stride Specifies the byte offset between consecutive generic vertex attributes. If <em class="parameter"><b>stride</b></em> is
*               0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
* @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer
*                currently bound to the <b>GL_ARRAY_BUFFER</b> target. The initial value is 0.
* @description
* 	glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer specify the location and data format of the array
* of generic vertex attributes at index index to use when rendering. size specifies the number of components per attribute
* and must be 1, 2, 3, 4, or GL_BGRA. type specifies the data type of each component, and stride specifies the byte stride
* from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate
* arrays.<br>
* 	For glVertexAttribPointer, if normalized is set to GL_TRUE, it indicates that values stored in an integer format are to
* be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to
* floating point. Otherwise, values will be converted to floats directly without normalization.<br>
* 	For glVertexAttribIPointer, only the integer types GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT
* are accepted. Values are always left as integer values.<br>
* 	glVertexAttribLPointer specifies state for a generic vertex attribute array associated with a shader attribute variable
* declared with 64-bit double precision components. type must be GL_DOUBLE. index, size, and stride behave as described for
* glVertexAttribPointer and glVertexAttribIPointer.<br>
* 	If pointer is not NULL, a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target (see glBindBuffer),
* otherwise an error is generated. pointer is treated as a byte offset into the buffer object's data store. The buffer object
* binding (GL_ARRAY_BUFFER_BINDING) is saved as generic vertex attribute array state (GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING)
* for index index.<br>
* 	When a generic vertex attribute array is specified, size, type, normalized, stride, and pointer are saved as vertex array
* state, in addition to the current vertex array buffer object binding.<br>
* 	To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray with
* index. If enabled, the generic vertex attribute array is used when glDrawArrays, glMultiDrawArrays, glDrawElements,
* glMultiDrawElements, or  glDrawRangeElements is called.<br>
*
* @note Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements, glDrawRangeElements, glDrawArrays,
*       glMultiDrawArrays, or glMultiDrawElements is called.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
* @errors GL_INVALID_ENUM is generated if type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is negative.
* @errors GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or
*         GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument
*         is not NULL.
*
*/
#define glVertexAttribIPointer glad_glVertexAttribIPointer
GLAD_API_CALL PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL1d glad_glVertexAttribL1d
GLAD_API_CALL PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL1dv glad_glVertexAttribL1dv
GLAD_API_CALL PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL2d glad_glVertexAttribL2d
GLAD_API_CALL PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL2dv glad_glVertexAttribL2dv
GLAD_API_CALL PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL3d glad_glVertexAttribL3d
GLAD_API_CALL PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL3dv glad_glVertexAttribL3dv
GLAD_API_CALL PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL4d glad_glVertexAttribL4d
GLAD_API_CALL PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL4dv glad_glVertexAttribL4dv
GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @description
* 	glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat, as well as glVertexArrayAttribFormat, glVertexArrayAttribIFormat
* and glVertexArrayAttribLFormat specify the organization of data in vertex arrays. The first three calls
* operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID
* vaobj. attribindex specifies the index of the generic vertex attribute array whose data layout is being described, and
* must be less than the value of GL_MAX_VERTEX_ATTRIBS.<br>
* 	size determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or
* GL_BGRA. type indicates the type of the data. If type is one of GL_BYTE, GL_SHORT, GL_INT, GL_FIXED, GL_FLOAT, GL_HALF_FLOAT,
* and GL_DOUBLE indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and GLdouble, respectively; the values
* GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, and GL_UNSIGNED_INT indicate types GLubyte, GLushort, and GLuint, respectively;
* the values GL_INT_2_10_10_10_REV and GL_UNSIGNED_INT_2_10_10_10_REV indicating respectively four signed or unsigned elements
* packed into a single GLuint; and the value GL_UNSIGNED_INT_10F_11F_11F_REV indicating three floating point values
* packed into a single GLuint.<br>
* 	glVertexAttribLFormat and glVertexArrayAttribLFormat is used to specify layout for data associated with a generic attribute
* variable declared as 64-bit double precision components. For glVertexAttribLFormat and glVertexArrayAttribLFormat,
* type must be GL_DOUBLE. In contrast to glVertexAttribFormat or glVertexArrayAttribFormat, which will cause data declared
* as GL_DOUBLE to be converted to 32-bit representation, glVertexAttribLFormat and glVertexArrayAttribLFormat cause such
* data to be left in its natural, 64-bit representation.<br>
* 	For glVertexAttribFormat and glVertexArrayAttribFormat, if normalized is GL_TRUE, then integer data is normalized to the
* range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If normalized is GL_FALSE then integer data is directly
* converted to floating point.<br>
* 	relativeoffset is the offset, measured in basic machine units of the first element relative to the start of the vertex
* buffer binding this attribute fetches from.<br>
* 	glVertexAttribFormat and glVertexArrayAttribFormat should be used to describe vertex attribute layout for floating-point
* vertex attributes, glVertexAttribIFormat and glVertexArrayAttribIFormat should be used to describe vertex attribute layout
* for integer vertex attribute, and glVertexAttribLFormat and glVertexArrayAttribLFormat should be used to describe the
* layout for 64-bit vertex attributes. Data for an array specified by glVertexAttribIFormat and glVertexArrayAttribIFormat
* will always be left as integer values; such data are referred to as pure integers.<br>
*
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexAttribLFormat glad_glVertexAttribLFormat
GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;
/**
* @name glVertexAttribPointer - define an array of generic vertex attribute data
* @usage
* @code void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant
*             <b>GL_BGRA</b> is accepted by <b>glVertexAttribPointer</b>. The initial value is 4.
* @param type Specifies the data type of each component in the array. The symbolic constants <b>GL_BYTE</b>, <b>GL_UNSIGNED_BYTE</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_INT</b>, and <b>GL_UNSIGNED_INT</b> are accepted by <b>glVertexAttribPointer</b>
*             and <b>glVertexAttribIPointer</b>. Additionally <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_DOUBLE</b>, <b>GL_FIXED</b>,
*             <b>GL_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>
*             are accepted by <b>glVertexAttribPointer</b>. <b>GL_DOUBLE</b> is also accepted by <b>glVertexAttribLPointer</b> and
*             is the only token accepted by the <em class="parameter"><b>type</b></em> parameter for that function. The initial value
*             is <b>GL_FLOAT</b>.
* @param normalized For <b>glVertexAttribPointer</b>, specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted
*                   directly as fixed-point values (<b>GL_FALSE</b>) when they are accessed.
* @param stride Specifies the byte offset between consecutive generic vertex attributes. If <em class="parameter"><b>stride</b></em> is
*               0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
* @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer
*                currently bound to the <b>GL_ARRAY_BUFFER</b> target. The initial value is 0.
* @description
* 	glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer specify the location and data format of the array
* of generic vertex attributes at index index to use when rendering. size specifies the number of components per attribute
* and must be 1, 2, 3, 4, or GL_BGRA. type specifies the data type of each component, and stride specifies the byte stride
* from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate
* arrays.<br>
* 	For glVertexAttribPointer, if normalized is set to GL_TRUE, it indicates that values stored in an integer format are to
* be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to
* floating point. Otherwise, values will be converted to floats directly without normalization.<br>
* 	For glVertexAttribIPointer, only the integer types GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT
* are accepted. Values are always left as integer values.<br>
* 	glVertexAttribLPointer specifies state for a generic vertex attribute array associated with a shader attribute variable
* declared with 64-bit double precision components. type must be GL_DOUBLE. index, size, and stride behave as described for
* glVertexAttribPointer and glVertexAttribIPointer.<br>
* 	If pointer is not NULL, a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target (see glBindBuffer),
* otherwise an error is generated. pointer is treated as a byte offset into the buffer object's data store. The buffer object
* binding (GL_ARRAY_BUFFER_BINDING) is saved as generic vertex attribute array state (GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING)
* for index index.<br>
* 	When a generic vertex attribute array is specified, size, type, normalized, stride, and pointer are saved as vertex array
* state, in addition to the current vertex array buffer object binding.<br>
* 	To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray with
* index. If enabled, the generic vertex attribute array is used when glDrawArrays, glMultiDrawArrays, glDrawElements,
* glMultiDrawElements, or  glDrawRangeElements is called.<br>
*
* @note Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements, glDrawRangeElements, glDrawArrays,
*       glMultiDrawArrays, or glMultiDrawElements is called.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
* @errors GL_INVALID_ENUM is generated if type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is negative.
* @errors GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or
*         GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument
*         is not NULL.
*
*/
#define glVertexAttribLPointer glad_glVertexAttribLPointer
GLAD_API_CALL PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP1ui glad_glVertexAttribP1ui
GLAD_API_CALL PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
// Unable to find the docs for this function!
#define glVertexAttribP1uiv glad_glVertexAttribP1uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP2ui glad_glVertexAttribP2ui
GLAD_API_CALL PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
// Unable to find the docs for this function!
#define glVertexAttribP2uiv glad_glVertexAttribP2uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP3ui glad_glVertexAttribP3ui
GLAD_API_CALL PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
// Unable to find the docs for this function!
#define glVertexAttribP3uiv glad_glVertexAttribP3uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @description
* 	The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in numbered locations.<br>
* 	Generic attributes are defined as four-component values that are organized into an array. The first entry of this array
* is numbered 0, and the size of the array is specified by the implementation-dependent constant GL_MAX_VERTEX_ATTRIBS. Individual
* elements of this array can be modified with a glVertexAttrib call that specifies the index of the element to be
* modified and a value for that element.<br>
* 	These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified
* by index. A 1 in the name of the command indicates that only one value is passed, and it will be used to modify the first
* component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component
* will be set to 1. Similarly, a 2 in the name of the command indicates that values are provided for the first two components,
* the third component will be set to 0, and the fourth component will be set to 1. A 3 in the name of the command indicates
* that values are provided for the first three components and the fourth component will be set to 1, whereas a 4 in
* the name indicates that values are provided for all four components.<br>
* 	The letters s, f, i, d, ub, us, and ui indicate whether the arguments are of type short, float, int, double, unsigned byte,
* unsigned short, or unsigned int. When v is appended to the name, the commands can take a pointer to an array of such
* values.<br>
* 	Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:<br>
* 	The commands containing N indicate that the arguments will be passed as fixed-point values that are scaled to a normalized
* range according to the component conversion rules defined by the OpenGL specification. Signed values are understood
* to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values
* in the range [0,1].<br>
* 	The commands containing I indicate that the arguments are extended to full signed or unsigned integers.<br>
* 	The commands containing P indicate that the arguments are stored as packed components within a larger natural type.<br>
* 	The commands containing L indicate that the arguments are full 64-bit quantities and should be passed directly to shader
* inputs declared as 64-bit double precision types.<br>
* 	OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may
* be loaded using the glVertexAttrib entry points. Matrices must be loaded into successive generic attribute slots in column
* major order, with one column of the matrix in each generic attribute slot.<br>
* 	A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling glBindAttribLocation.
* This allows an application to use more descriptive variable names in a vertex shader. A subsequent change
* to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable
* in the vertex shader.<br>
* 	The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of
* the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic
* vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different
* program object is used.<br>
* 	An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable.
* These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic
* vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing,
* the vertex shader will repeatedly use the current value for the generic vertex attribute.<br>
*
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP4ui glad_glVertexAttribP4ui
GLAD_API_CALL PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
// Unable to find the docs for this function!
#define glVertexAttribP4uiv glad_glVertexAttribP4uiv
GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
/**
* @name glVertexAttribPointer - define an array of generic vertex attribute data
* @usage
* @code void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant
*             <b>GL_BGRA</b> is accepted by <b>glVertexAttribPointer</b>. The initial value is 4.
* @param type Specifies the data type of each component in the array. The symbolic constants <b>GL_BYTE</b>, <b>GL_UNSIGNED_BYTE</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_INT</b>, and <b>GL_UNSIGNED_INT</b> are accepted by <b>glVertexAttribPointer</b>
*             and <b>glVertexAttribIPointer</b>. Additionally <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_DOUBLE</b>, <b>GL_FIXED</b>,
*             <b>GL_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>
*             are accepted by <b>glVertexAttribPointer</b>. <b>GL_DOUBLE</b> is also accepted by <b>glVertexAttribLPointer</b> and
*             is the only token accepted by the <em class="parameter"><b>type</b></em> parameter for that function. The initial value
*             is <b>GL_FLOAT</b>.
* @param normalized For <b>glVertexAttribPointer</b>, specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted
*                   directly as fixed-point values (<b>GL_FALSE</b>) when they are accessed.
* @param stride Specifies the byte offset between consecutive generic vertex attributes. If <em class="parameter"><b>stride</b></em> is
*               0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
* @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer
*                currently bound to the <b>GL_ARRAY_BUFFER</b> target. The initial value is 0.
* @description
* 	glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer specify the location and data format of the array
* of generic vertex attributes at index index to use when rendering. size specifies the number of components per attribute
* and must be 1, 2, 3, 4, or GL_BGRA. type specifies the data type of each component, and stride specifies the byte stride
* from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate
* arrays.<br>
* 	For glVertexAttribPointer, if normalized is set to GL_TRUE, it indicates that values stored in an integer format are to
* be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to
* floating point. Otherwise, values will be converted to floats directly without normalization.<br>
* 	For glVertexAttribIPointer, only the integer types GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT
* are accepted. Values are always left as integer values.<br>
* 	glVertexAttribLPointer specifies state for a generic vertex attribute array associated with a shader attribute variable
* declared with 64-bit double precision components. type must be GL_DOUBLE. index, size, and stride behave as described for
* glVertexAttribPointer and glVertexAttribIPointer.<br>
* 	If pointer is not NULL, a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target (see glBindBuffer),
* otherwise an error is generated. pointer is treated as a byte offset into the buffer object's data store. The buffer object
* binding (GL_ARRAY_BUFFER_BINDING) is saved as generic vertex attribute array state (GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING)
* for index index.<br>
* 	When a generic vertex attribute array is specified, size, type, normalized, stride, and pointer are saved as vertex array
* state, in addition to the current vertex array buffer object binding.<br>
* 	To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray with
* index. If enabled, the generic vertex attribute array is used when glDrawArrays, glMultiDrawArrays, glDrawElements,
* glMultiDrawElements, or  glDrawRangeElements is called.<br>
*
* @note Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements, glDrawRangeElements, glDrawArrays,
*       glMultiDrawArrays, or glMultiDrawElements is called.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
* @errors GL_INVALID_ENUM is generated if type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is negative.
* @errors GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or
*         GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument
*         is not NULL.
*
*/
#define glVertexAttribPointer glad_glVertexAttribPointer
GLAD_API_CALL PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;
/**
* @name glVertexBindingDivisor, glVertexArrayBindingDivisor - modify the rate at which generic vertex attributes
advance
* @usage
* @code void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor); @endcode
* @code void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayBindingDivisor</b> function.
* @param bindingindex The index of the binding whose divisor to modify.
* @param divisor The new value for the instance step rate to apply.
* @description
* 	glVertexBindingDivisor and glVertexArrayBindingDivisor modify the rate at which generic vertex attributes advance when
* rendering multiple instances of primitives in a single draw command. If divisor is zero, the attributes using the buffer
* bound to bindingindex advance once per vertex. If divisor is non-zero, the attributes advance once per divisor instances
* of the set(s) of vertices being rendered. An attribute is referred to as instanced if the corresponding divisor value
* is non-zero.<br>
* 	glVertexBindingDivisor uses currently bound vertex array object , whereas glVertexArrayBindingDivisor updates state of
* the vertex array object with ID vaobj.<br>
*
*
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION by glVertexBindingDivisor is generated if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayBindingDivisor if vaobj is not the name of an existing vertex array object.
*
*/
#define glVertexBindingDivisor glad_glVertexBindingDivisor
GLAD_API_CALL PFNGLVIEWPORTPROC glad_glViewport;
/**
* @name glViewport - set the viewport
* @usage
* @code void glViewport(GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param x, y Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0, 0).
* @param width, height Specify the width and height of the viewport. When a GL context is first attached to a window, <em class="parameter"><b>width</b></em>
*                      and <em class="parameter"><b>height</b></em> are set to the dimensions of that window.
* @description
* 	glViewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let
* xnd ynd be normalized device coordinates. Then the window coordinates xw yw are computed as follows:<br>
* 	Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call
* glGet with argument GL_MAX_VIEWPORT_DIMS.<br>
*
*
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
*
*/
#define glViewport glad_glViewport
GLAD_API_CALL PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;
// Unable to find the docs for this function!
#define glViewportArrayv glad_glViewportArrayv
GLAD_API_CALL PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;
// Unable to find the docs for this function!
#define glViewportIndexedf glad_glViewportIndexedf
GLAD_API_CALL PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;
// Unable to find the docs for this function!
#define glViewportIndexedfv glad_glViewportIndexedfv
GLAD_API_CALL PFNGLWAITSYNCPROC glad_glWaitSync;
/**
* @name glWaitSync - instruct the GL server to block until the specified sync object becomes signaled
* @usage
* @code void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout); @endcode
* @param sync Specifies the sync object whose status to wait on.
* @param flags A bitfield controlling the command flushing behavior. <em class="parameter"><b>flags</b></em> may be zero.
* @param timeout Specifies the timeout that the server should wait before continuing. <em class="parameter"><b>timeout</b></em> must be <b>GL_TIMEOUT_IGNORED</b>.
* @description
* 	glWaitSync causes the GL server to block and wait until sync becomes signaled. sync is the name of an existing sync object
* upon which to wait. flags and timeout are currently not used and must be set to zero and the special value GL_TIMEOUT_IGNORED,
* respectively[1]. glWaitSync will always wait no longer than an implementation-dependent timeout. The duration
* of this timeout in nanoseconds may be queried by calling glGet with the parameter GL_MAX_SERVER_WAIT_TIMEOUT. There is
* currently no way to determine whether glWaitSync unblocked because the timeout expired or because the sync object being
* waited on was signaled.<br>
* 	If an error occurs, glWaitSync does not cause the GL server to block.<br>
*
* @note glWaitSync is available only if the GL version is 3.2 or higher.
*
* @errors GL_INVALID_VALUE is generated if sync is not the name of a sync object.
* @errors GL_INVALID_VALUE is generated if flags is not zero.
* @errors GL_INVALID_VALUE is generated if timeout is not GL_TIMEOUT_IGNORED.
*
*/
#define glWaitSync glad_glWaitSync





GLAD_API_CALL int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr);
// Unable to find the docs for this function!
GLAD_API_CALL int gladLoadGL( GLADloadfunc load);


#ifdef GLAD_GL

// Unable to find the docs for this function!
GLAD_API_CALL int gladLoaderLoadGL(void);
// Unable to find the docs for this function!
GLAD_API_CALL void gladLoaderUnloadGL(void);

#endif

#ifdef __cplusplus
}
#endif
#endif

/* Source */
#ifdef GLAD_GL_IMPLEMENTATION
/**
 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef GLAD_IMPL_UTIL_C_
#define GLAD_IMPL_UTIL_C_

#ifdef _MSC_VER
#define GLAD_IMPL_UTIL_SSCANF sscanf_s
#else
#define GLAD_IMPL_UTIL_SSCANF sscanf
#endif

#endif /* GLAD_IMPL_UTIL_C_ */

#ifdef __cplusplus
extern "C" {
#endif



int GLAD_GL_VERSION_1_0 = 0;
int GLAD_GL_VERSION_1_1 = 0;
int GLAD_GL_VERSION_1_2 = 0;
int GLAD_GL_VERSION_1_3 = 0;
int GLAD_GL_VERSION_1_4 = 0;
int GLAD_GL_VERSION_1_5 = 0;
int GLAD_GL_VERSION_2_0 = 0;
int GLAD_GL_VERSION_2_1 = 0;
int GLAD_GL_VERSION_3_0 = 0;
int GLAD_GL_VERSION_3_1 = 0;
int GLAD_GL_VERSION_3_2 = 0;
int GLAD_GL_VERSION_3_3 = 0;
int GLAD_GL_VERSION_4_0 = 0;
int GLAD_GL_VERSION_4_1 = 0;
int GLAD_GL_VERSION_4_2 = 0;
int GLAD_GL_VERSION_4_3 = 0;
int GLAD_GL_VERSION_4_4 = 0;
int GLAD_GL_VERSION_4_5 = 0;
int GLAD_GL_VERSION_4_6 = 0;
int GLAD_GL_EXT_texture_lod_bias = 0;



PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram = NULL;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture = NULL;
PFNGLATTACHSHADERPROC glad_glAttachShader = NULL;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = NULL;
PFNGLBEGINQUERYPROC glad_glBeginQuery = NULL;
PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = NULL;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = NULL;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = NULL;
PFNGLBINDBUFFERPROC glad_glBindBuffer = NULL;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = NULL;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = NULL;
PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase = NULL;
PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange = NULL;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = NULL;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = NULL;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = NULL;
PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture = NULL;
PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures = NULL;
PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline = NULL;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = NULL;
PFNGLBINDSAMPLERPROC glad_glBindSampler = NULL;
PFNGLBINDSAMPLERSPROC glad_glBindSamplers = NULL;
PFNGLBINDTEXTUREPROC glad_glBindTexture = NULL;
PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit = NULL;
PFNGLBINDTEXTURESPROC glad_glBindTextures = NULL;
PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = NULL;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = NULL;
PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer = NULL;
PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers = NULL;
PFNGLBLENDCOLORPROC glad_glBlendColor = NULL;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation = NULL;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = NULL;
PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = NULL;
PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = NULL;
PFNGLBLENDFUNCPROC glad_glBlendFunc = NULL;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = NULL;
PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = NULL;
PFNGLBLENDFUNCIPROC glad_glBlendFunci = NULL;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = NULL;
PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer = NULL;
PFNGLBUFFERDATAPROC glad_glBufferData = NULL;
PFNGLBUFFERSTORAGEPROC glad_glBufferStorage = NULL;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = NULL;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus = NULL;
PFNGLCLAMPCOLORPROC glad_glClampColor = NULL;
PFNGLCLEARPROC glad_glClear = NULL;
PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData = NULL;
PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData = NULL;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = NULL;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = NULL;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = NULL;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = NULL;
PFNGLCLEARCOLORPROC glad_glClearColor = NULL;
PFNGLCLEARDEPTHPROC glad_glClearDepth = NULL;
PFNGLCLEARDEPTHFPROC glad_glClearDepthf = NULL;
PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData = NULL;
PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv = NULL;
PFNGLCLEARSTENCILPROC glad_glClearStencil = NULL;
PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage = NULL;
PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage = NULL;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = NULL;
PFNGLCLIPCONTROLPROC glad_glClipControl = NULL;
PFNGLCOLORMASKPROC glad_glColorMask = NULL;
PFNGLCOLORMASKIPROC glad_glColorMaski = NULL;
PFNGLCOMPILESHADERPROC glad_glCompileShader = NULL;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = NULL;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = NULL;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D = NULL;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = NULL;
PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData = NULL;
PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData = NULL;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = NULL;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = NULL;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = NULL;
PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D = NULL;
PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D = NULL;
PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D = NULL;
PFNGLCREATEBUFFERSPROC glad_glCreateBuffers = NULL;
PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers = NULL;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram = NULL;
PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines = NULL;
PFNGLCREATEQUERIESPROC glad_glCreateQueries = NULL;
PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers = NULL;
PFNGLCREATESAMPLERSPROC glad_glCreateSamplers = NULL;
PFNGLCREATESHADERPROC glad_glCreateShader = NULL;
PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv = NULL;
PFNGLCREATETEXTURESPROC glad_glCreateTextures = NULL;
PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks = NULL;
PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays = NULL;
PFNGLCULLFACEPROC glad_glCullFace = NULL;
PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback = NULL;
PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl = NULL;
PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert = NULL;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = NULL;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = NULL;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = NULL;
PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines = NULL;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries = NULL;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = NULL;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = NULL;
PFNGLDELETESHADERPROC glad_glDeleteShader = NULL;
PFNGLDELETESYNCPROC glad_glDeleteSync = NULL;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures = NULL;
PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = NULL;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = NULL;
PFNGLDEPTHFUNCPROC glad_glDepthFunc = NULL;
PFNGLDEPTHMASKPROC glad_glDepthMask = NULL;
PFNGLDEPTHRANGEPROC glad_glDepthRange = NULL;
PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv = NULL;
PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed = NULL;
PFNGLDEPTHRANGEFPROC glad_glDepthRangef = NULL;
PFNGLDETACHSHADERPROC glad_glDetachShader = NULL;
PFNGLDISABLEPROC glad_glDisable = NULL;
PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib = NULL;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = NULL;
PFNGLDISABLEIPROC glad_glDisablei = NULL;
PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute = NULL;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect = NULL;
PFNGLDRAWARRAYSPROC glad_glDrawArrays = NULL;
PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = NULL;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = NULL;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance = NULL;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer = NULL;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = NULL;
PFNGLDRAWELEMENTSPROC glad_glDrawElements = NULL;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = NULL;
PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = NULL;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance = NULL;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = NULL;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = NULL;
PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = NULL;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced = NULL;
PFNGLENABLEPROC glad_glEnable = NULL;
PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib = NULL;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = NULL;
PFNGLENABLEIPROC glad_glEnablei = NULL;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = NULL;
PFNGLENDQUERYPROC glad_glEndQuery = NULL;
PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = NULL;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = NULL;
PFNGLFENCESYNCPROC glad_glFenceSync = NULL;
PFNGLFINISHPROC glad_glFinish = NULL;
PFNGLFLUSHPROC glad_glFlush = NULL;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = NULL;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange = NULL;
PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri = NULL;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = NULL;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = NULL;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = NULL;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = NULL;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = NULL;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = NULL;
PFNGLFRONTFACEPROC glad_glFrontFace = NULL;
PFNGLGENBUFFERSPROC glad_glGenBuffers = NULL;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = NULL;
PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines = NULL;
PFNGLGENQUERIESPROC glad_glGenQueries = NULL;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = NULL;
PFNGLGENSAMPLERSPROC glad_glGenSamplers = NULL;
PFNGLGENTEXTURESPROC glad_glGenTextures = NULL;
PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = NULL;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = NULL;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = NULL;
PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = NULL;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = NULL;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = NULL;
PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = NULL;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = NULL;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = NULL;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = NULL;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = NULL;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = NULL;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = NULL;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = NULL;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = NULL;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv = NULL;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = NULL;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = NULL;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = NULL;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = NULL;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = NULL;
PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage = NULL;
PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage = NULL;
PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog = NULL;
PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v = NULL;
PFNGLGETDOUBLEVPROC glad_glGetDoublev = NULL;
PFNGLGETERRORPROC glad_glGetError = NULL;
PFNGLGETFLOATI_VPROC glad_glGetFloati_v = NULL;
PFNGLGETFLOATVPROC glad_glGetFloatv = NULL;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = NULL;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = NULL;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = NULL;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv = NULL;
PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus = NULL;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = NULL;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v = NULL;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = NULL;
PFNGLGETINTEGERVPROC glad_glGetIntegerv = NULL;
PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v = NULL;
PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ = NULL;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = NULL;
PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v = NULL;
PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv = NULL;
PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv = NULL;
PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData = NULL;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv = NULL;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv = NULL;
PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel = NULL;
PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel = NULL;
PFNGLGETPOINTERVPROC glad_glGetPointerv = NULL;
PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary = NULL;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = NULL;
PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv = NULL;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog = NULL;
PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv = NULL;
PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex = NULL;
PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName = NULL;
PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv = NULL;
PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = NULL;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = NULL;
PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v = NULL;
PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv = NULL;
PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v = NULL;
PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv = NULL;
PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = NULL;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = NULL;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = NULL;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = NULL;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = NULL;
PFNGLGETQUERYIVPROC glad_glGetQueryiv = NULL;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = NULL;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = NULL;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = NULL;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = NULL;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = NULL;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = NULL;
PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat = NULL;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = NULL;
PFNGLGETSHADERIVPROC glad_glGetShaderiv = NULL;
PFNGLGETSTRINGPROC glad_glGetString = NULL;
PFNGLGETSTRINGIPROC glad_glGetStringi = NULL;
PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = NULL;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = NULL;
PFNGLGETSYNCIVPROC glad_glGetSynciv = NULL;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage = NULL;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = NULL;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = NULL;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = NULL;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = NULL;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = NULL;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = NULL;
PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage = NULL;
PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv = NULL;
PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv = NULL;
PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv = NULL;
PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv = NULL;
PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv = NULL;
PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv = NULL;
PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = NULL;
PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v = NULL;
PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v = NULL;
PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv = NULL;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = NULL;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = NULL;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = NULL;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = NULL;
PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = NULL;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = NULL;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = NULL;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = NULL;
PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv = NULL;
PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv = NULL;
PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv = NULL;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = NULL;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = NULL;
PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv = NULL;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = NULL;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = NULL;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = NULL;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = NULL;
PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage = NULL;
PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage = NULL;
PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv = NULL;
PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv = NULL;
PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv = NULL;
PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv = NULL;
PFNGLHINTPROC glad_glHint = NULL;
PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData = NULL;
PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData = NULL;
PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData = NULL;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer = NULL;
PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage = NULL;
PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage = NULL;
PFNGLISBUFFERPROC glad_glIsBuffer = NULL;
PFNGLISENABLEDPROC glad_glIsEnabled = NULL;
PFNGLISENABLEDIPROC glad_glIsEnabledi = NULL;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = NULL;
PFNGLISPROGRAMPROC glad_glIsProgram = NULL;
PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline = NULL;
PFNGLISQUERYPROC glad_glIsQuery = NULL;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = NULL;
PFNGLISSAMPLERPROC glad_glIsSampler = NULL;
PFNGLISSHADERPROC glad_glIsShader = NULL;
PFNGLISSYNCPROC glad_glIsSync = NULL;
PFNGLISTEXTUREPROC glad_glIsTexture = NULL;
PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = NULL;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = NULL;
PFNGLLINEWIDTHPROC glad_glLineWidth = NULL;
PFNGLLINKPROGRAMPROC glad_glLinkProgram = NULL;
PFNGLLOGICOPPROC glad_glLogicOp = NULL;
PFNGLMAPBUFFERPROC glad_glMapBuffer = NULL;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = NULL;
PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer = NULL;
PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange = NULL;
PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier = NULL;
PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion = NULL;
PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = NULL;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount = NULL;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = NULL;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount = NULL;
PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData = NULL;
PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage = NULL;
PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers = NULL;
PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri = NULL;
PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample = NULL;
PFNGLOBJECTLABELPROC glad_glObjectLabel = NULL;
PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel = NULL;
PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = NULL;
PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = NULL;
PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = NULL;
PFNGLPIXELSTOREFPROC glad_glPixelStoref = NULL;
PFNGLPIXELSTOREIPROC glad_glPixelStorei = NULL;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = NULL;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = NULL;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = NULL;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = NULL;
PFNGLPOINTSIZEPROC glad_glPointSize = NULL;
PFNGLPOLYGONMODEPROC glad_glPolygonMode = NULL;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = NULL;
PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp = NULL;
PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup = NULL;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = NULL;
PFNGLPROGRAMBINARYPROC glad_glProgramBinary = NULL;
PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri = NULL;
PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d = NULL;
PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv = NULL;
PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f = NULL;
PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv = NULL;
PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i = NULL;
PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv = NULL;
PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui = NULL;
PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv = NULL;
PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d = NULL;
PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv = NULL;
PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f = NULL;
PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv = NULL;
PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i = NULL;
PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv = NULL;
PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui = NULL;
PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv = NULL;
PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d = NULL;
PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv = NULL;
PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f = NULL;
PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv = NULL;
PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i = NULL;
PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv = NULL;
PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui = NULL;
PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv = NULL;
PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d = NULL;
PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv = NULL;
PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f = NULL;
PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv = NULL;
PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i = NULL;
PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv = NULL;
PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui = NULL;
PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv = NULL;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = NULL;
PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup = NULL;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter = NULL;
PFNGLREADBUFFERPROC glad_glReadBuffer = NULL;
PFNGLREADPIXELSPROC glad_glReadPixels = NULL;
PFNGLREADNPIXELSPROC glad_glReadnPixels = NULL;
PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler = NULL;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = NULL;
PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = NULL;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = NULL;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski = NULL;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = NULL;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = NULL;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = NULL;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = NULL;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = NULL;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = NULL;
PFNGLSCISSORPROC glad_glScissor = NULL;
PFNGLSCISSORARRAYVPROC glad_glScissorArrayv = NULL;
PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed = NULL;
PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv = NULL;
PFNGLSHADERBINARYPROC glad_glShaderBinary = NULL;
PFNGLSHADERSOURCEPROC glad_glShaderSource = NULL;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding = NULL;
PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader = NULL;
PFNGLSTENCILFUNCPROC glad_glStencilFunc = NULL;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = NULL;
PFNGLSTENCILMASKPROC glad_glStencilMask = NULL;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = NULL;
PFNGLSTENCILOPPROC glad_glStencilOp = NULL;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = NULL;
PFNGLTEXBUFFERPROC glad_glTexBuffer = NULL;
PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange = NULL;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D = NULL;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D = NULL;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = NULL;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D = NULL;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = NULL;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = NULL;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = NULL;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf = NULL;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = NULL;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri = NULL;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = NULL;
PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D = NULL;
PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D = NULL;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample = NULL;
PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D = NULL;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample = NULL;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = NULL;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = NULL;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = NULL;
PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier = NULL;
PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer = NULL;
PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange = NULL;
PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv = NULL;
PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv = NULL;
PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf = NULL;
PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv = NULL;
PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri = NULL;
PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv = NULL;
PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D = NULL;
PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D = NULL;
PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample = NULL;
PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D = NULL;
PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample = NULL;
PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D = NULL;
PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D = NULL;
PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D = NULL;
PFNGLTEXTUREVIEWPROC glad_glTextureView = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = NULL;
PFNGLUNIFORM1DPROC glad_glUniform1d = NULL;
PFNGLUNIFORM1DVPROC glad_glUniform1dv = NULL;
PFNGLUNIFORM1FPROC glad_glUniform1f = NULL;
PFNGLUNIFORM1FVPROC glad_glUniform1fv = NULL;
PFNGLUNIFORM1IPROC glad_glUniform1i = NULL;
PFNGLUNIFORM1IVPROC glad_glUniform1iv = NULL;
PFNGLUNIFORM1UIPROC glad_glUniform1ui = NULL;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = NULL;
PFNGLUNIFORM2DPROC glad_glUniform2d = NULL;
PFNGLUNIFORM2DVPROC glad_glUniform2dv = NULL;
PFNGLUNIFORM2FPROC glad_glUniform2f = NULL;
PFNGLUNIFORM2FVPROC glad_glUniform2fv = NULL;
PFNGLUNIFORM2IPROC glad_glUniform2i = NULL;
PFNGLUNIFORM2IVPROC glad_glUniform2iv = NULL;
PFNGLUNIFORM2UIPROC glad_glUniform2ui = NULL;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = NULL;
PFNGLUNIFORM3DPROC glad_glUniform3d = NULL;
PFNGLUNIFORM3DVPROC glad_glUniform3dv = NULL;
PFNGLUNIFORM3FPROC glad_glUniform3f = NULL;
PFNGLUNIFORM3FVPROC glad_glUniform3fv = NULL;
PFNGLUNIFORM3IPROC glad_glUniform3i = NULL;
PFNGLUNIFORM3IVPROC glad_glUniform3iv = NULL;
PFNGLUNIFORM3UIPROC glad_glUniform3ui = NULL;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = NULL;
PFNGLUNIFORM4DPROC glad_glUniform4d = NULL;
PFNGLUNIFORM4DVPROC glad_glUniform4dv = NULL;
PFNGLUNIFORM4FPROC glad_glUniform4f = NULL;
PFNGLUNIFORM4FVPROC glad_glUniform4fv = NULL;
PFNGLUNIFORM4IPROC glad_glUniform4i = NULL;
PFNGLUNIFORM4IVPROC glad_glUniform4iv = NULL;
PFNGLUNIFORM4UIPROC glad_glUniform4ui = NULL;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = NULL;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = NULL;
PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = NULL;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = NULL;
PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = NULL;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = NULL;
PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = NULL;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = NULL;
PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = NULL;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = NULL;
PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = NULL;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = NULL;
PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = NULL;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = NULL;
PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = NULL;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = NULL;
PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = NULL;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = NULL;
PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = NULL;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = NULL;
PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = NULL;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = NULL;
PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer = NULL;
PFNGLUSEPROGRAMPROC glad_glUseProgram = NULL;
PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages = NULL;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = NULL;
PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline = NULL;
PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding = NULL;
PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat = NULL;
PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat = NULL;
PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat = NULL;
PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor = NULL;
PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers = NULL;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = NULL;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = NULL;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = NULL;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = NULL;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = NULL;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = NULL;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = NULL;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = NULL;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = NULL;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = NULL;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = NULL;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = NULL;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = NULL;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = NULL;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = NULL;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = NULL;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = NULL;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = NULL;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = NULL;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = NULL;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = NULL;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = NULL;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = NULL;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = NULL;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = NULL;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = NULL;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = NULL;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = NULL;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = NULL;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = NULL;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = NULL;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = NULL;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = NULL;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = NULL;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = NULL;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = NULL;
PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding = NULL;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = NULL;
PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat = NULL;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = NULL;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = NULL;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = NULL;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = NULL;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = NULL;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = NULL;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = NULL;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = NULL;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = NULL;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = NULL;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = NULL;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = NULL;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = NULL;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = NULL;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = NULL;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = NULL;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = NULL;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = NULL;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = NULL;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = NULL;
PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat = NULL;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = NULL;
PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d = NULL;
PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv = NULL;
PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d = NULL;
PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv = NULL;
PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d = NULL;
PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv = NULL;
PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d = NULL;
PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv = NULL;
PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat = NULL;
PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer = NULL;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = NULL;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = NULL;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = NULL;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = NULL;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = NULL;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = NULL;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = NULL;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = NULL;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = NULL;
PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor = NULL;
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
PFNGLWAITSYNCPROC glad_glWaitSync = NULL;


static void glad_gl_load_GL_VERSION_1_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_0) return;
    glad_glBlendFunc = (PFNGLBLENDFUNCPROC) load(userptr, "glBlendFunc");
    glad_glClear = (PFNGLCLEARPROC) load(userptr, "glClear");
    glad_glClearColor = (PFNGLCLEARCOLORPROC) load(userptr, "glClearColor");
    glad_glClearDepth = (PFNGLCLEARDEPTHPROC) load(userptr, "glClearDepth");
    glad_glClearStencil = (PFNGLCLEARSTENCILPROC) load(userptr, "glClearStencil");
    glad_glColorMask = (PFNGLCOLORMASKPROC) load(userptr, "glColorMask");
    glad_glCullFace = (PFNGLCULLFACEPROC) load(userptr, "glCullFace");
    glad_glDepthFunc = (PFNGLDEPTHFUNCPROC) load(userptr, "glDepthFunc");
    glad_glDepthMask = (PFNGLDEPTHMASKPROC) load(userptr, "glDepthMask");
    glad_glDepthRange = (PFNGLDEPTHRANGEPROC) load(userptr, "glDepthRange");
    glad_glDisable = (PFNGLDISABLEPROC) load(userptr, "glDisable");
    glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC) load(userptr, "glDrawBuffer");
    glad_glEnable = (PFNGLENABLEPROC) load(userptr, "glEnable");
    glad_glFinish = (PFNGLFINISHPROC) load(userptr, "glFinish");
    glad_glFlush = (PFNGLFLUSHPROC) load(userptr, "glFlush");
    glad_glFrontFace = (PFNGLFRONTFACEPROC) load(userptr, "glFrontFace");
    glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC) load(userptr, "glGetBooleanv");
    glad_glGetDoublev = (PFNGLGETDOUBLEVPROC) load(userptr, "glGetDoublev");
    glad_glGetError = (PFNGLGETERRORPROC) load(userptr, "glGetError");
    glad_glGetFloatv = (PFNGLGETFLOATVPROC) load(userptr, "glGetFloatv");
    glad_glGetIntegerv = (PFNGLGETINTEGERVPROC) load(userptr, "glGetIntegerv");
    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
    glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC) load(userptr, "glGetTexImage");
    glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC) load(userptr, "glGetTexLevelParameterfv");
    glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC) load(userptr, "glGetTexLevelParameteriv");
    glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC) load(userptr, "glGetTexParameterfv");
    glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC) load(userptr, "glGetTexParameteriv");
    glad_glHint = (PFNGLHINTPROC) load(userptr, "glHint");
    glad_glIsEnabled = (PFNGLISENABLEDPROC) load(userptr, "glIsEnabled");
    glad_glLineWidth = (PFNGLLINEWIDTHPROC) load(userptr, "glLineWidth");
    glad_glLogicOp = (PFNGLLOGICOPPROC) load(userptr, "glLogicOp");
    glad_glPixelStoref = (PFNGLPIXELSTOREFPROC) load(userptr, "glPixelStoref");
    glad_glPixelStorei = (PFNGLPIXELSTOREIPROC) load(userptr, "glPixelStorei");
    glad_glPointSize = (PFNGLPOINTSIZEPROC) load(userptr, "glPointSize");
    glad_glPolygonMode = (PFNGLPOLYGONMODEPROC) load(userptr, "glPolygonMode");
    glad_glReadBuffer = (PFNGLREADBUFFERPROC) load(userptr, "glReadBuffer");
    glad_glReadPixels = (PFNGLREADPIXELSPROC) load(userptr, "glReadPixels");
    glad_glScissor = (PFNGLSCISSORPROC) load(userptr, "glScissor");
    glad_glStencilFunc = (PFNGLSTENCILFUNCPROC) load(userptr, "glStencilFunc");
    glad_glStencilMask = (PFNGLSTENCILMASKPROC) load(userptr, "glStencilMask");
    glad_glStencilOp = (PFNGLSTENCILOPPROC) load(userptr, "glStencilOp");
    glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC) load(userptr, "glTexImage1D");
    glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC) load(userptr, "glTexImage2D");
    glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC) load(userptr, "glTexParameterf");
    glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC) load(userptr, "glTexParameterfv");
    glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC) load(userptr, "glTexParameteri");
    glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC) load(userptr, "glTexParameteriv");
    glad_glViewport = (PFNGLVIEWPORTPROC) load(userptr, "glViewport");
}
static void glad_gl_load_GL_VERSION_1_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_1) return;
    glad_glBindTexture = (PFNGLBINDTEXTUREPROC) load(userptr, "glBindTexture");
    glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC) load(userptr, "glCopyTexImage1D");
    glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) load(userptr, "glCopyTexImage2D");
    glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC) load(userptr, "glCopyTexSubImage1D");
    glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) load(userptr, "glCopyTexSubImage2D");
    glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC) load(userptr, "glDeleteTextures");
    glad_glDrawArrays = (PFNGLDRAWARRAYSPROC) load(userptr, "glDrawArrays");
    glad_glDrawElements = (PFNGLDRAWELEMENTSPROC) load(userptr, "glDrawElements");
    glad_glGenTextures = (PFNGLGENTEXTURESPROC) load(userptr, "glGenTextures");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glIsTexture = (PFNGLISTEXTUREPROC) load(userptr, "glIsTexture");
    glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC) load(userptr, "glPolygonOffset");
    glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC) load(userptr, "glTexSubImage1D");
    glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) load(userptr, "glTexSubImage2D");
}
static void glad_gl_load_GL_VERSION_1_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_2) return;
    glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) load(userptr, "glCopyTexSubImage3D");
    glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) load(userptr, "glDrawRangeElements");
    glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC) load(userptr, "glTexImage3D");
    glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) load(userptr, "glTexSubImage3D");
}
static void glad_gl_load_GL_VERSION_1_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_3) return;
    glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC) load(userptr, "glActiveTexture");
    glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC) load(userptr, "glCompressedTexImage1D");
    glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) load(userptr, "glCompressedTexImage2D");
    glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) load(userptr, "glCompressedTexImage3D");
    glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) load(userptr, "glCompressedTexSubImage1D");
    glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) load(userptr, "glCompressedTexSubImage2D");
    glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) load(userptr, "glCompressedTexSubImage3D");
    glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetCompressedTexImage");
    glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) load(userptr, "glSampleCoverage");
}
static void glad_gl_load_GL_VERSION_1_4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_4) return;
    glad_glBlendColor = (PFNGLBLENDCOLORPROC) load(userptr, "glBlendColor");
    glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC) load(userptr, "glBlendEquation");
    glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) load(userptr, "glBlendFuncSeparate");
    glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC) load(userptr, "glMultiDrawArrays");
    glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC) load(userptr, "glMultiDrawElements");
    glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) load(userptr, "glPointParameterf");
    glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) load(userptr, "glPointParameterfv");
    glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC) load(userptr, "glPointParameteri");
    glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC) load(userptr, "glPointParameteriv");
}
static void glad_gl_load_GL_VERSION_1_5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_5) return;
    glad_glBeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, "glBeginQuery");
    glad_glBindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, "glBindBuffer");
    glad_glBufferData = (PFNGLBUFFERDATAPROC) load(userptr, "glBufferData");
    glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, "glBufferSubData");
    glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, "glDeleteBuffers");
    glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, "glDeleteQueries");
    glad_glEndQuery = (PFNGLENDQUERYPROC) load(userptr, "glEndQuery");
    glad_glGenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, "glGenBuffers");
    glad_glGenQueries = (PFNGLGENQUERIESPROC) load(userptr, "glGenQueries");
    glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, "glGetBufferParameteriv");
    glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, "glGetBufferPointerv");
    glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, "glGetBufferSubData");
    glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, "glGetQueryObjectiv");
    glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, "glGetQueryObjectuiv");
    glad_glGetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, "glGetQueryiv");
    glad_glIsBuffer = (PFNGLISBUFFERPROC) load(userptr, "glIsBuffer");
    glad_glIsQuery = (PFNGLISQUERYPROC) load(userptr, "glIsQuery");
    glad_glMapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, "glMapBuffer");
    glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, "glUnmapBuffer");
}
static void glad_gl_load_GL_VERSION_2_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_2_0) return;
    glad_glAttachShader = (PFNGLATTACHSHADERPROC) load(userptr, "glAttachShader");
    glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) load(userptr, "glBindAttribLocation");
    glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) load(userptr, "glBlendEquationSeparate");
    glad_glCompileShader = (PFNGLCOMPILESHADERPROC) load(userptr, "glCompileShader");
    glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC) load(userptr, "glCreateProgram");
    glad_glCreateShader = (PFNGLCREATESHADERPROC) load(userptr, "glCreateShader");
    glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC) load(userptr, "glDeleteProgram");
    glad_glDeleteShader = (PFNGLDELETESHADERPROC) load(userptr, "glDeleteShader");
    glad_glDetachShader = (PFNGLDETACHSHADERPROC) load(userptr, "glDetachShader");
    glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) load(userptr, "glDisableVertexAttribArray");
    glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) load(userptr, "glDrawBuffers");
    glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) load(userptr, "glEnableVertexAttribArray");
    glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) load(userptr, "glGetActiveAttrib");
    glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) load(userptr, "glGetActiveUniform");
    glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC) load(userptr, "glGetAttachedShaders");
    glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) load(userptr, "glGetAttribLocation");
    glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) load(userptr, "glGetProgramInfoLog");
    glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC) load(userptr, "glGetProgramiv");
    glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) load(userptr, "glGetShaderInfoLog");
    glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) load(userptr, "glGetShaderSource");
    glad_glGetShaderiv = (PFNGLGETSHADERIVPROC) load(userptr, "glGetShaderiv");
    glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) load(userptr, "glGetUniformLocation");
    glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) load(userptr, "glGetUniformfv");
    glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) load(userptr, "glGetUniformiv");
    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
    glad_glIsProgram = (PFNGLISPROGRAMPROC) load(userptr, "glIsProgram");
    glad_glIsShader = (PFNGLISSHADERPROC) load(userptr, "glIsShader");
    glad_glLinkProgram = (PFNGLLINKPROGRAMPROC) load(userptr, "glLinkProgram");
    glad_glShaderSource = (PFNGLSHADERSOURCEPROC) load(userptr, "glShaderSource");
    glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC) load(userptr, "glStencilFuncSeparate");
    glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC) load(userptr, "glStencilMaskSeparate");
    glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) load(userptr, "glStencilOpSeparate");
    glad_glUniform1f = (PFNGLUNIFORM1FPROC) load(userptr, "glUniform1f");
    glad_glUniform1fv = (PFNGLUNIFORM1FVPROC) load(userptr, "glUniform1fv");
    glad_glUniform1i = (PFNGLUNIFORM1IPROC) load(userptr, "glUniform1i");
    glad_glUniform1iv = (PFNGLUNIFORM1IVPROC) load(userptr, "glUniform1iv");
    glad_glUniform2f = (PFNGLUNIFORM2FPROC) load(userptr, "glUniform2f");
    glad_glUniform2fv = (PFNGLUNIFORM2FVPROC) load(userptr, "glUniform2fv");
    glad_glUniform2i = (PFNGLUNIFORM2IPROC) load(userptr, "glUniform2i");
    glad_glUniform2iv = (PFNGLUNIFORM2IVPROC) load(userptr, "glUniform2iv");
    glad_glUniform3f = (PFNGLUNIFORM3FPROC) load(userptr, "glUniform3f");
    glad_glUniform3fv = (PFNGLUNIFORM3FVPROC) load(userptr, "glUniform3fv");
    glad_glUniform3i = (PFNGLUNIFORM3IPROC) load(userptr, "glUniform3i");
    glad_glUniform3iv = (PFNGLUNIFORM3IVPROC) load(userptr, "glUniform3iv");
    glad_glUniform4f = (PFNGLUNIFORM4FPROC) load(userptr, "glUniform4f");
    glad_glUniform4fv = (PFNGLUNIFORM4FVPROC) load(userptr, "glUniform4fv");
    glad_glUniform4i = (PFNGLUNIFORM4IPROC) load(userptr, "glUniform4i");
    glad_glUniform4iv = (PFNGLUNIFORM4IVPROC) load(userptr, "glUniform4iv");
    glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) load(userptr, "glUniformMatrix2fv");
    glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) load(userptr, "glUniformMatrix3fv");
    glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) load(userptr, "glUniformMatrix4fv");
    glad_glUseProgram = (PFNGLUSEPROGRAMPROC) load(userptr, "glUseProgram");
    glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) load(userptr, "glValidateProgram");
    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
    glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) load(userptr, "glVertexAttrib4Nbv");
    glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) load(userptr, "glVertexAttrib4Niv");
    glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) load(userptr, "glVertexAttrib4Nsv");
    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
    glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) load(userptr, "glVertexAttrib4Nuiv");
    glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) load(userptr, "glVertexAttrib4Nusv");
    glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) load(userptr, "glVertexAttrib4bv");
    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
    glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) load(userptr, "glVertexAttrib4iv");
    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
    glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) load(userptr, "glVertexAttrib4ubv");
    glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) load(userptr, "glVertexAttrib4uiv");
    glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) load(userptr, "glVertexAttrib4usv");
    glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) load(userptr, "glVertexAttribPointer");
}
static void glad_gl_load_GL_VERSION_2_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_2_1) return;
    glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC) load(userptr, "glUniformMatrix2x3fv");
    glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC) load(userptr, "glUniformMatrix2x4fv");
    glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC) load(userptr, "glUniformMatrix3x2fv");
    glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC) load(userptr, "glUniformMatrix3x4fv");
    glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC) load(userptr, "glUniformMatrix4x2fv");
    glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC) load(userptr, "glUniformMatrix4x3fv");
}
static void glad_gl_load_GL_VERSION_3_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_0) return;
    glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC) load(userptr, "glBeginConditionalRender");
    glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) load(userptr, "glBeginTransformFeedback");
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC) load(userptr, "glBindFragDataLocation");
    glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) load(userptr, "glBindFramebuffer");
    glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) load(userptr, "glBindRenderbuffer");
    glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) load(userptr, "glBindVertexArray");
    glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) load(userptr, "glBlitFramebuffer");
    glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckFramebufferStatus");
    glad_glClampColor = (PFNGLCLAMPCOLORPROC) load(userptr, "glClampColor");
    glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC) load(userptr, "glClearBufferfi");
    glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC) load(userptr, "glClearBufferfv");
    glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC) load(userptr, "glClearBufferiv");
    glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC) load(userptr, "glClearBufferuiv");
    glad_glColorMaski = (PFNGLCOLORMASKIPROC) load(userptr, "glColorMaski");
    glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) load(userptr, "glDeleteFramebuffers");
    glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) load(userptr, "glDeleteRenderbuffers");
    glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) load(userptr, "glDeleteVertexArrays");
    glad_glDisablei = (PFNGLDISABLEIPROC) load(userptr, "glDisablei");
    glad_glEnablei = (PFNGLENABLEIPROC) load(userptr, "glEnablei");
    glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) load(userptr, "glEndConditionalRender");
    glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) load(userptr, "glEndTransformFeedback");
    glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) load(userptr, "glFlushMappedBufferRange");
    glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glFramebufferRenderbuffer");
    glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) load(userptr, "glFramebufferTexture1D");
    glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) load(userptr, "glFramebufferTexture2D");
    glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) load(userptr, "glFramebufferTexture3D");
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) load(userptr, "glGenFramebuffers");
    glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) load(userptr, "glGenRenderbuffers");
    glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) load(userptr, "glGenVertexArrays");
    glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) load(userptr, "glGenerateMipmap");
    glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) load(userptr, "glGetBooleani_v");
    glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) load(userptr, "glGetFragDataLocation");
    glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetFramebufferAttachmentParameteriv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetRenderbufferParameteriv");
    glad_glGetStringi = (PFNGLGETSTRINGIPROC) load(userptr, "glGetStringi");
    glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) load(userptr, "glGetTexParameterIiv");
    glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) load(userptr, "glGetTexParameterIuiv");
    glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) load(userptr, "glGetTransformFeedbackVarying");
    glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) load(userptr, "glGetUniformuiv");
    glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) load(userptr, "glGetVertexAttribIiv");
    glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) load(userptr, "glGetVertexAttribIuiv");
    glad_glIsEnabledi = (PFNGLISENABLEDIPROC) load(userptr, "glIsEnabledi");
    glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) load(userptr, "glIsFramebuffer");
    glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) load(userptr, "glIsRenderbuffer");
    glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) load(userptr, "glIsVertexArray");
    glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) load(userptr, "glMapBufferRange");
    glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) load(userptr, "glRenderbufferStorage");
    glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glRenderbufferStorageMultisample");
    glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) load(userptr, "glTexParameterIiv");
    glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) load(userptr, "glTexParameterIuiv");
    glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) load(userptr, "glTransformFeedbackVaryings");
    glad_glUniform1ui = (PFNGLUNIFORM1UIPROC) load(userptr, "glUniform1ui");
    glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) load(userptr, "glUniform1uiv");
    glad_glUniform2ui = (PFNGLUNIFORM2UIPROC) load(userptr, "glUniform2ui");
    glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) load(userptr, "glUniform2uiv");
    glad_glUniform3ui = (PFNGLUNIFORM3UIPROC) load(userptr, "glUniform3ui");
    glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) load(userptr, "glUniform3uiv");
    glad_glUniform4ui = (PFNGLUNIFORM4UIPROC) load(userptr, "glUniform4ui");
    glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) load(userptr, "glUniform4uiv");
    glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC) load(userptr, "glVertexAttribI1i");
    glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC) load(userptr, "glVertexAttribI1iv");
    glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC) load(userptr, "glVertexAttribI1ui");
    glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC) load(userptr, "glVertexAttribI1uiv");
    glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC) load(userptr, "glVertexAttribI2i");
    glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC) load(userptr, "glVertexAttribI2iv");
    glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC) load(userptr, "glVertexAttribI2ui");
    glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC) load(userptr, "glVertexAttribI2uiv");
    glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC) load(userptr, "glVertexAttribI3i");
    glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC) load(userptr, "glVertexAttribI3iv");
    glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC) load(userptr, "glVertexAttribI3ui");
    glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC) load(userptr, "glVertexAttribI3uiv");
    glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC) load(userptr, "glVertexAttribI4bv");
    glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) load(userptr, "glVertexAttribI4i");
    glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) load(userptr, "glVertexAttribI4iv");
    glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC) load(userptr, "glVertexAttribI4sv");
    glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC) load(userptr, "glVertexAttribI4ubv");
    glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) load(userptr, "glVertexAttribI4ui");
    glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) load(userptr, "glVertexAttribI4uiv");
    glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC) load(userptr, "glVertexAttribI4usv");
    glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) load(userptr, "glVertexAttribIPointer");
}
static void glad_gl_load_GL_VERSION_3_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_1) return;
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, "glCopyBufferSubData");
    glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, "glDrawArraysInstanced");
    glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, "glDrawElementsInstanced");
    glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, "glGetActiveUniformBlockName");
    glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, "glGetActiveUniformBlockiv");
    glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, "glGetActiveUniformName");
    glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, "glGetActiveUniformsiv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, "glGetUniformBlockIndex");
    glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, "glGetUniformIndices");
    glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) load(userptr, "glPrimitiveRestartIndex");
    glad_glTexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, "glTexBuffer");
    glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, "glUniformBlockBinding");
}
static void glad_gl_load_GL_VERSION_3_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_2) return;
    glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, "glClientWaitSync");
    glad_glDeleteSync = (PFNGLDELETESYNCPROC) load(userptr, "glDeleteSync");
    glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glDrawElementsBaseVertex");
    glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, "glDrawElementsInstancedBaseVertex");
    glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, "glDrawRangeElementsBaseVertex");
    glad_glFenceSync = (PFNGLFENCESYNCPROC) load(userptr, "glFenceSync");
    glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, "glFramebufferTexture");
    glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) load(userptr, "glGetBufferParameteri64v");
    glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) load(userptr, "glGetInteger64i_v");
    glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, "glGetInteger64v");
    glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, "glGetMultisamplefv");
    glad_glGetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, "glGetSynciv");
    glad_glIsSync = (PFNGLISSYNCPROC) load(userptr, "glIsSync");
    glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glMultiDrawElementsBaseVertex");
    glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, "glProvokingVertex");
    glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, "glSampleMaski");
    glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, "glTexImage2DMultisample");
    glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, "glTexImage3DMultisample");
    glad_glWaitSync = (PFNGLWAITSYNCPROC) load(userptr, "glWaitSync");
}
static void glad_gl_load_GL_VERSION_3_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_3) return;
    glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) load(userptr, "glBindFragDataLocationIndexed");
    glad_glBindSampler = (PFNGLBINDSAMPLERPROC) load(userptr, "glBindSampler");
    glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) load(userptr, "glDeleteSamplers");
    glad_glGenSamplers = (PFNGLGENSAMPLERSPROC) load(userptr, "glGenSamplers");
    glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) load(userptr, "glGetFragDataIndex");
    glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) load(userptr, "glGetQueryObjecti64v");
    glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) load(userptr, "glGetQueryObjectui64v");
    glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) load(userptr, "glGetSamplerParameterIiv");
    glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) load(userptr, "glGetSamplerParameterIuiv");
    glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) load(userptr, "glGetSamplerParameterfv");
    glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) load(userptr, "glGetSamplerParameteriv");
    glad_glIsSampler = (PFNGLISSAMPLERPROC) load(userptr, "glIsSampler");
    glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC) load(userptr, "glQueryCounter");
    glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) load(userptr, "glSamplerParameterIiv");
    glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) load(userptr, "glSamplerParameterIuiv");
    glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) load(userptr, "glSamplerParameterf");
    glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) load(userptr, "glSamplerParameterfv");
    glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) load(userptr, "glSamplerParameteri");
    glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) load(userptr, "glSamplerParameteriv");
    glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) load(userptr, "glVertexAttribDivisor");
    glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) load(userptr, "glVertexAttribP1ui");
    glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) load(userptr, "glVertexAttribP1uiv");
    glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) load(userptr, "glVertexAttribP2ui");
    glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) load(userptr, "glVertexAttribP2uiv");
    glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) load(userptr, "glVertexAttribP3ui");
    glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) load(userptr, "glVertexAttribP3uiv");
    glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) load(userptr, "glVertexAttribP4ui");
    glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) load(userptr, "glVertexAttribP4uiv");
}
static void glad_gl_load_GL_VERSION_4_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_0) return;
    glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, "glBeginQueryIndexed");
    glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, "glBindTransformFeedback");
    glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, "glBlendEquationSeparatei");
    glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, "glBlendEquationi");
    glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, "glBlendFuncSeparatei");
    glad_glBlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, "glBlendFunci");
    glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, "glDeleteTransformFeedbacks");
    glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, "glDrawArraysIndirect");
    glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, "glDrawElementsIndirect");
    glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, "glDrawTransformFeedback");
    glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, "glDrawTransformFeedbackStream");
    glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, "glEndQueryIndexed");
    glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, "glGenTransformFeedbacks");
    glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, "glGetActiveSubroutineName");
    glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, "glGetActiveSubroutineUniformName");
    glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, "glGetActiveSubroutineUniformiv");
    glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, "glGetProgramStageiv");
    glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, "glGetQueryIndexediv");
    glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, "glGetSubroutineIndex");
    glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, "glGetSubroutineUniformLocation");
    glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, "glGetUniformSubroutineuiv");
    glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, "glGetUniformdv");
    glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, "glIsTransformFeedback");
    glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, "glMinSampleShading");
    glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, "glPatchParameterfv");
    glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, "glPatchParameteri");
    glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, "glPauseTransformFeedback");
    glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, "glResumeTransformFeedback");
    glad_glUniform1d = (PFNGLUNIFORM1DPROC) load(userptr, "glUniform1d");
    glad_glUniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, "glUniform1dv");
    glad_glUniform2d = (PFNGLUNIFORM2DPROC) load(userptr, "glUniform2d");
    glad_glUniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, "glUniform2dv");
    glad_glUniform3d = (PFNGLUNIFORM3DPROC) load(userptr, "glUniform3d");
    glad_glUniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, "glUniform3dv");
    glad_glUniform4d = (PFNGLUNIFORM4DPROC) load(userptr, "glUniform4d");
    glad_glUniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, "glUniform4dv");
    glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, "glUniformMatrix2dv");
    glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, "glUniformMatrix2x3dv");
    glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, "glUniformMatrix2x4dv");
    glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, "glUniformMatrix3dv");
    glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, "glUniformMatrix3x2dv");
    glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, "glUniformMatrix3x4dv");
    glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, "glUniformMatrix4dv");
    glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, "glUniformMatrix4x2dv");
    glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, "glUniformMatrix4x3dv");
    glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, "glUniformSubroutinesuiv");
}
static void glad_gl_load_GL_VERSION_4_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_1) return;
    glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) load(userptr, "glActiveShaderProgram");
    glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) load(userptr, "glBindProgramPipeline");
    glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC) load(userptr, "glClearDepthf");
    glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) load(userptr, "glCreateShaderProgramv");
    glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) load(userptr, "glDeleteProgramPipelines");
    glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC) load(userptr, "glDepthRangeArrayv");
    glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC) load(userptr, "glDepthRangeIndexed");
    glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC) load(userptr, "glDepthRangef");
    glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) load(userptr, "glGenProgramPipelines");
    glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) load(userptr, "glGetDoublei_v");
    glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC) load(userptr, "glGetFloati_v");
    glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) load(userptr, "glGetProgramBinary");
    glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) load(userptr, "glGetProgramPipelineInfoLog");
    glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) load(userptr, "glGetProgramPipelineiv");
    glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) load(userptr, "glGetShaderPrecisionFormat");
    glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) load(userptr, "glGetVertexAttribLdv");
    glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) load(userptr, "glIsProgramPipeline");
    glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC) load(userptr, "glProgramBinary");
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
    glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC) load(userptr, "glProgramUniform1d");
    glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC) load(userptr, "glProgramUniform1dv");
    glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) load(userptr, "glProgramUniform1f");
    glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) load(userptr, "glProgramUniform1fv");
    glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) load(userptr, "glProgramUniform1i");
    glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) load(userptr, "glProgramUniform1iv");
    glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) load(userptr, "glProgramUniform1ui");
    glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) load(userptr, "glProgramUniform1uiv");
    glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC) load(userptr, "glProgramUniform2d");
    glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC) load(userptr, "glProgramUniform2dv");
    glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) load(userptr, "glProgramUniform2f");
    glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) load(userptr, "glProgramUniform2fv");
    glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) load(userptr, "glProgramUniform2i");
    glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) load(userptr, "glProgramUniform2iv");
    glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) load(userptr, "glProgramUniform2ui");
    glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) load(userptr, "glProgramUniform2uiv");
    glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC) load(userptr, "glProgramUniform3d");
    glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC) load(userptr, "glProgramUniform3dv");
    glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) load(userptr, "glProgramUniform3f");
    glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) load(userptr, "glProgramUniform3fv");
    glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) load(userptr, "glProgramUniform3i");
    glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) load(userptr, "glProgramUniform3iv");
    glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) load(userptr, "glProgramUniform3ui");
    glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) load(userptr, "glProgramUniform3uiv");
    glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC) load(userptr, "glProgramUniform4d");
    glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC) load(userptr, "glProgramUniform4dv");
    glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) load(userptr, "glProgramUniform4f");
    glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) load(userptr, "glProgramUniform4fv");
    glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) load(userptr, "glProgramUniform4i");
    glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) load(userptr, "glProgramUniform4iv");
    glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) load(userptr, "glProgramUniform4ui");
    glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) load(userptr, "glProgramUniform4uiv");
    glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC) load(userptr, "glProgramUniformMatrix2dv");
    glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) load(userptr, "glProgramUniformMatrix2fv");
    glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) load(userptr, "glProgramUniformMatrix2x3dv");
    glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) load(userptr, "glProgramUniformMatrix2x3fv");
    glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) load(userptr, "glProgramUniformMatrix2x4dv");
    glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) load(userptr, "glProgramUniformMatrix2x4fv");
    glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC) load(userptr, "glProgramUniformMatrix3dv");
    glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) load(userptr, "glProgramUniformMatrix3fv");
    glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) load(userptr, "glProgramUniformMatrix3x2dv");
    glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) load(userptr, "glProgramUniformMatrix3x2fv");
    glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) load(userptr, "glProgramUniformMatrix3x4dv");
    glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) load(userptr, "glProgramUniformMatrix3x4fv");
    glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC) load(userptr, "glProgramUniformMatrix4dv");
    glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) load(userptr, "glProgramUniformMatrix4fv");
    glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) load(userptr, "glProgramUniformMatrix4x2dv");
    glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) load(userptr, "glProgramUniformMatrix4x2fv");
    glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) load(userptr, "glProgramUniformMatrix4x3dv");
    glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) load(userptr, "glProgramUniformMatrix4x3fv");
    glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) load(userptr, "glReleaseShaderCompiler");
    glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC) load(userptr, "glScissorArrayv");
    glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC) load(userptr, "glScissorIndexed");
    glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC) load(userptr, "glScissorIndexedv");
    glad_glShaderBinary = (PFNGLSHADERBINARYPROC) load(userptr, "glShaderBinary");
    glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) load(userptr, "glUseProgramStages");
    glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) load(userptr, "glValidateProgramPipeline");
    glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) load(userptr, "glVertexAttribL1d");
    glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) load(userptr, "glVertexAttribL1dv");
    glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) load(userptr, "glVertexAttribL2d");
    glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) load(userptr, "glVertexAttribL2dv");
    glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) load(userptr, "glVertexAttribL3d");
    glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) load(userptr, "glVertexAttribL3dv");
    glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) load(userptr, "glVertexAttribL4d");
    glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) load(userptr, "glVertexAttribL4dv");
    glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) load(userptr, "glVertexAttribLPointer");
    glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC) load(userptr, "glViewportArrayv");
    glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC) load(userptr, "glViewportIndexedf");
    glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC) load(userptr, "glViewportIndexedfv");
}
static void glad_gl_load_GL_VERSION_4_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_2) return;
    glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) load(userptr, "glBindImageTexture");
    glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawArraysInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseVertexBaseInstance");
    glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackInstanced");
    glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackStreamInstanced");
    glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) load(userptr, "glGetActiveAtomicCounterBufferiv");
    glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) load(userptr, "glGetInternalformativ");
    glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) load(userptr, "glMemoryBarrier");
    glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC) load(userptr, "glTexStorage1D");
    glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) load(userptr, "glTexStorage2D");
    glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) load(userptr, "glTexStorage3D");
}
static void glad_gl_load_GL_VERSION_4_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_3) return;
    glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) load(userptr, "glBindVertexBuffer");
    glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC) load(userptr, "glClearBufferData");
    glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC) load(userptr, "glClearBufferSubData");
    glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) load(userptr, "glCopyImageSubData");
    glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) load(userptr, "glDebugMessageCallback");
    glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) load(userptr, "glDebugMessageControl");
    glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) load(userptr, "glDebugMessageInsert");
    glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) load(userptr, "glDispatchCompute");
    glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) load(userptr, "glDispatchComputeIndirect");
    glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) load(userptr, "glFramebufferParameteri");
    glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) load(userptr, "glGetDebugMessageLog");
    glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetFramebufferParameteriv");
    glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC) load(userptr, "glGetInternalformati64v");
    glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) load(userptr, "glGetObjectLabel");
    glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) load(userptr, "glGetObjectPtrLabel");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) load(userptr, "glGetProgramInterfaceiv");
    glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) load(userptr, "glGetProgramResourceIndex");
    glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) load(userptr, "glGetProgramResourceLocation");
    glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) load(userptr, "glGetProgramResourceLocationIndex");
    glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) load(userptr, "glGetProgramResourceName");
    glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) load(userptr, "glGetProgramResourceiv");
    glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC) load(userptr, "glInvalidateBufferData");
    glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC) load(userptr, "glInvalidateBufferSubData");
    glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) load(userptr, "glInvalidateFramebuffer");
    glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) load(userptr, "glInvalidateSubFramebuffer");
    glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC) load(userptr, "glInvalidateTexImage");
    glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC) load(userptr, "glInvalidateTexSubImage");
    glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) load(userptr, "glMultiDrawArraysIndirect");
    glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) load(userptr, "glMultiDrawElementsIndirect");
    glad_glObjectLabel = (PFNGLOBJECTLABELPROC) load(userptr, "glObjectLabel");
    glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) load(userptr, "glObjectPtrLabel");
    glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) load(userptr, "glPopDebugGroup");
    glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) load(userptr, "glPushDebugGroup");
    glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC) load(userptr, "glShaderStorageBlockBinding");
    glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) load(userptr, "glTexBufferRange");
    glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) load(userptr, "glTexStorage2DMultisample");
    glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) load(userptr, "glTexStorage3DMultisample");
    glad_glTextureView = (PFNGLTEXTUREVIEWPROC) load(userptr, "glTextureView");
    glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) load(userptr, "glVertexAttribBinding");
    glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) load(userptr, "glVertexAttribFormat");
    glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) load(userptr, "glVertexAttribIFormat");
    glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC) load(userptr, "glVertexAttribLFormat");
    glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) load(userptr, "glVertexBindingDivisor");
}
static void glad_gl_load_GL_VERSION_4_4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_4) return;
    glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC) load(userptr, "glBindBuffersBase");
    glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC) load(userptr, "glBindBuffersRange");
    glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC) load(userptr, "glBindImageTextures");
    glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC) load(userptr, "glBindSamplers");
    glad_glBindTextures = (PFNGLBINDTEXTURESPROC) load(userptr, "glBindTextures");
    glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC) load(userptr, "glBindVertexBuffers");
    glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC) load(userptr, "glBufferStorage");
    glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC) load(userptr, "glClearTexImage");
    glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC) load(userptr, "glClearTexSubImage");
}
static void glad_gl_load_GL_VERSION_4_5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_5) return;
    glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC) load(userptr, "glBindTextureUnit");
    glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC) load(userptr, "glBlitNamedFramebuffer");
    glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckNamedFramebufferStatus");
    glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC) load(userptr, "glClearNamedBufferData");
    glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC) load(userptr, "glClearNamedBufferSubData");
    glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) load(userptr, "glClearNamedFramebufferfi");
    glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) load(userptr, "glClearNamedFramebufferfv");
    glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) load(userptr, "glClearNamedFramebufferiv");
    glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) load(userptr, "glClearNamedFramebufferuiv");
    glad_glClipControl = (PFNGLCLIPCONTROLPROC) load(userptr, "glClipControl");
    glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) load(userptr, "glCompressedTextureSubImage1D");
    glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) load(userptr, "glCompressedTextureSubImage2D");
    glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) load(userptr, "glCompressedTextureSubImage3D");
    glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC) load(userptr, "glCopyNamedBufferSubData");
    glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC) load(userptr, "glCopyTextureSubImage1D");
    glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC) load(userptr, "glCopyTextureSubImage2D");
    glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC) load(userptr, "glCopyTextureSubImage3D");
    glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC) load(userptr, "glCreateBuffers");
    glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC) load(userptr, "glCreateFramebuffers");
    glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC) load(userptr, "glCreateProgramPipelines");
    glad_glCreateQueries = (PFNGLCREATEQUERIESPROC) load(userptr, "glCreateQueries");
    glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC) load(userptr, "glCreateRenderbuffers");
    glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC) load(userptr, "glCreateSamplers");
    glad_glCreateTextures = (PFNGLCREATETEXTURESPROC) load(userptr, "glCreateTextures");
    glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC) load(userptr, "glCreateTransformFeedbacks");
    glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC) load(userptr, "glCreateVertexArrays");
    glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC) load(userptr, "glDisableVertexArrayAttrib");
    glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC) load(userptr, "glEnableVertexArrayAttrib");
    glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) load(userptr, "glFlushMappedNamedBufferRange");
    glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC) load(userptr, "glGenerateTextureMipmap");
    glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) load(userptr, "glGetCompressedTextureImage");
    glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) load(userptr, "glGetCompressedTextureSubImage");
    glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) load(userptr, "glGetGraphicsResetStatus");
    glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) load(userptr, "glGetNamedBufferParameteri64v");
    glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedBufferParameteriv");
    glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC) load(userptr, "glGetNamedBufferPointerv");
    glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC) load(userptr, "glGetNamedBufferSubData");
    glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferAttachmentParameteriv");
    glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferParameteriv");
    glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedRenderbufferParameteriv");
    glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC) load(userptr, "glGetQueryBufferObjecti64v");
    glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC) load(userptr, "glGetQueryBufferObjectiv");
    glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC) load(userptr, "glGetQueryBufferObjectui64v");
    glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC) load(userptr, "glGetQueryBufferObjectuiv");
    glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC) load(userptr, "glGetTextureImage");
    glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC) load(userptr, "glGetTextureLevelParameterfv");
    glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC) load(userptr, "glGetTextureLevelParameteriv");
    glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC) load(userptr, "glGetTextureParameterIiv");
    glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC) load(userptr, "glGetTextureParameterIuiv");
    glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC) load(userptr, "glGetTextureParameterfv");
    glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC) load(userptr, "glGetTextureParameteriv");
    glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC) load(userptr, "glGetTextureSubImage");
    glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC) load(userptr, "glGetTransformFeedbacki64_v");
    glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC) load(userptr, "glGetTransformFeedbacki_v");
    glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC) load(userptr, "glGetTransformFeedbackiv");
    glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC) load(userptr, "glGetVertexArrayIndexed64iv");
    glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC) load(userptr, "glGetVertexArrayIndexediv");
    glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC) load(userptr, "glGetVertexArrayiv");
    glad_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetnCompressedTexImage");
    glad_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC) load(userptr, "glGetnTexImage");
    glad_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC) load(userptr, "glGetnUniformdv");
    glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) load(userptr, "glGetnUniformfv");
    glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) load(userptr, "glGetnUniformiv");
    glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) load(userptr, "glGetnUniformuiv");
    glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) load(userptr, "glInvalidateNamedFramebufferData");
    glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) load(userptr, "glInvalidateNamedFramebufferSubData");
    glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC) load(userptr, "glMapNamedBuffer");
    glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC) load(userptr, "glMapNamedBufferRange");
    glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) load(userptr, "glMemoryBarrierByRegion");
    glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC) load(userptr, "glNamedBufferData");
    glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) load(userptr, "glNamedBufferStorage");
    glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) load(userptr, "glNamedBufferSubData");
    glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) load(userptr, "glNamedFramebufferDrawBuffer");
    glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) load(userptr, "glNamedFramebufferDrawBuffers");
    glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) load(userptr, "glNamedFramebufferParameteri");
    glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) load(userptr, "glNamedFramebufferReadBuffer");
    glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glNamedFramebufferRenderbuffer");
    glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) load(userptr, "glNamedFramebufferTexture");
    glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glNamedFramebufferTextureLayer");
    glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC) load(userptr, "glNamedRenderbufferStorage");
    glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glNamedRenderbufferStorageMultisample");
    glad_glReadnPixels = (PFNGLREADNPIXELSPROC) load(userptr, "glReadnPixels");
    glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC) load(userptr, "glTextureBarrier");
    glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC) load(userptr, "glTextureBuffer");
    glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC) load(userptr, "glTextureBufferRange");
    glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC) load(userptr, "glTextureParameterIiv");
    glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC) load(userptr, "glTextureParameterIuiv");
    glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC) load(userptr, "glTextureParameterf");
    glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC) load(userptr, "glTextureParameterfv");
    glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC) load(userptr, "glTextureParameteri");
    glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC) load(userptr, "glTextureParameteriv");
    glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC) load(userptr, "glTextureStorage1D");
    glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC) load(userptr, "glTextureStorage2D");
    glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) load(userptr, "glTextureStorage2DMultisample");
    glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC) load(userptr, "glTextureStorage3D");
    glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) load(userptr, "glTextureStorage3DMultisample");
    glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC) load(userptr, "glTextureSubImage1D");
    glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC) load(userptr, "glTextureSubImage2D");
    glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC) load(userptr, "glTextureSubImage3D");
    glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) load(userptr, "glTransformFeedbackBufferBase");
    glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) load(userptr, "glTransformFeedbackBufferRange");
    glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC) load(userptr, "glUnmapNamedBuffer");
    glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC) load(userptr, "glVertexArrayAttribBinding");
    glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC) load(userptr, "glVertexArrayAttribFormat");
    glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC) load(userptr, "glVertexArrayAttribIFormat");
    glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC) load(userptr, "glVertexArrayAttribLFormat");
    glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC) load(userptr, "glVertexArrayBindingDivisor");
    glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC) load(userptr, "glVertexArrayElementBuffer");
    glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC) load(userptr, "glVertexArrayVertexBuffer");
    glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC) load(userptr, "glVertexArrayVertexBuffers");
}
static void glad_gl_load_GL_VERSION_4_6( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_6) return;
    glad_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawArraysIndirectCount");
    glad_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawElementsIndirectCount");
    glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) load(userptr, "glPolygonOffsetClamp");
    glad_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC) load(userptr, "glSpecializeShader");
}



#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
#define GLAD_GL_IS_SOME_NEW_VERSION 1
#else
#define GLAD_GL_IS_SOME_NEW_VERSION 0
#endif

static int glad_gl_get_extensions( int version, const char **out_exts, unsigned int *out_num_exts_i, char ***out_exts_i) {
#if GLAD_GL_IS_SOME_NEW_VERSION
    if(GLAD_VERSION_MAJOR(version) < 3) {
#else
    GLAD_UNUSED(version);
    GLAD_UNUSED(out_num_exts_i);
    GLAD_UNUSED(out_exts_i);
#endif
        if (glad_glGetString == NULL) {
            return 0;
        }
        *out_exts = (const char *)glad_glGetString(GL_EXTENSIONS);
#if GLAD_GL_IS_SOME_NEW_VERSION
    } else {
        unsigned int index = 0;
        unsigned int num_exts_i = 0;
        char **exts_i = NULL;
        if (glad_glGetStringi == NULL || glad_glGetIntegerv == NULL) {
            return 0;
        }
        glad_glGetIntegerv(GL_NUM_EXTENSIONS, (int*) &num_exts_i);
        if (num_exts_i > 0) {
            exts_i = (char **) malloc(num_exts_i * (sizeof *exts_i));
        }
        if (exts_i == NULL) {
            return 0;
        }
        for(index = 0; index < num_exts_i; index++) {
            const char *gl_str_tmp = (const char*) glad_glGetStringi(GL_EXTENSIONS, index);
            size_t len = strlen(gl_str_tmp) + 1;

            char *local_str = (char*) malloc(len * sizeof(char));
            if(local_str != NULL) {
                memcpy(local_str, gl_str_tmp, len * sizeof(char));
            }

            exts_i[index] = local_str;
        }

        *out_num_exts_i = num_exts_i;
        *out_exts_i = exts_i;
    }
#endif
    return 1;
}
static void glad_gl_free_extensions(char **exts_i, unsigned int num_exts_i) {
    if (exts_i != NULL) {
        unsigned int index;
        for(index = 0; index < num_exts_i; index++) {
            free((void *) (exts_i[index]));
        }
        free((void *)exts_i);
        exts_i = NULL;
    }
}
static int glad_gl_has_extension(int version, const char *exts, unsigned int num_exts_i, char **exts_i, const char *ext) {
    if(GLAD_VERSION_MAJOR(version) < 3 || !GLAD_GL_IS_SOME_NEW_VERSION) {
        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == NULL || ext == NULL) {
            return 0;
        }
        while(1) {
            loc = strstr(extensions, ext);
            if(loc == NULL) {
                return 0;
            }
            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }
    } else {
        unsigned int index;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];
            if(strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }
    return 0;
}

static GLADapiproc glad_gl_get_proc_from_userptr(void *userptr, const char* name) {
    return (GLAD_GNUC_EXTENSION (GLADapiproc (*)(const char *name)) userptr)(name);
}

// Unable to find the docs for this function!
static int glad_gl_find_extensions_gl( int version) {
    const char *exts = NULL;
    unsigned int num_exts_i = 0;
    char **exts_i = NULL;
    if (!glad_gl_get_extensions(version, &exts, &num_exts_i, &exts_i)) return 0;

    GLAD_GL_EXT_texture_lod_bias = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_lod_bias");

    glad_gl_free_extensions(exts_i, num_exts_i);

    return 1;
}

// Unable to find the docs for this function!
static int glad_gl_find_core_gl(void) {
    int i;
    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        "OpenGL SC ",
        NULL
    };
    int major = 0;
    int minor = 0;
    version = (const char*) glad_glGetString(GL_VERSION);
    if (!version) return 0;
    for (i = 0;  prefixes[i];  i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }

    GLAD_IMPL_UTIL_SSCANF(version, "%d.%d", &major, &minor);

    GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
    GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
    GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
    GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
    GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
    GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
    GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
    GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
    GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
    GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
    GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
    GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
    GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;
    GLAD_GL_VERSION_4_1 = (major == 4 && minor >= 1) || major > 4;
    GLAD_GL_VERSION_4_2 = (major == 4 && minor >= 2) || major > 4;
    GLAD_GL_VERSION_4_3 = (major == 4 && minor >= 3) || major > 4;
    GLAD_GL_VERSION_4_4 = (major == 4 && minor >= 4) || major > 4;
    GLAD_GL_VERSION_4_5 = (major == 4 && minor >= 5) || major > 4;
    GLAD_GL_VERSION_4_6 = (major == 4 && minor >= 6) || major > 4;

    return GLAD_MAKE_VERSION(major, minor);
}

int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr) {
    int version;

    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
    if(glad_glGetString == NULL) return 0;
    if(glad_glGetString(GL_VERSION) == NULL) return 0;
    version = glad_gl_find_core_gl();

    glad_gl_load_GL_VERSION_1_0(load, userptr);
    glad_gl_load_GL_VERSION_1_1(load, userptr);
    glad_gl_load_GL_VERSION_1_2(load, userptr);
    glad_gl_load_GL_VERSION_1_3(load, userptr);
    glad_gl_load_GL_VERSION_1_4(load, userptr);
    glad_gl_load_GL_VERSION_1_5(load, userptr);
    glad_gl_load_GL_VERSION_2_0(load, userptr);
    glad_gl_load_GL_VERSION_2_1(load, userptr);
    glad_gl_load_GL_VERSION_3_0(load, userptr);
    glad_gl_load_GL_VERSION_3_1(load, userptr);
    glad_gl_load_GL_VERSION_3_2(load, userptr);
    glad_gl_load_GL_VERSION_3_3(load, userptr);
    glad_gl_load_GL_VERSION_4_0(load, userptr);
    glad_gl_load_GL_VERSION_4_1(load, userptr);
    glad_gl_load_GL_VERSION_4_2(load, userptr);
    glad_gl_load_GL_VERSION_4_3(load, userptr);
    glad_gl_load_GL_VERSION_4_4(load, userptr);
    glad_gl_load_GL_VERSION_4_5(load, userptr);
    glad_gl_load_GL_VERSION_4_6(load, userptr);

    if (!glad_gl_find_extensions_gl(version)) return 0;



    return version;
}


// Unable to find the docs for this function!
int gladLoadGL( GLADloadfunc load) {
    return gladLoadGLUserPtr( glad_gl_get_proc_from_userptr, GLAD_GNUC_EXTENSION (void*) load);
}



 

#ifdef GLAD_GL

#ifndef GLAD_LOADER_LIBRARY_C_
#define GLAD_LOADER_LIBRARY_C_

#include <stddef.h>
#include <stdlib.h>

#if GLAD_PLATFORM_WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif


static void* glad_get_dlopen_handle(const char *lib_names[], int length) {
    void *handle = NULL;
    int i;

    for (i = 0; i < length; ++i) {
#if GLAD_PLATFORM_WIN32
  #if GLAD_PLATFORM_UWP
        size_t buffer_size = (strlen(lib_names[i]) + 1) * sizeof(WCHAR);
        LPWSTR buffer = (LPWSTR) malloc(buffer_size);
        if (buffer != NULL) {
            int ret = MultiByteToWideChar(CP_ACP, 0, lib_names[i], -1, buffer, buffer_size);
            if (ret != 0) {
                handle = (void*) LoadPackagedLibrary(buffer, 0);
            }
            free((void*) buffer);
        }
  #else
        handle = (void*) LoadLibraryA(lib_names[i]);
  #endif
#else
        handle = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
#endif
        if (handle != NULL) {
            return handle;
        }
    }

    return NULL;
}

static void glad_close_dlopen_handle(void* handle) {
    if (handle != NULL) {
#if GLAD_PLATFORM_WIN32
        FreeLibrary((HMODULE) handle);
#else
        dlclose(handle);
#endif
    }
}

static GLADapiproc glad_dlsym_handle(void* handle, const char *name) {
    if (handle == NULL) {
        return NULL;
    }

#if GLAD_PLATFORM_WIN32
    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);
#else
    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);
#endif
}

#endif /* GLAD_LOADER_LIBRARY_C_ */

typedef void* (GLAD_API_PTR *GLADglprocaddrfunc)(const char*);
struct _glad_gl_userptr {
    void *handle;
    GLADglprocaddrfunc gl_get_proc_address_ptr;
};

static GLADapiproc glad_gl_get_proc(void *vuserptr, const char *name) {
    struct _glad_gl_userptr userptr = *(struct _glad_gl_userptr*) vuserptr;
    GLADapiproc result = NULL;

    if(userptr.gl_get_proc_address_ptr != NULL) {
        result = GLAD_GNUC_EXTENSION (GLADapiproc) userptr.gl_get_proc_address_ptr(name);
    }
    if(result == NULL) {
        result = glad_dlsym_handle(userptr.handle, name);
    }

    return result;
}

static void* _glad_GL_loader_handle = NULL;

static void* glad_gl_dlopen_handle(void) {
#if GLAD_PLATFORM_APPLE
    static const char *NAMES[] = {
        "../Frameworks/OpenGL.framework/OpenGL",
        "/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
    };
#elif GLAD_PLATFORM_WIN32
    static const char *NAMES[] = {"opengl32.dll"};
#else
    static const char *NAMES[] = {
  #if defined(__CYGWIN__)
        "libGL-1.so",
  #endif
        "libGL.so.1",
        "libGL.so"
    };
#endif

    if (_glad_GL_loader_handle == NULL) {
        _glad_GL_loader_handle = glad_get_dlopen_handle(NAMES, sizeof(NAMES) / sizeof(NAMES[0]));
    }

    return _glad_GL_loader_handle;
}

static struct _glad_gl_userptr glad_gl_build_userptr(void *handle) {
    struct _glad_gl_userptr userptr;

    userptr.handle = handle;
#if GLAD_PLATFORM_APPLE || defined(__HAIKU__)
    userptr.gl_get_proc_address_ptr = NULL;
#elif GLAD_PLATFORM_WIN32
    userptr.gl_get_proc_address_ptr =
        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "wglGetProcAddress");
#else
    userptr.gl_get_proc_address_ptr =
        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "glXGetProcAddressARB");
#endif

    return userptr;
}

// Unable to find the docs for this function!
int gladLoaderLoadGL(void) {
    int version = 0;
    void *handle;
    int did_load = 0;
    struct _glad_gl_userptr userptr;

    did_load = _glad_GL_loader_handle == NULL;
    handle = glad_gl_dlopen_handle();
    if (handle) {
        userptr = glad_gl_build_userptr(handle);

        version = gladLoadGLUserPtr(glad_gl_get_proc, &userptr);

        if (did_load) {
            gladLoaderUnloadGL();
        }
    }

    return version;
}



// Unable to find the docs for this function!
void gladLoaderUnloadGL(void) {
    if (_glad_GL_loader_handle != NULL) {
        glad_close_dlopen_handle(_glad_GL_loader_handle);
        _glad_GL_loader_handle = NULL;
    }
}

#endif /* GLAD_GL */

#ifdef __cplusplus
}
#endif

#endif /* GLAD_GL_IMPLEMENTATION */

