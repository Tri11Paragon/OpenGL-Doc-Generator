/**
 * Loader generated by glad 2.0.4 on Tue Nov 28 05:36:12 2023
 *
 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
 *
 * Generator: C/C++
 * Specification: gl
 * Extensions: 1
 *
 * APIs:
 *  - gl:core=4.6
 *
 * Options:
 *  - ALIAS = False
 *  - DEBUG = False
 *  - HEADER_ONLY = True
 *  - LOADER = True
 *  - MX = False
 *  - ON_DEMAND = False
 *
 * Commandline:
 *    --api='gl:core=4.6' --extensions='GL_EXT_texture_lod_bias' c --header-only --loader
 *
 * Online:
 *    http://glad.sh/#api=gl%3Acore%3D4.6&extensions=GL_EXT_texture_lod_bias&generator=c&options=HEADER_ONLY%2CLOADER
 *
 */

#ifndef GLAD_GL_H_
#define GLAD_GL_H_

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifdef __gl_h_
  #error OpenGL (gl.h) header already included (API: gl), remove previous include!
#endif
#define __gl_h_ 1
#ifdef __gl3_h_
  #error OpenGL (gl3.h) header already included (API: gl), remove previous include!
#endif
#define __gl3_h_ 1
#ifdef __glext_h_
  #error OpenGL (glext.h) header already included (API: gl), remove previous include!
#endif
#define __glext_h_ 1
#ifdef __gl3ext_h_
  #error OpenGL (gl3ext.h) header already included (API: gl), remove previous include!
#endif
#define __gl3ext_h_ 1
#ifdef __clang__
#pragma clang diagnostic pop
#endif

#define GLAD_GL
#define GLAD_OPTION_GL_HEADER_ONLY
#define GLAD_OPTION_GL_LOADER

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GLAD_PLATFORM_H_
#define GLAD_PLATFORM_H_

#ifndef GLAD_PLATFORM_WIN32
  #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__MINGW32__)
    #define GLAD_PLATFORM_WIN32 1
  #else
    #define GLAD_PLATFORM_WIN32 0
  #endif
#endif

#ifndef GLAD_PLATFORM_APPLE
  #ifdef __APPLE__
    #define GLAD_PLATFORM_APPLE 1
  #else
    #define GLAD_PLATFORM_APPLE 0
  #endif
#endif

#ifndef GLAD_PLATFORM_EMSCRIPTEN
  #ifdef __EMSCRIPTEN__
    #define GLAD_PLATFORM_EMSCRIPTEN 1
  #else
    #define GLAD_PLATFORM_EMSCRIPTEN 0
  #endif
#endif

#ifndef GLAD_PLATFORM_UWP
  #if defined(_MSC_VER) && !defined(GLAD_INTERNAL_HAVE_WINAPIFAMILY)
    #ifdef __has_include
      #if __has_include(<winapifamily.h>)
        #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
      #endif
    #elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
      #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
    #endif
  #endif

  #ifdef GLAD_INTERNAL_HAVE_WINAPIFAMILY
    #include <winapifamily.h>
    #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
      #define GLAD_PLATFORM_UWP 1
    #endif
  #endif

  #ifndef GLAD_PLATFORM_UWP
    #define GLAD_PLATFORM_UWP 0
  #endif
#endif

#ifdef __GNUC__
  #define GLAD_GNUC_EXTENSION __extension__
#else
  #define GLAD_GNUC_EXTENSION
#endif

#define GLAD_UNUSED(x) (void)(x)

#ifndef GLAD_API_CALL
  #if defined(GLAD_API_CALL_EXPORT)
    #if GLAD_PLATFORM_WIN32 || defined(__CYGWIN__)
      #if defined(GLAD_API_CALL_EXPORT_BUILD)
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllexport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllexport) extern
        #endif
      #else
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllimport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllimport) extern
        #endif
      #endif
    #elif defined(__GNUC__) && defined(GLAD_API_CALL_EXPORT_BUILD)
      #define GLAD_API_CALL __attribute__ ((visibility ("default"))) extern
    #else
      #define GLAD_API_CALL extern
    #endif
  #else
    #define GLAD_API_CALL extern
  #endif
#endif

#ifdef APIENTRY
  #define GLAD_API_PTR APIENTRY
#elif GLAD_PLATFORM_WIN32
  #define GLAD_API_PTR __stdcall
#else
  #define GLAD_API_PTR
#endif

#ifndef GLAPI
#define GLAPI GLAD_API_CALL
#endif

#ifndef GLAPIENTRY
#define GLAPIENTRY GLAD_API_PTR
#endif

#define GLAD_MAKE_VERSION(major, minor) (major * 10000 + minor)
#define GLAD_VERSION_MAJOR(version) (version / 10000)
#define GLAD_VERSION_MINOR(version) (version % 10000)

#define GLAD_GENERATOR_VERSION "2.0.4"

typedef void (*GLADapiproc)(void);

typedef GLADapiproc (*GLADloadfunc)(const char *name);
typedef GLADapiproc (*GLADuserptrloadfunc)(void *userptr, const char *name);

typedef void (*GLADprecallback)(const char *name, GLADapiproc apiproc, int len_args, ...);
typedef void (*GLADpostcallback)(void *ret, const char *name, GLADapiproc apiproc, int len_args, ...);

#endif /* GLAD_PLATFORM_H_ */

#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS 0x92D9
#define GL_ACTIVE_ATTRIBUTES 0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_PROGRAM 0x8259
#define GL_ACTIVE_RESOURCES 0x92F5
#define GL_ACTIVE_SUBROUTINES 0x8DE5
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH 0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORMS 0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_ACTIVE_TEXTURE 0x84E0
#define GL_ACTIVE_UNIFORMS 0x8B86
#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
#define GL_ACTIVE_VARIABLES 0x9305
#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
#define GL_ALL_BARRIER_BITS 0xFFFFFFFF
#define GL_ALL_SHADER_BITS 0xFFFFFFFF
#define GL_ALPHA 0x1906
#define GL_ALREADY_SIGNALED 0x911A
#define GL_ALWAYS 0x0207
#define GL_AND 0x1501
#define GL_AND_INVERTED 0x1504
#define GL_AND_REVERSE 0x1502
#define GL_ANY_SAMPLES_PASSED 0x8C2F
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_ARRAY_BUFFER 0x8892
#define GL_ARRAY_BUFFER_BINDING 0x8894
#define GL_ARRAY_SIZE 0x92FB
#define GL_ARRAY_STRIDE 0x92FE
#define GL_ATOMIC_COUNTER_BARRIER_BIT 0x00001000
#define GL_ATOMIC_COUNTER_BUFFER 0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS 0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES 0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_BINDING 0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE 0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_INDEX 0x9301
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER 0x92CB
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER 0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER 0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER 0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_SIZE 0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_START 0x92C2
#define GL_ATTACHED_SHADERS 0x8B85
#define GL_AUTO_GENERATE_MIPMAP 0x8295
#define GL_BACK 0x0405
#define GL_BACK_LEFT 0x0402
#define GL_BACK_RIGHT 0x0403
#define GL_BGR 0x80E0
#define GL_BGRA 0x80E1
#define GL_BGRA_INTEGER 0x8D9B
#define GL_BGR_INTEGER 0x8D9A
#define GL_BLEND 0x0BE2
#define GL_BLEND_COLOR 0x8005
#define GL_BLEND_DST 0x0BE0
#define GL_BLEND_DST_ALPHA 0x80CA
#define GL_BLEND_DST_RGB 0x80C8
#define GL_BLEND_EQUATION 0x8009
#define GL_BLEND_EQUATION_ALPHA 0x883D
#define GL_BLEND_EQUATION_RGB 0x8009
#define GL_BLEND_SRC 0x0BE1
#define GL_BLEND_SRC_ALPHA 0x80CB
#define GL_BLEND_SRC_RGB 0x80C9
#define GL_BLOCK_INDEX 0x92FD
#define GL_BLUE 0x1905
#define GL_BLUE_INTEGER 0x8D96
#define GL_BOOL 0x8B56
#define GL_BOOL_VEC2 0x8B57
#define GL_BOOL_VEC3 0x8B58
#define GL_BOOL_VEC4 0x8B59
#define GL_BUFFER 0x82E0
#define GL_BUFFER_ACCESS 0x88BB
#define GL_BUFFER_ACCESS_FLAGS 0x911F
#define GL_BUFFER_BINDING 0x9302
#define GL_BUFFER_DATA_SIZE 0x9303
#define GL_BUFFER_IMMUTABLE_STORAGE 0x821F
#define GL_BUFFER_MAPPED 0x88BC
#define GL_BUFFER_MAP_LENGTH 0x9120
#define GL_BUFFER_MAP_OFFSET 0x9121
#define GL_BUFFER_MAP_POINTER 0x88BD
#define GL_BUFFER_SIZE 0x8764
#define GL_BUFFER_STORAGE_FLAGS 0x8220
#define GL_BUFFER_UPDATE_BARRIER_BIT 0x00000200
#define GL_BUFFER_USAGE 0x8765
#define GL_BUFFER_VARIABLE 0x92E5
#define GL_BYTE 0x1400
#define GL_CAVEAT_SUPPORT 0x82B8
#define GL_CCW 0x0901
#define GL_CLAMP_READ_COLOR 0x891C
#define GL_CLAMP_TO_BORDER 0x812D
#define GL_CLAMP_TO_EDGE 0x812F
#define GL_CLEAR 0x1500
#define GL_CLEAR_BUFFER 0x82B4
#define GL_CLEAR_TEXTURE 0x9365
#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT 0x00004000
#define GL_CLIENT_STORAGE_BIT 0x0200
#define GL_CLIPPING_INPUT_PRIMITIVES 0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES 0x82F7
#define GL_CLIP_DEPTH_MODE 0x935D
#define GL_CLIP_DISTANCE0 0x3000
#define GL_CLIP_DISTANCE1 0x3001
#define GL_CLIP_DISTANCE2 0x3002
#define GL_CLIP_DISTANCE3 0x3003
#define GL_CLIP_DISTANCE4 0x3004
#define GL_CLIP_DISTANCE5 0x3005
#define GL_CLIP_DISTANCE6 0x3006
#define GL_CLIP_DISTANCE7 0x3007
#define GL_CLIP_ORIGIN 0x935C
#define GL_COLOR 0x1800
#define GL_COLOR_ATTACHMENT0 0x8CE0
#define GL_COLOR_ATTACHMENT1 0x8CE1
#define GL_COLOR_ATTACHMENT10 0x8CEA
#define GL_COLOR_ATTACHMENT11 0x8CEB
#define GL_COLOR_ATTACHMENT12 0x8CEC
#define GL_COLOR_ATTACHMENT13 0x8CED
#define GL_COLOR_ATTACHMENT14 0x8CEE
#define GL_COLOR_ATTACHMENT15 0x8CEF
#define GL_COLOR_ATTACHMENT16 0x8CF0
#define GL_COLOR_ATTACHMENT17 0x8CF1
#define GL_COLOR_ATTACHMENT18 0x8CF2
#define GL_COLOR_ATTACHMENT19 0x8CF3
#define GL_COLOR_ATTACHMENT2 0x8CE2
#define GL_COLOR_ATTACHMENT20 0x8CF4
#define GL_COLOR_ATTACHMENT21 0x8CF5
#define GL_COLOR_ATTACHMENT22 0x8CF6
#define GL_COLOR_ATTACHMENT23 0x8CF7
#define GL_COLOR_ATTACHMENT24 0x8CF8
#define GL_COLOR_ATTACHMENT25 0x8CF9
#define GL_COLOR_ATTACHMENT26 0x8CFA
#define GL_COLOR_ATTACHMENT27 0x8CFB
#define GL_COLOR_ATTACHMENT28 0x8CFC
#define GL_COLOR_ATTACHMENT29 0x8CFD
#define GL_COLOR_ATTACHMENT3 0x8CE3
#define GL_COLOR_ATTACHMENT30 0x8CFE
#define GL_COLOR_ATTACHMENT31 0x8CFF
#define GL_COLOR_ATTACHMENT4 0x8CE4
#define GL_COLOR_ATTACHMENT5 0x8CE5
#define GL_COLOR_ATTACHMENT6 0x8CE6
#define GL_COLOR_ATTACHMENT7 0x8CE7
#define GL_COLOR_ATTACHMENT8 0x8CE8
#define GL_COLOR_ATTACHMENT9 0x8CE9
#define GL_COLOR_BUFFER_BIT 0x00004000
#define GL_COLOR_CLEAR_VALUE 0x0C22
#define GL_COLOR_COMPONENTS 0x8283
#define GL_COLOR_ENCODING 0x8296
#define GL_COLOR_LOGIC_OP 0x0BF2
#define GL_COLOR_RENDERABLE 0x8286
#define GL_COLOR_WRITEMASK 0x0C23
#define GL_COMMAND_BARRIER_BIT 0x00000040
#define GL_COMPARE_REF_TO_TEXTURE 0x884E
#define GL_COMPATIBLE_SUBROUTINES 0x8E4B
#define GL_COMPILE_STATUS 0x8B81
#define GL_COMPRESSED_R11_EAC 0x9270
#define GL_COMPRESSED_RED 0x8225
#define GL_COMPRESSED_RED_RGTC1 0x8DBB
#define GL_COMPRESSED_RG 0x8226
#define GL_COMPRESSED_RG11_EAC 0x9272
#define GL_COMPRESSED_RGB 0x84ED
#define GL_COMPRESSED_RGB8_ETC2 0x9274
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_RGBA 0x84EE
#define GL_COMPRESSED_RGBA8_ETC2_EAC 0x9278
#define GL_COMPRESSED_RGBA_BPTC_UNORM 0x8E8C
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT 0x8E8F
#define GL_COMPRESSED_RG_RGTC2 0x8DBD
#define GL_COMPRESSED_SIGNED_R11_EAC 0x9271
#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
#define GL_COMPRESSED_SIGNED_RG11_EAC 0x9273
#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
#define GL_COMPRESSED_SRGB 0x8C48
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_COMPRESSED_SRGB8_ETC2 0x9275
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM 0x8E8D
#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
#define GL_COMPUTE_SHADER 0x91B9
#define GL_COMPUTE_SHADER_BIT 0x00000020
#define GL_COMPUTE_SHADER_INVOCATIONS 0x82F5
#define GL_COMPUTE_SUBROUTINE 0x92ED
#define GL_COMPUTE_SUBROUTINE_UNIFORM 0x92F3
#define GL_COMPUTE_TEXTURE 0x82A0
#define GL_COMPUTE_WORK_GROUP_SIZE 0x8267
#define GL_CONDITION_SATISFIED 0x911C
#define GL_CONSTANT_ALPHA 0x8003
#define GL_CONSTANT_COLOR 0x8001
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
#define GL_CONTEXT_FLAGS 0x821E
#define GL_CONTEXT_FLAG_DEBUG_BIT 0x00000002
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
#define GL_CONTEXT_FLAG_NO_ERROR_BIT 0x00000008
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT 0x00000004
#define GL_CONTEXT_LOST 0x0507
#define GL_CONTEXT_PROFILE_MASK 0x9126
#define GL_CONTEXT_RELEASE_BEHAVIOR 0x82FB
#define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH 0x82FC
#define GL_COPY 0x1503
#define GL_COPY_INVERTED 0x150C
#define GL_COPY_READ_BUFFER 0x8F36
#define GL_COPY_READ_BUFFER_BINDING 0x8F36
#define GL_COPY_WRITE_BUFFER 0x8F37
#define GL_COPY_WRITE_BUFFER_BINDING 0x8F37
#define GL_CULL_FACE 0x0B44
#define GL_CULL_FACE_MODE 0x0B45
#define GL_CURRENT_PROGRAM 0x8B8D
#define GL_CURRENT_QUERY 0x8865
#define GL_CURRENT_VERTEX_ATTRIB 0x8626
#define GL_CW 0x0900
#define GL_DEBUG_CALLBACK_FUNCTION 0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM 0x8245
#define GL_DEBUG_GROUP_STACK_DEPTH 0x826D
#define GL_DEBUG_LOGGED_MESSAGES 0x9145
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH 0x8243
#define GL_DEBUG_OUTPUT 0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS 0x8242
#define GL_DEBUG_SEVERITY_HIGH 0x9146
#define GL_DEBUG_SEVERITY_LOW 0x9148
#define GL_DEBUG_SEVERITY_MEDIUM 0x9147
#define GL_DEBUG_SEVERITY_NOTIFICATION 0x826B
#define GL_DEBUG_SOURCE_API 0x8246
#define GL_DEBUG_SOURCE_APPLICATION 0x824A
#define GL_DEBUG_SOURCE_OTHER 0x824B
#define GL_DEBUG_SOURCE_SHADER_COMPILER 0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY 0x8249
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM 0x8247
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR 0x824D
#define GL_DEBUG_TYPE_ERROR 0x824C
#define GL_DEBUG_TYPE_MARKER 0x8268
#define GL_DEBUG_TYPE_OTHER 0x8251
#define GL_DEBUG_TYPE_PERFORMANCE 0x8250
#define GL_DEBUG_TYPE_POP_GROUP 0x826A
#define GL_DEBUG_TYPE_PORTABILITY 0x824F
#define GL_DEBUG_TYPE_PUSH_GROUP 0x8269
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR 0x824E
#define GL_DECR 0x1E03
#define GL_DECR_WRAP 0x8508
#define GL_DELETE_STATUS 0x8B80
#define GL_DEPTH 0x1801
#define GL_DEPTH24_STENCIL8 0x88F0
#define GL_DEPTH32F_STENCIL8 0x8CAD
#define GL_DEPTH_ATTACHMENT 0x8D00
#define GL_DEPTH_BUFFER_BIT 0x00000100
#define GL_DEPTH_CLAMP 0x864F
#define GL_DEPTH_CLEAR_VALUE 0x0B73
#define GL_DEPTH_COMPONENT 0x1902
#define GL_DEPTH_COMPONENT16 0x81A5
#define GL_DEPTH_COMPONENT24 0x81A6
#define GL_DEPTH_COMPONENT32 0x81A7
#define GL_DEPTH_COMPONENT32F 0x8CAC
#define GL_DEPTH_COMPONENTS 0x8284
#define GL_DEPTH_FUNC 0x0B74
#define GL_DEPTH_RANGE 0x0B70
#define GL_DEPTH_RENDERABLE 0x8287
#define GL_DEPTH_STENCIL 0x84F9
#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
#define GL_DEPTH_STENCIL_TEXTURE_MODE 0x90EA
#define GL_DEPTH_TEST 0x0B71
#define GL_DEPTH_WRITEMASK 0x0B72
#define GL_DISPATCH_INDIRECT_BUFFER 0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING 0x90EF
#define GL_DITHER 0x0BD0
#define GL_DONT_CARE 0x1100
#define GL_DOUBLE 0x140A
#define GL_DOUBLEBUFFER 0x0C32
#define GL_DOUBLE_MAT2 0x8F46
#define GL_DOUBLE_MAT2x3 0x8F49
#define GL_DOUBLE_MAT2x4 0x8F4A
#define GL_DOUBLE_MAT3 0x8F47
#define GL_DOUBLE_MAT3x2 0x8F4B
#define GL_DOUBLE_MAT3x4 0x8F4C
#define GL_DOUBLE_MAT4 0x8F48
#define GL_DOUBLE_MAT4x2 0x8F4D
#define GL_DOUBLE_MAT4x3 0x8F4E
#define GL_DOUBLE_VEC2 0x8FFC
#define GL_DOUBLE_VEC3 0x8FFD
#define GL_DOUBLE_VEC4 0x8FFE
#define GL_DRAW_BUFFER 0x0C01
#define GL_DRAW_BUFFER0 0x8825
#define GL_DRAW_BUFFER1 0x8826
#define GL_DRAW_BUFFER10 0x882F
#define GL_DRAW_BUFFER11 0x8830
#define GL_DRAW_BUFFER12 0x8831
#define GL_DRAW_BUFFER13 0x8832
#define GL_DRAW_BUFFER14 0x8833
#define GL_DRAW_BUFFER15 0x8834
#define GL_DRAW_BUFFER2 0x8827
#define GL_DRAW_BUFFER3 0x8828
#define GL_DRAW_BUFFER4 0x8829
#define GL_DRAW_BUFFER5 0x882A
#define GL_DRAW_BUFFER6 0x882B
#define GL_DRAW_BUFFER7 0x882C
#define GL_DRAW_BUFFER8 0x882D
#define GL_DRAW_BUFFER9 0x882E
#define GL_DRAW_FRAMEBUFFER 0x8CA9
#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
#define GL_DRAW_INDIRECT_BUFFER 0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING 0x8F43
#define GL_DST_ALPHA 0x0304
#define GL_DST_COLOR 0x0306
#define GL_DYNAMIC_COPY 0x88EA
#define GL_DYNAMIC_DRAW 0x88E8
#define GL_DYNAMIC_READ 0x88E9
#define GL_DYNAMIC_STORAGE_BIT 0x0100
#define GL_ELEMENT_ARRAY_BARRIER_BIT 0x00000002
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
#define GL_EQUAL 0x0202
#define GL_EQUIV 0x1509
#define GL_EXTENSIONS 0x1F03
#define GL_FALSE 0
#define GL_FASTEST 0x1101
#define GL_FILL 0x1B02
#define GL_FILTER 0x829A
#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
#define GL_FIXED 0x140C
#define GL_FIXED_ONLY 0x891D
#define GL_FLOAT 0x1406
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT2x3 0x8B65
#define GL_FLOAT_MAT2x4 0x8B66
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT3x2 0x8B67
#define GL_FLOAT_MAT3x4 0x8B68
#define GL_FLOAT_MAT4 0x8B5C
#define GL_FLOAT_MAT4x2 0x8B69
#define GL_FLOAT_MAT4x3 0x8B6A
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FRACTIONAL_EVEN 0x8E7C
#define GL_FRACTIONAL_ODD 0x8E7B
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
#define GL_FRAGMENT_SHADER 0x8B30
#define GL_FRAGMENT_SHADER_BIT 0x00000002
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_FRAGMENT_SHADER_INVOCATIONS 0x82F4
#define GL_FRAGMENT_SUBROUTINE 0x92EC
#define GL_FRAGMENT_SUBROUTINE_UNIFORM 0x92F2
#define GL_FRAGMENT_TEXTURE 0x829F
#define GL_FRAMEBUFFER 0x8D40
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_BARRIER_BIT 0x00000400
#define GL_FRAMEBUFFER_BINDING 0x8CA6
#define GL_FRAMEBUFFER_BLEND 0x828B
#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
#define GL_FRAMEBUFFER_DEFAULT 0x8218
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS 0x9314
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT 0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS 0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES 0x9313
#define GL_FRAMEBUFFER_DEFAULT_WIDTH 0x9310
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_RENDERABLE 0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED 0x828A
#define GL_FRAMEBUFFER_SRGB 0x8DB9
#define GL_FRAMEBUFFER_UNDEFINED 0x8219
#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
#define GL_FRONT 0x0404
#define GL_FRONT_AND_BACK 0x0408
#define GL_FRONT_FACE 0x0B46
#define GL_FRONT_LEFT 0x0400
#define GL_FRONT_RIGHT 0x0401
#define GL_FULL_SUPPORT 0x82B7
#define GL_FUNC_ADD 0x8006
#define GL_FUNC_REVERSE_SUBTRACT 0x800B
#define GL_FUNC_SUBTRACT 0x800A
#define GL_GEOMETRY_INPUT_TYPE 0x8917
#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
#define GL_GEOMETRY_SHADER 0x8DD9
#define GL_GEOMETRY_SHADER_BIT 0x00000004
#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED 0x82F3
#define GL_GEOMETRY_SUBROUTINE 0x92EB
#define GL_GEOMETRY_SUBROUTINE_UNIFORM 0x92F1
#define GL_GEOMETRY_TEXTURE 0x829E
#define GL_GEOMETRY_VERTICES_OUT 0x8916
#define GL_GEQUAL 0x0206
#define GL_GET_TEXTURE_IMAGE_FORMAT 0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE 0x8292
#define GL_GREATER 0x0204
#define GL_GREEN 0x1904
#define GL_GREEN_INTEGER 0x8D95
#define GL_GUILTY_CONTEXT_RESET 0x8253
#define GL_HALF_FLOAT 0x140B
#define GL_HIGH_FLOAT 0x8DF2
#define GL_HIGH_INT 0x8DF5
#define GL_IMAGE_1D 0x904C
#define GL_IMAGE_1D_ARRAY 0x9052
#define GL_IMAGE_2D 0x904D
#define GL_IMAGE_2D_ARRAY 0x9053
#define GL_IMAGE_2D_MULTISAMPLE 0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY 0x9056
#define GL_IMAGE_2D_RECT 0x904F
#define GL_IMAGE_3D 0x904E
#define GL_IMAGE_BINDING_ACCESS 0x8F3E
#define GL_IMAGE_BINDING_FORMAT 0x906E
#define GL_IMAGE_BINDING_LAYER 0x8F3D
#define GL_IMAGE_BINDING_LAYERED 0x8F3C
#define GL_IMAGE_BINDING_LEVEL 0x8F3B
#define GL_IMAGE_BINDING_NAME 0x8F3A
#define GL_IMAGE_BUFFER 0x9051
#define GL_IMAGE_CLASS_10_10_10_2 0x82C3
#define GL_IMAGE_CLASS_11_11_10 0x82C2
#define GL_IMAGE_CLASS_1_X_16 0x82BE
#define GL_IMAGE_CLASS_1_X_32 0x82BB
#define GL_IMAGE_CLASS_1_X_8 0x82C1
#define GL_IMAGE_CLASS_2_X_16 0x82BD
#define GL_IMAGE_CLASS_2_X_32 0x82BA
#define GL_IMAGE_CLASS_2_X_8 0x82C0
#define GL_IMAGE_CLASS_4_X_16 0x82BC
#define GL_IMAGE_CLASS_4_X_32 0x82B9
#define GL_IMAGE_CLASS_4_X_8 0x82BF
#define GL_IMAGE_COMPATIBILITY_CLASS 0x82A8
#define GL_IMAGE_CUBE 0x9050
#define GL_IMAGE_CUBE_MAP_ARRAY 0x9054
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS 0x90C9
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE 0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE 0x90C7
#define GL_IMAGE_PIXEL_FORMAT 0x82A9
#define GL_IMAGE_PIXEL_TYPE 0x82AA
#define GL_IMAGE_TEXEL_SIZE 0x82A7
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_INCR 0x1E02
#define GL_INCR_WRAP 0x8507
#define GL_INFO_LOG_LENGTH 0x8B84
#define GL_INNOCENT_CONTEXT_RESET 0x8254
#define GL_INT 0x1404
#define GL_INTERLEAVED_ATTRIBS 0x8C8C
#define GL_INTERNALFORMAT_ALPHA_SIZE 0x8274
#define GL_INTERNALFORMAT_ALPHA_TYPE 0x827B
#define GL_INTERNALFORMAT_BLUE_SIZE 0x8273
#define GL_INTERNALFORMAT_BLUE_TYPE 0x827A
#define GL_INTERNALFORMAT_DEPTH_SIZE 0x8275
#define GL_INTERNALFORMAT_DEPTH_TYPE 0x827C
#define GL_INTERNALFORMAT_GREEN_SIZE 0x8272
#define GL_INTERNALFORMAT_GREEN_TYPE 0x8279
#define GL_INTERNALFORMAT_PREFERRED 0x8270
#define GL_INTERNALFORMAT_RED_SIZE 0x8271
#define GL_INTERNALFORMAT_RED_TYPE 0x8278
#define GL_INTERNALFORMAT_SHARED_SIZE 0x8277
#define GL_INTERNALFORMAT_STENCIL_SIZE 0x8276
#define GL_INTERNALFORMAT_STENCIL_TYPE 0x827D
#define GL_INTERNALFORMAT_SUPPORTED 0x826F
#define GL_INT_2_10_10_10_REV 0x8D9F
#define GL_INT_IMAGE_1D 0x9057
#define GL_INT_IMAGE_1D_ARRAY 0x905D
#define GL_INT_IMAGE_2D 0x9058
#define GL_INT_IMAGE_2D_ARRAY 0x905E
#define GL_INT_IMAGE_2D_MULTISAMPLE 0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x9061
#define GL_INT_IMAGE_2D_RECT 0x905A
#define GL_INT_IMAGE_3D 0x9059
#define GL_INT_IMAGE_BUFFER 0x905C
#define GL_INT_IMAGE_CUBE 0x905B
#define GL_INT_IMAGE_CUBE_MAP_ARRAY 0x905F
#define GL_INT_SAMPLER_1D 0x8DC9
#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
#define GL_INT_SAMPLER_2D 0x8DCA
#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_INT_SAMPLER_2D_RECT 0x8DCD
#define GL_INT_SAMPLER_3D 0x8DCB
#define GL_INT_SAMPLER_BUFFER 0x8DD0
#define GL_INT_SAMPLER_CUBE 0x8DCC
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY 0x900E
#define GL_INT_VEC2 0x8B53
#define GL_INT_VEC3 0x8B54
#define GL_INT_VEC4 0x8B55
#define GL_INVALID_ENUM 0x0500
#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
#define GL_INVALID_INDEX 0xFFFFFFFF
#define GL_INVALID_OPERATION 0x0502
#define GL_INVALID_VALUE 0x0501
#define GL_INVERT 0x150A
#define GL_ISOLINES 0x8E7A
#define GL_IS_PER_PATCH 0x92E7
#define GL_IS_ROW_MAJOR 0x9300
#define GL_KEEP 0x1E00
#define GL_LAST_VERTEX_CONVENTION 0x8E4E
#define GL_LAYER_PROVOKING_VERTEX 0x825E
#define GL_LEFT 0x0406
#define GL_LEQUAL 0x0203
#define GL_LESS 0x0201
#define GL_LINE 0x1B01
#define GL_LINEAR 0x2601
#define GL_LINEAR_MIPMAP_LINEAR 0x2703
#define GL_LINEAR_MIPMAP_NEAREST 0x2701
#define GL_LINES 0x0001
#define GL_LINES_ADJACENCY 0x000A
#define GL_LINE_LOOP 0x0002
#define GL_LINE_SMOOTH 0x0B20
#define GL_LINE_SMOOTH_HINT 0x0C52
#define GL_LINE_STRIP 0x0003
#define GL_LINE_STRIP_ADJACENCY 0x000B
#define GL_LINE_WIDTH 0x0B21
#define GL_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_LINE_WIDTH_RANGE 0x0B22
#define GL_LINK_STATUS 0x8B82
#define GL_LOCATION 0x930E
#define GL_LOCATION_COMPONENT 0x934A
#define GL_LOCATION_INDEX 0x930F
#define GL_LOGIC_OP_MODE 0x0BF0
#define GL_LOSE_CONTEXT_ON_RESET 0x8252
#define GL_LOWER_LEFT 0x8CA1
#define GL_LOW_FLOAT 0x8DF0
#define GL_LOW_INT 0x8DF3
#define GL_MAJOR_VERSION 0x821B
#define GL_MANUAL_GENERATE_MIPMAP 0x8294
#define GL_MAP_COHERENT_BIT 0x0080
#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
#define GL_MAP_PERSISTENT_BIT 0x0040
#define GL_MAP_READ_BIT 0x0001
#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
#define GL_MAP_WRITE_BIT 0x0002
#define GL_MATRIX_STRIDE 0x92FF
#define GL_MAX 0x8008
#define GL_MAX_3D_TEXTURE_SIZE 0x8073
#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 0x92DC
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE 0x92D8
#define GL_MAX_CLIP_DISTANCES 0x0D32
#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
#define GL_MAX_COMBINED_ATOMIC_COUNTERS 0x92D7
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 0x92D1
#define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES 0x82FA
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
#define GL_MAX_COMBINED_DIMENSIONS 0x8282
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_IMAGE_UNIFORMS 0x90CF
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS 0x8F39
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES 0x8F39
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS 0x90DC
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS 0x8265
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS 0x91BD
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS 0x90DB
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE 0x8262
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS 0x91BC
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS 0x91BB
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS 0x8263
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT 0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS 0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE 0x91BF
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
#define GL_MAX_CULL_DISTANCES 0x82F9
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH 0x826C
#define GL_MAX_DEBUG_LOGGED_MESSAGES 0x9144
#define GL_MAX_DEBUG_MESSAGE_LENGTH 0x9143
#define GL_MAX_DEPTH 0x8280
#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
#define GL_MAX_DRAW_BUFFERS 0x8824
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
#define GL_MAX_ELEMENTS_INDICES 0x80E9
#define GL_MAX_ELEMENTS_VERTICES 0x80E8
#define GL_MAX_ELEMENT_INDEX 0x8D6B
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS 0x92D6
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 0x92D0
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS 0x90CE
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 0x90DA
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS 0x8DFD
#define GL_MAX_FRAMEBUFFER_HEIGHT 0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS 0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES 0x9318
#define GL_MAX_FRAMEBUFFER_WIDTH 0x9315
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS 0x92D5
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0x92CF
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS 0x90CD
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0x90D7
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS 0x8A2C
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_HEIGHT 0x827F
#define GL_MAX_IMAGE_SAMPLES 0x906D
#define GL_MAX_IMAGE_UNITS 0x8F38
#define GL_MAX_INTEGER_SAMPLES 0x9110
#define GL_MAX_LABEL_LENGTH 0x82E8
#define GL_MAX_LAYERS 0x8281
#define GL_MAX_NAME_LENGTH 0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES 0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES 0x92F8
#define GL_MAX_PATCH_VERTICES 0x8E7D
#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
#define GL_MAX_SAMPLES 0x8D57
#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE 0x90DE
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS 0x90DD
#define GL_MAX_SUBROUTINES 0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS 0x92D3
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0x92CD
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS 0x90CB
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0x90D8
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0x92D4
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0x92CE
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0x90CC
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0x90D9
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_GEN_LEVEL 0x8E7E
#define GL_MAX_TESS_PATCH_COMPONENTS 0x8E84
#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
#define GL_MAX_TEXTURE_LOD_BIAS_EXT 0x84FD
#define GL_MAX_TEXTURE_MAX_ANISOTROPY 0x84FF
#define GL_MAX_TEXTURE_SIZE 0x0D33
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
#define GL_MAX_UNIFORM_LOCATIONS 0x826E
#define GL_MAX_VARYING_COMPONENTS 0x8B4B
#define GL_MAX_VARYING_FLOATS 0x8B4B
#define GL_MAX_VARYING_VECTORS 0x8DFC
#define GL_MAX_VERTEX_ATOMIC_COUNTERS 0x92D2
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0x92CC
#define GL_MAX_VERTEX_ATTRIBS 0x8869
#define GL_MAX_VERTEX_ATTRIB_BINDINGS 0x82DA
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D9
#define GL_MAX_VERTEX_ATTRIB_STRIDE 0x82E5
#define GL_MAX_VERTEX_IMAGE_UNIFORMS 0x90CA
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS 0x90D6
#define GL_MAX_VERTEX_STREAMS 0x8E71
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
#define GL_MAX_VERTEX_UNIFORM_VECTORS 0x8DFB
#define GL_MAX_VIEWPORTS 0x825B
#define GL_MAX_VIEWPORT_DIMS 0x0D3A
#define GL_MAX_WIDTH 0x827E
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_MEDIUM_INT 0x8DF4
#define GL_MIN 0x8007
#define GL_MINOR_VERSION 0x821C
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MIN_MAP_BUFFER_ALIGNMENT 0x90BC
#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MIN_SAMPLE_SHADING_VALUE 0x8C37
#define GL_MIPMAP 0x8293
#define GL_MIRRORED_REPEAT 0x8370
#define GL_MIRROR_CLAMP_TO_EDGE 0x8743
#define GL_MULTISAMPLE 0x809D
#define GL_NAME_LENGTH 0x92F9
#define GL_NAND 0x150E
#define GL_NEAREST 0x2600
#define GL_NEAREST_MIPMAP_LINEAR 0x2702
#define GL_NEAREST_MIPMAP_NEAREST 0x2700
#define GL_NEGATIVE_ONE_TO_ONE 0x935E
#define GL_NEVER 0x0200
#define GL_NICEST 0x1102
#define GL_NONE 0
#define GL_NOOP 0x1505
#define GL_NOR 0x1508
#define GL_NOTEQUAL 0x0205
#define GL_NO_ERROR 0
#define GL_NO_RESET_NOTIFICATION 0x8261
#define GL_NUM_ACTIVE_VARIABLES 0x9304
#define GL_NUM_COMPATIBLE_SUBROUTINES 0x8E4A
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_NUM_EXTENSIONS 0x821D
#define GL_NUM_PROGRAM_BINARY_FORMATS 0x87FE
#define GL_NUM_SAMPLE_COUNTS 0x9380
#define GL_NUM_SHADER_BINARY_FORMATS 0x8DF9
#define GL_NUM_SHADING_LANGUAGE_VERSIONS 0x82E9
#define GL_NUM_SPIR_V_EXTENSIONS 0x9554
#define GL_OBJECT_TYPE 0x9112
#define GL_OFFSET 0x92FC
#define GL_ONE 1
#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
#define GL_ONE_MINUS_DST_ALPHA 0x0305
#define GL_ONE_MINUS_DST_COLOR 0x0307
#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
#define GL_ONE_MINUS_SRC_ALPHA 0x0303
#define GL_ONE_MINUS_SRC_COLOR 0x0301
#define GL_OR 0x1507
#define GL_OR_INVERTED 0x150D
#define GL_OR_REVERSE 0x150B
#define GL_OUT_OF_MEMORY 0x0505
#define GL_PACK_ALIGNMENT 0x0D05
#define GL_PACK_COMPRESSED_BLOCK_DEPTH 0x912D
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT 0x912C
#define GL_PACK_COMPRESSED_BLOCK_SIZE 0x912E
#define GL_PACK_COMPRESSED_BLOCK_WIDTH 0x912B
#define GL_PACK_IMAGE_HEIGHT 0x806C
#define GL_PACK_LSB_FIRST 0x0D01
#define GL_PACK_ROW_LENGTH 0x0D02
#define GL_PACK_SKIP_IMAGES 0x806B
#define GL_PACK_SKIP_PIXELS 0x0D04
#define GL_PACK_SKIP_ROWS 0x0D03
#define GL_PACK_SWAP_BYTES 0x0D00
#define GL_PARAMETER_BUFFER 0x80EE
#define GL_PARAMETER_BUFFER_BINDING 0x80EF
#define GL_PATCHES 0x000E
#define GL_PATCH_DEFAULT_INNER_LEVEL 0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL 0x8E74
#define GL_PATCH_VERTICES 0x8E72
#define GL_PIXEL_BUFFER_BARRIER_BIT 0x00000080
#define GL_PIXEL_PACK_BUFFER 0x88EB
#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
#define GL_PIXEL_UNPACK_BUFFER 0x88EC
#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
#define GL_POINT 0x1B00
#define GL_POINTS 0x0000
#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
#define GL_POINT_SIZE 0x0B11
#define GL_POINT_SIZE_GRANULARITY 0x0B13
#define GL_POINT_SIZE_RANGE 0x0B12
#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
#define GL_POLYGON_MODE 0x0B40
#define GL_POLYGON_OFFSET_CLAMP 0x8E1B
#define GL_POLYGON_OFFSET_FACTOR 0x8038
#define GL_POLYGON_OFFSET_FILL 0x8037
#define GL_POLYGON_OFFSET_LINE 0x2A02
#define GL_POLYGON_OFFSET_POINT 0x2A01
#define GL_POLYGON_OFFSET_UNITS 0x2A00
#define GL_POLYGON_SMOOTH 0x0B41
#define GL_POLYGON_SMOOTH_HINT 0x0C53
#define GL_PRIMITIVES_GENERATED 0x8C87
#define GL_PRIMITIVES_SUBMITTED 0x82EF
#define GL_PRIMITIVE_RESTART 0x8F9D
#define GL_PRIMITIVE_RESTART_FIXED_INDEX 0x8D69
#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
#define GL_PROGRAM 0x82E2
#define GL_PROGRAM_BINARY_FORMATS 0x87FF
#define GL_PROGRAM_BINARY_LENGTH 0x8741
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_INPUT 0x92E3
#define GL_PROGRAM_OUTPUT 0x92E4
#define GL_PROGRAM_PIPELINE 0x82E4
#define GL_PROGRAM_PIPELINE_BINDING 0x825A
#define GL_PROGRAM_POINT_SIZE 0x8642
#define GL_PROGRAM_SEPARABLE 0x8258
#define GL_PROVOKING_VERTEX 0x8E4F
#define GL_PROXY_TEXTURE_1D 0x8063
#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
#define GL_PROXY_TEXTURE_2D 0x8064
#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_PROXY_TEXTURE_3D 0x8070
#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY 0x900B
#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
#define GL_QUADS 0x0007
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_QUERY 0x82E3
#define GL_QUERY_BUFFER 0x9192
#define GL_QUERY_BUFFER_BARRIER_BIT 0x00008000
#define GL_QUERY_BUFFER_BINDING 0x9193
#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
#define GL_QUERY_BY_REGION_NO_WAIT_INVERTED 0x8E1A
#define GL_QUERY_BY_REGION_WAIT 0x8E15
#define GL_QUERY_BY_REGION_WAIT_INVERTED 0x8E19
#define GL_QUERY_COUNTER_BITS 0x8864
#define GL_QUERY_NO_WAIT 0x8E14
#define GL_QUERY_NO_WAIT_INVERTED 0x8E18
#define GL_QUERY_RESULT 0x8866
#define GL_QUERY_RESULT_AVAILABLE 0x8867
#define GL_QUERY_RESULT_NO_WAIT 0x9194
#define GL_QUERY_TARGET 0x82EA
#define GL_QUERY_WAIT 0x8E13
#define GL_QUERY_WAIT_INVERTED 0x8E17
#define GL_R11F_G11F_B10F 0x8C3A
#define GL_R16 0x822A
#define GL_R16F 0x822D
#define GL_R16I 0x8233
#define GL_R16UI 0x8234
#define GL_R16_SNORM 0x8F98
#define GL_R32F 0x822E
#define GL_R32I 0x8235
#define GL_R32UI 0x8236
#define GL_R3_G3_B2 0x2A10
#define GL_R8 0x8229
#define GL_R8I 0x8231
#define GL_R8UI 0x8232
#define GL_R8_SNORM 0x8F94
#define GL_RASTERIZER_DISCARD 0x8C89
#define GL_READ_BUFFER 0x0C02
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
#define GL_READ_ONLY 0x88B8
#define GL_READ_PIXELS 0x828C
#define GL_READ_PIXELS_FORMAT 0x828D
#define GL_READ_PIXELS_TYPE 0x828E
#define GL_READ_WRITE 0x88BA
#define GL_RED 0x1903
#define GL_RED_INTEGER 0x8D94
#define GL_REFERENCED_BY_COMPUTE_SHADER 0x930B
#define GL_REFERENCED_BY_FRAGMENT_SHADER 0x930A
#define GL_REFERENCED_BY_GEOMETRY_SHADER 0x9309
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER 0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER 0x9308
#define GL_REFERENCED_BY_VERTEX_SHADER 0x9306
#define GL_RENDERBUFFER 0x8D41
#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
#define GL_RENDERBUFFER_BINDING 0x8CA7
#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
#define GL_RENDERBUFFER_HEIGHT 0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
#define GL_RENDERBUFFER_RED_SIZE 0x8D50
#define GL_RENDERBUFFER_SAMPLES 0x8CAB
#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
#define GL_RENDERBUFFER_WIDTH 0x8D42
#define GL_RENDERER 0x1F01
#define GL_REPEAT 0x2901
#define GL_REPLACE 0x1E01
#define GL_RESET_NOTIFICATION_STRATEGY 0x8256
#define GL_RG 0x8227
#define GL_RG16 0x822C
#define GL_RG16F 0x822F
#define GL_RG16I 0x8239
#define GL_RG16UI 0x823A
#define GL_RG16_SNORM 0x8F99
#define GL_RG32F 0x8230
#define GL_RG32I 0x823B
#define GL_RG32UI 0x823C
#define GL_RG8 0x822B
#define GL_RG8I 0x8237
#define GL_RG8UI 0x8238
#define GL_RG8_SNORM 0x8F95
#define GL_RGB 0x1907
#define GL_RGB10 0x8052
#define GL_RGB10_A2 0x8059
#define GL_RGB10_A2UI 0x906F
#define GL_RGB12 0x8053
#define GL_RGB16 0x8054
#define GL_RGB16F 0x881B
#define GL_RGB16I 0x8D89
#define GL_RGB16UI 0x8D77
#define GL_RGB16_SNORM 0x8F9A
#define GL_RGB32F 0x8815
#define GL_RGB32I 0x8D83
#define GL_RGB32UI 0x8D71
#define GL_RGB4 0x804F
#define GL_RGB5 0x8050
#define GL_RGB565 0x8D62
#define GL_RGB5_A1 0x8057
#define GL_RGB8 0x8051
#define GL_RGB8I 0x8D8F
#define GL_RGB8UI 0x8D7D
#define GL_RGB8_SNORM 0x8F96
#define GL_RGB9_E5 0x8C3D
#define GL_RGBA 0x1908
#define GL_RGBA12 0x805A
#define GL_RGBA16 0x805B
#define GL_RGBA16F 0x881A
#define GL_RGBA16I 0x8D88
#define GL_RGBA16UI 0x8D76
#define GL_RGBA16_SNORM 0x8F9B
#define GL_RGBA2 0x8055
#define GL_RGBA32F 0x8814
#define GL_RGBA32I 0x8D82
#define GL_RGBA32UI 0x8D70
#define GL_RGBA4 0x8056
#define GL_RGBA8 0x8058
#define GL_RGBA8I 0x8D8E
#define GL_RGBA8UI 0x8D7C
#define GL_RGBA8_SNORM 0x8F97
#define GL_RGBA_INTEGER 0x8D99
#define GL_RGB_INTEGER 0x8D98
#define GL_RG_INTEGER 0x8228
#define GL_RIGHT 0x0407
#define GL_SAMPLER 0x82E6
#define GL_SAMPLER_1D 0x8B5D
#define GL_SAMPLER_1D_ARRAY 0x8DC0
#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
#define GL_SAMPLER_1D_SHADOW 0x8B61
#define GL_SAMPLER_2D 0x8B5E
#define GL_SAMPLER_2D_ARRAY 0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
#define GL_SAMPLER_2D_RECT 0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
#define GL_SAMPLER_2D_SHADOW 0x8B62
#define GL_SAMPLER_3D 0x8B5F
#define GL_SAMPLER_BINDING 0x8919
#define GL_SAMPLER_BUFFER 0x8DC2
#define GL_SAMPLER_CUBE 0x8B60
#define GL_SAMPLER_CUBE_MAP_ARRAY 0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW 0x900D
#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
#define GL_SAMPLES 0x80A9
#define GL_SAMPLES_PASSED 0x8914
#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
#define GL_SAMPLE_BUFFERS 0x80A8
#define GL_SAMPLE_COVERAGE 0x80A0
#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
#define GL_SAMPLE_MASK 0x8E51
#define GL_SAMPLE_MASK_VALUE 0x8E52
#define GL_SAMPLE_POSITION 0x8E50
#define GL_SAMPLE_SHADING 0x8C36
#define GL_SCISSOR_BOX 0x0C10
#define GL_SCISSOR_TEST 0x0C11
#define GL_SEPARATE_ATTRIBS 0x8C8D
#define GL_SET 0x150F
#define GL_SHADER 0x82E1
#define GL_SHADER_BINARY_FORMATS 0x8DF8
#define GL_SHADER_BINARY_FORMAT_SPIR_V 0x9551
#define GL_SHADER_COMPILER 0x8DFA
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT 0x00000020
#define GL_SHADER_IMAGE_ATOMIC 0x82A6
#define GL_SHADER_IMAGE_LOAD 0x82A4
#define GL_SHADER_IMAGE_STORE 0x82A5
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#define GL_SHADER_STORAGE_BARRIER_BIT 0x00002000
#define GL_SHADER_STORAGE_BLOCK 0x92E6
#define GL_SHADER_STORAGE_BUFFER 0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING 0x90D3
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 0x90DF
#define GL_SHADER_STORAGE_BUFFER_SIZE 0x90D5
#define GL_SHADER_STORAGE_BUFFER_START 0x90D4
#define GL_SHADER_TYPE 0x8B4F
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#define GL_SHORT 0x1402
#define GL_SIGNALED 0x9119
#define GL_SIGNED_NORMALIZED 0x8F9C
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST 0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE 0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST 0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE 0x82AF
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
#define GL_SPIR_V_BINARY 0x9552
#define GL_SPIR_V_EXTENSIONS 0x9553
#define GL_SRC1_ALPHA 0x8589
#define GL_SRC1_COLOR 0x88F9
#define GL_SRC_ALPHA 0x0302
#define GL_SRC_ALPHA_SATURATE 0x0308
#define GL_SRC_COLOR 0x0300
#define GL_SRGB 0x8C40
#define GL_SRGB8 0x8C41
#define GL_SRGB8_ALPHA8 0x8C43
#define GL_SRGB_ALPHA 0x8C42
#define GL_SRGB_READ 0x8297
#define GL_SRGB_WRITE 0x8298
#define GL_STACK_OVERFLOW 0x0503
#define GL_STACK_UNDERFLOW 0x0504
#define GL_STATIC_COPY 0x88E6
#define GL_STATIC_DRAW 0x88E4
#define GL_STATIC_READ 0x88E5
#define GL_STENCIL 0x1802
#define GL_STENCIL_ATTACHMENT 0x8D20
#define GL_STENCIL_BACK_FAIL 0x8801
#define GL_STENCIL_BACK_FUNC 0x8800
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
#define GL_STENCIL_BACK_REF 0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
#define GL_STENCIL_BUFFER_BIT 0x00000400
#define GL_STENCIL_CLEAR_VALUE 0x0B91
#define GL_STENCIL_COMPONENTS 0x8285
#define GL_STENCIL_FAIL 0x0B94
#define GL_STENCIL_FUNC 0x0B92
#define GL_STENCIL_INDEX 0x1901
#define GL_STENCIL_INDEX1 0x8D46
#define GL_STENCIL_INDEX16 0x8D49
#define GL_STENCIL_INDEX4 0x8D47
#define GL_STENCIL_INDEX8 0x8D48
#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
#define GL_STENCIL_REF 0x0B97
#define GL_STENCIL_RENDERABLE 0x8288
#define GL_STENCIL_TEST 0x0B90
#define GL_STENCIL_VALUE_MASK 0x0B93
#define GL_STENCIL_WRITEMASK 0x0B98
#define GL_STEREO 0x0C33
#define GL_STREAM_COPY 0x88E2
#define GL_STREAM_DRAW 0x88E0
#define GL_STREAM_READ 0x88E1
#define GL_SUBPIXEL_BITS 0x0D50
#define GL_SYNC_CONDITION 0x9113
#define GL_SYNC_FENCE 0x9116
#define GL_SYNC_FLAGS 0x9115
#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
#define GL_SYNC_STATUS 0x9114
#define GL_TESS_CONTROL_OUTPUT_VERTICES 0x8E75
#define GL_TESS_CONTROL_SHADER 0x8E88
#define GL_TESS_CONTROL_SHADER_BIT 0x00000008
#define GL_TESS_CONTROL_SHADER_PATCHES 0x82F1
#define GL_TESS_CONTROL_SUBROUTINE 0x92E9
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM 0x92EF
#define GL_TESS_CONTROL_TEXTURE 0x829C
#define GL_TESS_EVALUATION_SHADER 0x8E87
#define GL_TESS_EVALUATION_SHADER_BIT 0x00000010
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS 0x82F2
#define GL_TESS_EVALUATION_SUBROUTINE 0x92EA
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM 0x92F0
#define GL_TESS_EVALUATION_TEXTURE 0x829D
#define GL_TESS_GEN_MODE 0x8E76
#define GL_TESS_GEN_POINT_MODE 0x8E79
#define GL_TESS_GEN_SPACING 0x8E77
#define GL_TESS_GEN_VERTEX_ORDER 0x8E78
#define GL_TEXTURE 0x1702
#define GL_TEXTURE0 0x84C0
#define GL_TEXTURE1 0x84C1
#define GL_TEXTURE10 0x84CA
#define GL_TEXTURE11 0x84CB
#define GL_TEXTURE12 0x84CC
#define GL_TEXTURE13 0x84CD
#define GL_TEXTURE14 0x84CE
#define GL_TEXTURE15 0x84CF
#define GL_TEXTURE16 0x84D0
#define GL_TEXTURE17 0x84D1
#define GL_TEXTURE18 0x84D2
#define GL_TEXTURE19 0x84D3
#define GL_TEXTURE2 0x84C2
#define GL_TEXTURE20 0x84D4
#define GL_TEXTURE21 0x84D5
#define GL_TEXTURE22 0x84D6
#define GL_TEXTURE23 0x84D7
#define GL_TEXTURE24 0x84D8
#define GL_TEXTURE25 0x84D9
#define GL_TEXTURE26 0x84DA
#define GL_TEXTURE27 0x84DB
#define GL_TEXTURE28 0x84DC
#define GL_TEXTURE29 0x84DD
#define GL_TEXTURE3 0x84C3
#define GL_TEXTURE30 0x84DE
#define GL_TEXTURE31 0x84DF
#define GL_TEXTURE4 0x84C4
#define GL_TEXTURE5 0x84C5
#define GL_TEXTURE6 0x84C6
#define GL_TEXTURE7 0x84C7
#define GL_TEXTURE8 0x84C8
#define GL_TEXTURE9 0x84C9
#define GL_TEXTURE_1D 0x0DE0
#define GL_TEXTURE_1D_ARRAY 0x8C18
#define GL_TEXTURE_2D 0x0DE1
#define GL_TEXTURE_2D_ARRAY 0x8C1A
#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
#define GL_TEXTURE_3D 0x806F
#define GL_TEXTURE_ALPHA_SIZE 0x805F
#define GL_TEXTURE_ALPHA_TYPE 0x8C13
#define GL_TEXTURE_BASE_LEVEL 0x813C
#define GL_TEXTURE_BINDING_1D 0x8068
#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
#define GL_TEXTURE_BINDING_2D 0x8069
#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_BINDING_3D 0x806A
#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
#define GL_TEXTURE_BLUE_SIZE 0x805E
#define GL_TEXTURE_BLUE_TYPE 0x8C12
#define GL_TEXTURE_BORDER_COLOR 0x1004
#define GL_TEXTURE_BUFFER 0x8C2A
#define GL_TEXTURE_BUFFER_BINDING 0x8C2A
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_BUFFER_OFFSET 0x919D
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT 0x919F
#define GL_TEXTURE_BUFFER_SIZE 0x919E
#define GL_TEXTURE_COMPARE_FUNC 0x884D
#define GL_TEXTURE_COMPARE_MODE 0x884C
#define GL_TEXTURE_COMPRESSED 0x86A1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT 0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE 0x82B3
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH 0x82B1
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
#define GL_TEXTURE_CUBE_MAP 0x8513
#define GL_TEXTURE_CUBE_MAP_ARRAY 0x9009
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
#define GL_TEXTURE_DEPTH 0x8071
#define GL_TEXTURE_DEPTH_SIZE 0x884A
#define GL_TEXTURE_DEPTH_TYPE 0x8C16
#define GL_TEXTURE_FETCH_BARRIER_BIT 0x00000008
#define GL_TEXTURE_FILTER_CONTROL_EXT 0x8500
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_TEXTURE_GATHER 0x82A2
#define GL_TEXTURE_GATHER_SHADOW 0x82A3
#define GL_TEXTURE_GREEN_SIZE 0x805D
#define GL_TEXTURE_GREEN_TYPE 0x8C11
#define GL_TEXTURE_HEIGHT 0x1001
#define GL_TEXTURE_IMAGE_FORMAT 0x828F
#define GL_TEXTURE_IMAGE_TYPE 0x8290
#define GL_TEXTURE_IMMUTABLE_FORMAT 0x912F
#define GL_TEXTURE_IMMUTABLE_LEVELS 0x82DF
#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
#define GL_TEXTURE_LOD_BIAS 0x8501
#define GL_TEXTURE_LOD_BIAS_EXT 0x8501
#define GL_TEXTURE_MAG_FILTER 0x2800
#define GL_TEXTURE_MAX_ANISOTROPY 0x84FE
#define GL_TEXTURE_MAX_LEVEL 0x813D
#define GL_TEXTURE_MAX_LOD 0x813B
#define GL_TEXTURE_MIN_FILTER 0x2801
#define GL_TEXTURE_MIN_LOD 0x813A
#define GL_TEXTURE_RECTANGLE 0x84F5
#define GL_TEXTURE_RED_SIZE 0x805C
#define GL_TEXTURE_RED_TYPE 0x8C10
#define GL_TEXTURE_SAMPLES 0x9106
#define GL_TEXTURE_SHADOW 0x82A1
#define GL_TEXTURE_SHARED_SIZE 0x8C3F
#define GL_TEXTURE_STENCIL_SIZE 0x88F1
#define GL_TEXTURE_SWIZZLE_A 0x8E45
#define GL_TEXTURE_SWIZZLE_B 0x8E44
#define GL_TEXTURE_SWIZZLE_G 0x8E43
#define GL_TEXTURE_SWIZZLE_R 0x8E42
#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
#define GL_TEXTURE_TARGET 0x1006
#define GL_TEXTURE_UPDATE_BARRIER_BIT 0x00000100
#define GL_TEXTURE_VIEW 0x82B5
#define GL_TEXTURE_VIEW_MIN_LAYER 0x82DD
#define GL_TEXTURE_VIEW_MIN_LEVEL 0x82DB
#define GL_TEXTURE_VIEW_NUM_LAYERS 0x82DE
#define GL_TEXTURE_VIEW_NUM_LEVELS 0x82DC
#define GL_TEXTURE_WIDTH 0x1000
#define GL_TEXTURE_WRAP_R 0x8072
#define GL_TEXTURE_WRAP_S 0x2802
#define GL_TEXTURE_WRAP_T 0x2803
#define GL_TIMEOUT_EXPIRED 0x911B
#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
#define GL_TIMESTAMP 0x8E28
#define GL_TIME_ELAPSED 0x88BF
#define GL_TOP_LEVEL_ARRAY_SIZE 0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE 0x930D
#define GL_TRANSFORM_FEEDBACK 0x8E22
#define GL_TRANSFORM_FEEDBACK_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT 0x00000800
#define GL_TRANSFORM_FEEDBACK_BINDING 0x8E25
#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX 0x934B
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE 0x934C
#define GL_TRANSFORM_FEEDBACK_OVERFLOW 0x82EC
#define GL_TRANSFORM_FEEDBACK_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW 0x82ED
#define GL_TRANSFORM_FEEDBACK_VARYING 0x92F4
#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRIANGLES 0x0004
#define GL_TRIANGLES_ADJACENCY 0x000C
#define GL_TRIANGLE_FAN 0x0006
#define GL_TRIANGLE_STRIP 0x0005
#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
#define GL_TRUE 1
#define GL_TYPE 0x92FA
#define GL_UNDEFINED_VERTEX 0x8260
#define GL_UNIFORM 0x92E1
#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX 0x92DA
#define GL_UNIFORM_BARRIER_BIT 0x00000004
#define GL_UNIFORM_BLOCK 0x92E2
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BUFFER 0x8A11
#define GL_UNIFORM_BUFFER_BINDING 0x8A28
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
#define GL_UNIFORM_BUFFER_START 0x8A29
#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
#define GL_UNIFORM_NAME_LENGTH 0x8A39
#define GL_UNIFORM_OFFSET 0x8A3B
#define GL_UNIFORM_SIZE 0x8A38
#define GL_UNIFORM_TYPE 0x8A37
#define GL_UNKNOWN_CONTEXT_RESET 0x8255
#define GL_UNPACK_ALIGNMENT 0x0CF5
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH 0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT 0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE 0x912A
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH 0x9127
#define GL_UNPACK_IMAGE_HEIGHT 0x806E
#define GL_UNPACK_LSB_FIRST 0x0CF1
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_IMAGES 0x806D
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#define GL_UNPACK_SWAP_BYTES 0x0CF0
#define GL_UNSIGNALED 0x9118
#define GL_UNSIGNED_BYTE 0x1401
#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
#define GL_UNSIGNED_BYTE_3_3_2 0x8032
#define GL_UNSIGNED_INT 0x1405
#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
#define GL_UNSIGNED_INT_10_10_10_2 0x8036
#define GL_UNSIGNED_INT_24_8 0x84FA
#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
#define GL_UNSIGNED_INT_8_8_8_8 0x8035
#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
#define GL_UNSIGNED_INT_ATOMIC_COUNTER 0x92DB
#define GL_UNSIGNED_INT_IMAGE_1D 0x9062
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY 0x9068
#define GL_UNSIGNED_INT_IMAGE_2D 0x9063
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY 0x9069
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x906C
#define GL_UNSIGNED_INT_IMAGE_2D_RECT 0x9065
#define GL_UNSIGNED_INT_IMAGE_3D 0x9064
#define GL_UNSIGNED_INT_IMAGE_BUFFER 0x9067
#define GL_UNSIGNED_INT_IMAGE_CUBE 0x9066
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY 0x906A
#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8
#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
#define GL_UNSIGNED_INT_VEC2 0x8DC6
#define GL_UNSIGNED_INT_VEC3 0x8DC7
#define GL_UNSIGNED_INT_VEC4 0x8DC8
#define GL_UNSIGNED_NORMALIZED 0x8C17
#define GL_UNSIGNED_SHORT 0x1403
#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
#define GL_UNSIGNED_SHORT_5_6_5 0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
#define GL_UPPER_LEFT 0x8CA2
#define GL_VALIDATE_STATUS 0x8B83
#define GL_VENDOR 0x1F00
#define GL_VERSION 0x1F02
#define GL_VERTEX_ARRAY 0x8074
#define GL_VERTEX_ARRAY_BINDING 0x85B5
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT 0x00000001
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_LONG 0x874E
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
#define GL_VERTEX_ATTRIB_BINDING 0x82D4
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D5
#define GL_VERTEX_BINDING_BUFFER 0x8F4F
#define GL_VERTEX_BINDING_DIVISOR 0x82D6
#define GL_VERTEX_BINDING_OFFSET 0x82D7
#define GL_VERTEX_BINDING_STRIDE 0x82D8
#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
#define GL_VERTEX_SHADER 0x8B31
#define GL_VERTEX_SHADER_BIT 0x00000001
#define GL_VERTEX_SHADER_INVOCATIONS 0x82F0
#define GL_VERTEX_SUBROUTINE 0x92E8
#define GL_VERTEX_SUBROUTINE_UNIFORM 0x92EE
#define GL_VERTEX_TEXTURE 0x829B
#define GL_VERTICES_SUBMITTED 0x82EE
#define GL_VIEWPORT 0x0BA2
#define GL_VIEWPORT_BOUNDS_RANGE 0x825D
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_VIEWPORT_SUBPIXEL_BITS 0x825C
#define GL_VIEW_CLASS_128_BITS 0x82C4
#define GL_VIEW_CLASS_16_BITS 0x82CA
#define GL_VIEW_CLASS_24_BITS 0x82C9
#define GL_VIEW_CLASS_32_BITS 0x82C8
#define GL_VIEW_CLASS_48_BITS 0x82C7
#define GL_VIEW_CLASS_64_BITS 0x82C6
#define GL_VIEW_CLASS_8_BITS 0x82CB
#define GL_VIEW_CLASS_96_BITS 0x82C5
#define GL_VIEW_CLASS_BPTC_FLOAT 0x82D3
#define GL_VIEW_CLASS_BPTC_UNORM 0x82D2
#define GL_VIEW_CLASS_RGTC1_RED 0x82D0
#define GL_VIEW_CLASS_RGTC2_RG 0x82D1
#define GL_VIEW_CLASS_S3TC_DXT1_RGB 0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA 0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA 0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA 0x82CF
#define GL_VIEW_COMPATIBILITY_CLASS 0x82B6
#define GL_WAIT_FAILED 0x911D
#define GL_WRITE_ONLY 0x88B9
#define GL_XOR 0x1506
#define GL_ZERO 0
#define GL_ZERO_TO_ONE 0x935F


#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2018 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
 *
 * The master copy of khrplatform.h is maintained in the Khronos EGL
 * Registry repository at https://github.com/KhronosGroup/EGL-Registry
 * The last semantic modification to khrplatform.h was at commit ID:
 *      67a3e0864c2d75ea5287b9f3d2eb74a745936692
 *
 * Adopters may modify this file to suit their platform. Adopters are
 * encouraged to submit platform specific modifications to the Khronos
 * group so that they can be included in future versions of this file.
 * Please submit changes by filing pull requests or issues on
 * the EGL Registry repository linked above.
 *
 *
 * See the Implementer's Guidelines for information about where this file
 * should be located on your system and for more details of its use:
 *    http://www.khronos.org/registry/implementers_guide.pdf
 *
 * This file should be included as
 *        #include <KHR/khrplatform.h>
 * by Khronos client API header files that use its types and defines.
 *
 * The types in khrplatform.h should only be used to define API-specific types.
 *
 * Types defined in khrplatform.h:
 *    khronos_int8_t              signed   8  bit
 *    khronos_uint8_t             unsigned 8  bit
 *    khronos_int16_t             signed   16 bit
 *    khronos_uint16_t            unsigned 16 bit
 *    khronos_int32_t             signed   32 bit
 *    khronos_uint32_t            unsigned 32 bit
 *    khronos_int64_t             signed   64 bit
 *    khronos_uint64_t            unsigned 64 bit
 *    khronos_intptr_t            signed   same number of bits as a pointer
 *    khronos_uintptr_t           unsigned same number of bits as a pointer
 *    khronos_ssize_t             signed   size
 *    khronos_usize_t             unsigned size
 *    khronos_float_t             signed   32 bit floating point
 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
 *                                         nanoseconds
 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
 *    khronos_boolean_enum_t      enumerated boolean type. This should
 *      only be used as a base type when a client API's boolean type is
 *      an enum. Client APIs which use an integer or other type for
 *      booleans cannot use this as the base type for their boolean.
 *
 * Tokens defined in khrplatform.h:
 *
 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
 *
 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
 *
 * Calling convention macros defined in this file:
 *    KHRONOS_APICALL
 *    KHRONOS_GLAD_API_PTR
 *    KHRONOS_APIATTRIBUTES
 *
 * These may be used in function prototypes as:
 *
 *      KHRONOS_APICALL void KHRONOS_GLAD_API_PTR funcname(
 *                                  int arg1,
 *                                  int arg2) KHRONOS_APIATTRIBUTES;
 */

#if defined(__SCITECH_SNAP__) && !defined(KHRONOS_STATIC)
#   define KHRONOS_STATIC 1
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APICALL
 *-------------------------------------------------------------------------
 * This precedes the return type of the function in the function prototype.
 */
#if defined(KHRONOS_STATIC)
    /* If the preprocessor constant KHRONOS_STATIC is defined, make the
     * header compatible with static linking. */
#   define KHRONOS_APICALL
#elif defined(_WIN32)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_GLAD_API_PTR
 *-------------------------------------------------------------------------
 * This follows the return type of the function  and precedes the function
 * name in the function prototype.
 */
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
    /* Win32 but not WinCE */
#   define KHRONOS_GLAD_API_PTR __stdcall
#else
#   define KHRONOS_GLAD_API_PTR
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIATTRIBUTES
 *-------------------------------------------------------------------------
 * This follows the closing parenthesis of the function prototype arguments.
 */
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
 * basic type definitions
 *-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
 * Using <stdint.h>
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1
/*
 * To support platform where unsigned long cannot be used interchangeably with
 * inptr_t (e.g. CHERI-extended ISAs), we can use the stdint.h intptr_t.
 * Ideally, we could just use (u)intptr_t everywhere, but this could result in
 * ABI breakage if khronos_uintptr_t is changed from unsigned long to
 * unsigned long long or similar (this results in different C++ name mangling).
 * To avoid changes for existing platforms, we restrict usage of intptr_t to
 * platforms where the size of a pointer is larger than the size of long.
 */
#if defined(__SIZEOF_LONG__) && defined(__SIZEOF_POINTER__)
#if __SIZEOF_POINTER__ > __SIZEOF_LONG__
#define KHRONOS_USE_INTPTR_T
#endif
#endif

#elif defined(__VMS ) || defined(__sgi)

/*
 * Using <inttypes.h>
 */
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
 * Win32
 */
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
 * Sun or Digital
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
 * Hypothetical platform with no float or int64 support
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
 * Generic fallback
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
 * Types that are (so far) the same on all platforms
 */
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
 * Types that differ between LLP64 and LP64 architectures - in LLP64,
 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
 * to be the only LLP64 architecture in current use.
 */
#ifdef KHRONOS_USE_INTPTR_T
typedef intptr_t               khronos_intptr_t;
typedef uintptr_t              khronos_uintptr_t;
#elif defined(_WIN64)
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
#endif

#if defined(_WIN64)
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
 * Float type
 */
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
 *
 * These types can be used to represent a time interval in nanoseconds or
 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
 * of nanoseconds since some arbitrary system event (e.g. since the last
 * time the system booted).  The Unadjusted System Time is an unsigned
 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
 * may be either signed or unsigned.
 */
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
 * Dummy value used to pad enum types to 32 bits.
 */
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
 * Enumerated boolean type
 *
 * Values other than zero should be considered to be true.  Therefore
 * comparisons should not be made against KHRONOS_TRUE.
 */
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;
#ifdef __APPLE__
typedef void *GLhandleARB;
#else
typedef unsigned int GLhandleARB;
#endif
typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_intptr_t GLintptr;
#else
typedef khronos_intptr_t GLintptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_intptr_t GLintptrARB;
#else
typedef khronos_intptr_t GLintptrARB;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_ssize_t GLsizeiptr;
#else
typedef khronos_ssize_t GLsizeiptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_ssize_t GLsizeiptrARB;
#else
typedef khronos_ssize_t GLsizeiptrARB;
#endif
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (GLAD_API_PTR *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (GLAD_API_PTR *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (GLAD_API_PTR *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (GLAD_API_PTR *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void (GLAD_API_PTR *GLVULKANPROCNV)(void);


#define GL_VERSION_1_0 1
GLAD_API_CALL int GLAD_GL_VERSION_1_0;
#define GL_VERSION_1_1 1
GLAD_API_CALL int GLAD_GL_VERSION_1_1;
#define GL_VERSION_1_2 1
GLAD_API_CALL int GLAD_GL_VERSION_1_2;
#define GL_VERSION_1_3 1
GLAD_API_CALL int GLAD_GL_VERSION_1_3;
#define GL_VERSION_1_4 1
GLAD_API_CALL int GLAD_GL_VERSION_1_4;
#define GL_VERSION_1_5 1
GLAD_API_CALL int GLAD_GL_VERSION_1_5;
#define GL_VERSION_2_0 1
GLAD_API_CALL int GLAD_GL_VERSION_2_0;
#define GL_VERSION_2_1 1
GLAD_API_CALL int GLAD_GL_VERSION_2_1;
#define GL_VERSION_3_0 1
GLAD_API_CALL int GLAD_GL_VERSION_3_0;
#define GL_VERSION_3_1 1
GLAD_API_CALL int GLAD_GL_VERSION_3_1;
#define GL_VERSION_3_2 1
GLAD_API_CALL int GLAD_GL_VERSION_3_2;
#define GL_VERSION_3_3 1
GLAD_API_CALL int GLAD_GL_VERSION_3_3;
#define GL_VERSION_4_0 1
GLAD_API_CALL int GLAD_GL_VERSION_4_0;
#define GL_VERSION_4_1 1
GLAD_API_CALL int GLAD_GL_VERSION_4_1;
#define GL_VERSION_4_2 1
GLAD_API_CALL int GLAD_GL_VERSION_4_2;
#define GL_VERSION_4_3 1
GLAD_API_CALL int GLAD_GL_VERSION_4_3;
#define GL_VERSION_4_4 1
GLAD_API_CALL int GLAD_GL_VERSION_4_4;
#define GL_VERSION_4_5 1
GLAD_API_CALL int GLAD_GL_VERSION_4_5;
#define GL_VERSION_4_6 1
GLAD_API_CALL int GLAD_GL_VERSION_4_6;
#define GL_EXT_texture_lod_bias 1
GLAD_API_CALL int GLAD_GL_EXT_texture_lod_bias;


typedef void (GLAD_API_PTR *PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
typedef void (GLAD_API_PTR *PFNGLACTIVETEXTUREPROC)(GLenum texture);
typedef void (GLAD_API_PTR *PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (GLAD_API_PTR *PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
typedef void (GLAD_API_PTR *PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (GLAD_API_PTR *PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXARRAYPROC)(GLuint array);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (GLAD_API_PTR *PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (GLAD_API_PTR *PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
typedef void (GLAD_API_PTR *PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
typedef void (GLAD_API_PTR *PFNGLCLEARPROC)(GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHPROC)(GLdouble depth);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHFPROC)(GLfloat d);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARSTENCILPROC)(GLint s);
typedef void (GLAD_API_PTR *PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);
typedef GLenum (GLAD_API_PTR *PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GLAD_API_PTR *PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (GLAD_API_PTR *PFNGLCOMPILESHADERPROC)(GLuint shader);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (GLAD_API_PTR *PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef GLuint (GLAD_API_PTR *PFNGLCREATEPROGRAMPROC)(void);
typedef void (GLAD_API_PTR *PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint * samplers);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROC)(GLenum type);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const* strings);
typedef void (GLAD_API_PTR *PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLCULLFACEPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void * userParam);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
typedef void (GLAD_API_PTR *PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLDELETESHADERPROC)(GLuint shader);
typedef void (GLAD_API_PTR *PFNGLDELETESYNCPROC)(GLsync sync);
typedef void (GLAD_API_PTR *PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLDEPTHFUNCPROC)(GLenum func);
typedef void (GLAD_API_PTR *PFNGLDEPTHMASKPROC)(GLboolean flag);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
typedef void (GLAD_API_PTR *PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (GLAD_API_PTR *PFNGLDISABLEPROC)(GLenum cap);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEIPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERPROC)(GLenum buf);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLENABLEPROC)(GLenum cap);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEIPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENDCONDITIONALRENDERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDQUERYPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENDTRANSFORMFEEDBACKPROC)(void);
typedef GLsync (GLAD_API_PTR *PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLFINISHPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFLUSHPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLFRONTFACEPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLGENBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLGENQUERIESPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLGENTEXTURESPROC)(GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLGENERATEMIPMAPPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
typedef GLint (GLAD_API_PTR *PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void * img);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);
typedef GLuint (GLAD_API_PTR *PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble * data);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble * data);
typedef GLenum (GLAD_API_PTR *PFNGLGETERRORPROC)(void);
typedef void (GLAD_API_PTR *PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETFLOATVPROC)(GLenum pname, GLfloat * data);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef GLenum (GLAD_API_PTR *PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
typedef void (GLAD_API_PTR *PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERVPROC)(GLenum pname, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat * val);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTPTRLABELPROC)(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETPOINTERVPROC)(GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint * params);
typedef GLuint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision);
typedef void (GLAD_API_PTR *PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
typedef void (GLAD_API_PTR *PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint * params);
typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGPROC)(GLenum name);
typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
typedef GLuint (GLAD_API_PTR *PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 * param);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint * param);
typedef GLuint (GLAD_API_PTR *PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar * uniformBlockName);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
typedef GLint (GLAD_API_PTR *PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLHINTPROC)(GLenum target, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments);
typedef void (GLAD_API_PTR *PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments);
typedef void (GLAD_API_PTR *PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
typedef GLboolean (GLAD_API_PTR *PFNGLISBUFFERPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDPROC)(GLenum cap);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
typedef GLboolean (GLAD_API_PTR *PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPROC)(GLuint program);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef GLboolean (GLAD_API_PTR *PFNGLISQUERYPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISSAMPLERPROC)(GLuint sampler);
typedef GLboolean (GLAD_API_PTR *PFNGLISSHADERPROC)(GLuint shader);
typedef GLboolean (GLAD_API_PTR *PFNGLISSYNCPROC)(GLsync sync);
typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREPROC)(GLuint texture);
typedef GLboolean (GLAD_API_PTR *PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISVERTEXARRAYPROC)(GLuint array);
typedef void (GLAD_API_PTR *PFNGLLINEWIDTHPROC)(GLfloat width);
typedef void (GLAD_API_PTR *PFNGLLINKPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLLOGICOPPROC)(GLenum opcode);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);
typedef void (GLAD_API_PTR *PFNGLOBJECTPTRLABELPROC)(const void * ptr, GLsizei length, const GLchar * label);
typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPOINTSIZEPROC)(GLfloat size);
typedef void (GLAD_API_PTR *PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
typedef void (GLAD_API_PTR *PFNGLPOPDEBUGGROUPPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar * message);
typedef void (GLAD_API_PTR *PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
typedef void (GLAD_API_PTR *PFNGLREADBUFFERPROC)(GLenum src);
typedef void (GLAD_API_PTR *PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
typedef void (GLAD_API_PTR *PFNGLRELEASESHADERCOMPILERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
typedef void (GLAD_API_PTR *PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (GLAD_API_PTR *PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
typedef void (GLAD_API_PTR *PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
typedef void (GLAD_API_PTR *PFNGLSPECIALIZESHADERPROC)(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILMASKPROC)(GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBARRIERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint * indices);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPBUFFERPROC)(GLenum target);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);

GLAD_API_CALL PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;
/**
* @name glActiveShaderProgram - set the active program object for a program pipeline object
* @usage
* @code void glActiveShaderProgram(GLuint pipeline, GLuint program); @endcode
* @param pipeline Specifies the program pipeline object to set the active program object for.
* @param program Specifies the program object to set as the active program pipeline object <em class="parameter"><b>pipeline</b></em>.
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
* @errors GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked.
*
*/
#define glActiveShaderProgram glad_glActiveShaderProgram
GLAD_API_CALL PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
/**
* @name glActiveTexture - select active texture unit
* @usage
* @code void glActiveTexture(GLenum texture); @endcode
* @param texture Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least
*                80. <em class="parameter"><b>texture</b></em> must be one of <b>GL_TEXTURE</b><span class="emphasis"><em>i</em></span>,
*                where <span class="emphasis"><em>i</em></span> ranges from zero to the value of <b>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</b>
*                minus one. The initial value is <b>GL_TEXTURE0</b>.
*
* @errors GL_INVALID_ENUM is generated if texture is not one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
*         minus one.
*
*/
#define glActiveTexture glad_glActiveTexture
GLAD_API_CALL PFNGLATTACHSHADERPROC glad_glAttachShader;
/**
* @name glAttachShader - Attaches a shader object to a program object
* @usage
* @code void glAttachShader(GLuint program, GLuint shader); @endcode
* @param program Specifies the program object to which a shader object will be attached.
* @param shader Specifies the shader object that is to be attached.
*
* @errors GL_INVALID_VALUE is generated if either program or shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_OPERATION is generated if shader is already attached to program.
*
*/
#define glAttachShader glad_glAttachShader
GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
/**
* @name glBeginConditionalRender - start conditional rendering
* @usage
* @code void glBeginConditionalRender(GLuint id, GLenum mode); @endcode
* @param id Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
* @param mode Specifies how <b>glBeginConditionalRender</b> interprets the results of the occlusion query.
* @note glBeginConditionalRender and glEndConditionalRender are available only if the GL version is 3.0 or greater.
* @note The GL_ANY_SAMPLES_PASSED query result is available only if the GL version is 3.3 or greater.
*
* @errors GL_INVALID_VALUE is generated if id is not the name of an existing query object.
* @errors GL_INVALID_ENUM is generated if mode is not one of the accepted tokens.
* @errors GL_INVALID_OPERATION is generated if glBeginConditionalRender is called while conditional rendering is active, or if glEndConditionalRender
*         is called while conditional rendering is inactive.
* @errors GL_INVALID_OPERATION is generated if id is the name of a query object with a target other than GL_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED.
* @errors GL_INVALID_OPERATION is generated if id is the name of a query currently in progress.
*
*/
#define glBeginConditionalRender glad_glBeginConditionalRender
GLAD_API_CALL PFNGLBEGINQUERYPROC glad_glBeginQuery;
/**
* @name glBeginQuery - delimit the boundaries of a query object
* @usage
* @code void glBeginQuery(GLenum target, GLuint id); @endcode
* @param target Specifies the target type of query object established between <b>glBeginQuery</b> and the subsequent  <b>glEndQuery</b>.
*               The symbolic constant must be one of <b>GL_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</b>,
*               <b>GL_PRIMITIVES_GENERATED</b>, <b>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</b>, or <b>GL_TIME_ELAPSED</b>.
* @param id Specifies the name of a query object.
* @note If the query target's count exceeds the maximum value representable in the number of available bits, as reported by glGetQueryiv
*       with target set to the appropriate query target and pnameGL_QUERY_COUNTER_BITS, the count becomes undefined.
* @note An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.
* @note When GL_SAMPLE_BUFFERS is 0, the samples-passed counter of an occlusion query will increment once for each fragment that
*       passes the depth test.  When GL_SAMPLE_BUFFERS is 1, an implementation may either increment the samples-passed counter
*       individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all
*       samples of a fragment if any one of them passes the depth test.
* @note The query targets GL_ANY_SAMPLES_PASSED, and GL_TIME_ELAPSED are availale only if the GL version is 3.3 or higher.
* @note The query target GL_ANY_SAMPLES_PASSED_CONSERVATIVE is available only of the GL version is 4.3 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the accepted tokens.
* @errors GL_INVALID_OPERATION is generated if glBeginQuery is executed while a query object of the same target is already active.
* @errors GL_INVALID_OPERATION is generated if  glEndQuery is executed when a query object of the same target is not active.
* @errors GL_INVALID_OPERATION is generated if id is 0.
* @errors GL_INVALID_OPERATION is generated if id is the name of an already active query object.
* @errors GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target.
*
*/
#define glBeginQuery glad_glBeginQuery
GLAD_API_CALL PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;
/**
* @name glBeginQueryIndexed, glEndQueryIndexed - delimit the boundaries of a query object on an indexed target
* @usage
* @code void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id); @endcode
* @param target Specifies the target type of query object established between <b>glBeginQueryIndexed</b> and the subsequent  <b>glEndQueryIndexed</b>.
*               The symbolic constant must be one of <b>GL_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED</b>, <b>GL_PRIMITIVES_GENERATED</b>,
*               <b>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</b>, or <b>GL_TIME_ELAPSED</b>.
* @param index Specifies the index of the query target upon which to begin the query.
* @param id Specifies the name of a query object.
* @note If the query target's count exceeds the maximum value representable in the number of available bits, as reported by glGetQueryiv
*       with target set to the appropriate query target and pnameGL_QUERY_COUNTER_BITS, the count becomes undefined.
* @note An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.
* @note When GL_SAMPLE_BUFFERS is 0, the samples-passed counter of an occlusion query will increment once for each fragment that
*       passes the depth test.  When GL_SAMPLE_BUFFERS is 1, an implementation may either increment the samples-passed counter
*       individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all
*       samples of a fragment if any one of them passes the depth test.
* @note Calling glBeginQuery or glEndQuery is equivalent to calling glBeginQueryIndexed or glEndQueryIndexed with index set to zero,
*       respectively.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the accepted tokens.
* @errors GL_INVALID_VALUE is generated if index is greater than the query target-specific maximum.
* @errors GL_INVALID_OPERATION is generated if glBeginQueryIndexed is executed while a query object of the same target is already
*         active.
* @errors GL_INVALID_OPERATION is generated if  glEndQueryIndexed is executed when a query object of the same target is not active.
* @errors GL_INVALID_OPERATION is generated if id is 0.
* @errors GL_INVALID_OPERATION is generated if id is the name of an already active query object.
* @errors GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target.
*
*/
#define glBeginQueryIndexed glad_glBeginQueryIndexed
GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
/**
* @name glBeginTransformFeedback - start transform feedback operation
* @usage
* @code void glBeginTransformFeedback(GLenum primitiveMode); @endcode
* @param primitiveMode Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
* @note Geometry shaders, and the GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY, GL_LINES_ADJACENCY and GL_LINE_STRIP_ADJACENCY
*       primtive modes are available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_OPERATION is generated if glBeginTransformFeedback is executed while transform feedback is active.
* @errors GL_INVALID_OPERATION is generated if glEndTransformFeedback is executed while transform feedback is not active.
* @errors GL_INVALID_OPERATION is generated by glDrawArrays if no geometry shader is present, transform feedback is active and mode
*         is not one of the allowed modes.
* @errors GL_INVALID_OPERATION is generated by glDrawArrays if a geometry shader is present, transform feedback is active and the
*         output primitive type of the geometry shader does not match the transform feedback primitiveMode.
* @errors GL_INVALID_OPERATION is generated by glBeginTransformFeedback if any binding point used in transform feedback mode does
*         not have a buffer object bound.
* @errors GL_INVALID_OPERATION is generated by glBeginTransformFeedback if no binding points would be used, either because no program
*         object is active of because the active program object has specified no varying variables to record.
*
*/
#define glBeginTransformFeedback glad_glBeginTransformFeedback
GLAD_API_CALL PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
/**
* @name glBindAttribLocation - Associates a generic vertex attribute index with a named attribute variable
* @usage
* @code void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name); @endcode
* @param program Specifies the handle of the program object in which the association is to be made.
* @param index Specifies the index of the generic vertex attribute to be bound.
* @param name Specifies a null terminated string containing the name of the vertex shader attribute variable to which <em class="parameter"><b>index</b></em>
*             is to be bound.
* @note glBindAttribLocation can be called before any vertex shader objects are bound to the specified program object. It is also
*       permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.
* @note If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple
*       indices, but you can bind multiple user-defined attribute variables to the same index.
* @note Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index.
*       This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program,
*       or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location.
*       The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work
*       only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing.
* @note Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram is called. The locations
*       assigned can be queried by calling glGetAttribLocation.
* @note OpenGL copies the name string when glBindAttribLocation is called, so an application may free its copy of the name string
*       immediately after the function returns.
* @note Generic attribute locations may be specified in the shader source text using a location layout qualifier. In this case,
*       the location of the attribute specified in the shader's source takes precedence and may be queried by calling glGetAttribLocation.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
*
*/
#define glBindAttribLocation glad_glBindAttribLocation
GLAD_API_CALL PFNGLBINDBUFFERPROC glad_glBindBuffer;
/**
* @name glBindBuffer - bind a named buffer object
* @usage
* @code void glBindBuffer(GLenum target, GLuint buffer); @endcode
* @param target Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following
*               table:
* @param buffer Specifies the name of a buffer object.
* @note The GL_COPY_READ_BUFFER, GL_UNIFORM_BUFFER and GL_TEXTURE_BUFFER targets are available only if the GL version is 3.1 or
*       greater.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if buffer is not a name previously returned from a call to glGenBuffers.
*
*/
#define glBindBuffer glad_glBindBuffer
GLAD_API_CALL PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
/**
* @name glBindBufferBase - bind a buffer object to an indexed buffer target
* @usage
* @code void glBindBufferBase(GLenum target, GLuint index, GLuint buffer); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b> or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param index Specify the index of the binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param buffer The name of a buffer object to bind to the specified binding point.
* @note Calling glBindBufferBase is equivalent to calling glBindBufferRange with offset zero and size equal to the size of the buffer.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_SHADER_STORAGE_BUFFER target is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points.
* @errors GL_INVALID_VALUE is generated if buffer does not have an associated data store, or if the size of that store is zero.
*
*/
#define glBindBufferBase glad_glBindBufferBase
GLAD_API_CALL PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
/**
* @name glBindBufferRange - bind a range within a buffer object to an indexed buffer target
* @usage
* @code void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b>, or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param index Specify the index of the binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param buffer The name of a buffer object to bind to the specified binding point.
* @param offset The starting offset in basic machine units into the buffer object <em class="parameter"><b>buffer</b></em>.
* @param size The amount of data in machine units that can be read from the buffer object while used as an indexed target.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_SHADER_STORAGE_BUFFER target is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if target is not one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points.
* @errors GL_INVALID_VALUE is generated if size is less than or equal to zero, or if offset + size is greater than the value of GL_BUFFER_SIZE.
* @errors Additional errors may be generated if offset violates any target-specific alignmemt restrictions.
*
*/
#define glBindBufferRange glad_glBindBufferRange
GLAD_API_CALL PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;
/**
* @name glBindBuffersBase - bind one or more buffer objects to a sequence of indexed buffer targets
* @usage
* @code void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b> or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param first Specify the index of the first binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param count Specify the number of contiguous binding points to which to bind buffers.
* @param buffers A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or <b>NULL</b>.
* @note glBindBuffersBase is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
*
*/
#define glBindBuffersBase glad_glBindBuffersBase
GLAD_API_CALL PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;
/**
* @name glBindBuffersRange - bind ranges of one or more buffer objects to a sequence of indexed buffer targets
* @usage
* @code void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLintptr *sizes); @endcode
* @param target Specify the target of the bind operation. <em class="parameter"><b>target</b></em> must be one of <b>GL_ATOMIC_COUNTER_BUFFER</b>,
*               <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>, <b>GL_UNIFORM_BUFFER</b> or <b>GL_SHADER_STORAGE_BUFFER</b>.
* @param first Specify the index of the first binding point within the array specified by <em class="parameter"><b>target</b></em>.
* @param count Specify the number of contiguous binding points to which to bind buffers.
* @param buffers A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or <b>NULL</b>.
* @param offsets A pointer to an array of offsets into the corresponding buffer in <em class="parameter"><b>buffers</b></em> to bind, or
*                <b>NULL</b> if <em class="parameter"><b>buffers</b></em> is <b>NULL</b>.
* @param sizes A pointer to an array of sizes of the corresponding buffer in <em class="parameter"><b>buffers</b></em> to bind, or <b>NULL</b>
*              if <em class="parameter"><b>buffers</b></em> is <b>NULL</b>.
* @note glBindBuffersBase is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER
*         or GL_SHADER_STORAGE_BUFFER.
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated by if any value in offsets is less than zero or if any value in sizes is less than zero.
* @errors GL_INVALID_VALUE is generated if any pair of values in offsets and sizes does not respectively satisfy the constraints described
*         for those parameters for the specified target.
*
*/
#define glBindBuffersRange glad_glBindBuffersRange
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
/**
* @name glBindFragDataLocation - bind a user-defined varying out variable to a fragment shader color number
* @usage
* @code void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name); @endcode
* @param program The name of the program containing varying out variable whose binding to modify
* @param colorNumber The color number to bind the user-defined varying out variable to
* @param name The name of the user-defined varying out variable whose binding to modify
* @note Varying out varyings may have indexed locations assigned explicitly in the shader text using a location layout qualifier.
*       If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any
*       location assigned with glBindFragDataLocation is ignored.
*
* @errors GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS.
* @errors GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix.
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glBindFragDataLocation glad_glBindFragDataLocation
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
/**
* @name glBindFragDataLocationIndexed - bind a user-defined varying out variable to a fragment shader color number and index
* @usage
* @code void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char *name); @endcode
* @param program The name of the program containing varying out variable whose binding to modify
* @param colorNumber The color number to bind the user-defined varying out variable to
* @param index The index of the color input to bind the user-defined varying out variable to
* @param name The name of the user-defined varying out variable whose binding to modify
* @note Varying out varyings may have locations assigned explicitly in the shader text using a location layout qualifier. If a shader
*       statically assigns a location to a varying out variable in the shader text, that location is used and any location
*       assigned with glBindFragDataLocation is ignored.
*
* @errors GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS.
* @errors GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DUAL_SOURCE_DRAW_BUFFERS and index is greater
*         than or equal to one.
* @errors GL_INVALID_VALUE is generated if index is greater than one.
* @errors GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix.
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glBindFragDataLocationIndexed glad_glBindFragDataLocationIndexed
GLAD_API_CALL PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
/**
* @name glBindFramebuffer - bind a framebuffer to a framebuffer target
* @usage
* @code void glBindFramebuffer(GLenum target, GLuint framebuffer); @endcode
* @param target Specifies the framebuffer target of the binding operation.
* @param framebuffer Specifies the name of the framebuffer object to bind.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
* @errors GL_INVALID_OPERATION is generated if framebuffer is not zero or the name of a framebuffer previously returned from a call
*         to glGenFramebuffers.
*
*/
#define glBindFramebuffer glad_glBindFramebuffer
GLAD_API_CALL PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;
/**
* @name glBindImageTexture - bind a level of a texture to an image unit
* @usage
* @code void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format); @endcode
* @param unit Specifies the index of the image unit to which to bind the texture
* @param texture Specifies the name of the texture to bind to the image unit.
* @param level Specifies the level of the texture that is to be bound.
* @param layered Specifies whether a layered texture binding is to be established.
* @param layer If <em class="parameter"><b>layered</b></em> is <b>GL_FALSE</b>, specifies the layer of <em class="parameter"><b>texture</b></em>
*              to be bound to the image unit. Ignored otherwise.
* @param access Specifies a token indicating the type of access that will be performed on the image.
* @param format Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.
* @note The glBindImageTexture is available only if the GL version is 4.2 or greater.
*
* @errors GL_INVALID_VALUE is generated if unit greater than or equal to the value of GL_MAX_IMAGE_UNITS.
* @errors GL_INVALID_VALUE is generated if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level or layer is less than zero.
* @errors GL_INVALID_ENUM is generated if access or format is not one of the supported tokens.
*
*/
#define glBindImageTexture glad_glBindImageTexture
GLAD_API_CALL PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;
/**
* @name glBindImageTextures - bind one or more named texture images to a sequence of consecutive image units
* @usage
* @code void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures); @endcode
* @param first Specifies the first image unit to which a texture is to be bound.
* @param count Specifies the number of textures to bind.
* @param textures Specifies the address of an array of names of existing texture objects.
* @note glBindImageTextures is available only if the GL version is 4.4 or higher.
* @note Note that because glBindImageTextures cannot create new textures (even if a name passed has been previously generated by
*       call to glGenTextures), names passed to glBindImageTextures must have been bound at least once previously via a call to
*       glBindTexture.
*
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of image units supported by the implementation.
* @errors GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object.
* @errors GL_INVALID_OPERATION error is generated if the internal format of the level zero texture image of any texture in textures
*         is not supported.
* @errors GL_INVALID_OPERATION error is generated if the width, height, or depth of the level zero texture image of any texture in
*         textures is zero.
*
*/
#define glBindImageTextures glad_glBindImageTextures
GLAD_API_CALL PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;
/**
* @name glBindProgramPipeline - bind a program pipeline to the current context
* @usage
* @code void glBindProgramPipeline(GLuint pipeline); @endcode
* @param pipeline Specifies the name of the pipeline object to bind to the context.
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not zero or a name previously returned from a call to glGenProgramPipelines
*         or if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glBindProgramPipeline glad_glBindProgramPipeline
GLAD_API_CALL PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
/**
* @name glBindRenderbuffer - bind a renderbuffer to a renderbuffer target
* @usage
* @code void glBindRenderbuffer(GLenum target, GLuint renderbuffer); @endcode
* @param target Specifies the renderbuffer target of the binding operation. <em class="parameter"><b>target</b></em> must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object to bind.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated if renderbuffer is not zero or the name of a renderbuffer previously returned from a call
*         to glGenRenderbuffers.
*
*/
#define glBindRenderbuffer glad_glBindRenderbuffer
GLAD_API_CALL PFNGLBINDSAMPLERPROC glad_glBindSampler;
/**
* @name glBindSampler - bind a named sampler to a texturing target
* @usage
* @code void glBindSampler(GLuint unit, GLuint sampler); @endcode
* @param unit Specifies the index of the texture unit to which the sampler is bound.
* @param sampler Specifies the name of a sampler.
* @note glBindSampler is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if unit is greater than or equal to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS.
* @errors GL_INVALID_OPERATION is generated if sampler is not zero or a name previously returned from a call to glGenSamplers, or
*         if such a name has been deleted by a call to glDeleteSamplers.
*
*/
#define glBindSampler glad_glBindSampler
GLAD_API_CALL PFNGLBINDSAMPLERSPROC glad_glBindSamplers;
/**
* @name glBindSamplers - bind one or more named sampler objects to a sequence of consecutive sampler units
* @usage
* @code void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers); @endcode
* @param first Specifies the first sampler unit to which a sampler object is to be bound.
* @param count Specifies the number of samplers to bind.
* @param samplers Specifies the address of an array of names of existing sampler objects.
* @note glBindSamplers is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of sampler units supported by the implementation.
* @errors GL_INVALID_OPERATION is generated if any value in samplers is not zero or the name of an existing sampler object.
*
*/
#define glBindSamplers glad_glBindSamplers
GLAD_API_CALL PFNGLBINDTEXTUREPROC glad_glBindTexture;
/**
* @name glBindTexture - bind a named texture to a texturing target
* @usage
* @code void glBindTexture(GLenum target, GLuint texture); @endcode
* @param target Specifies the target to which the texture is bound. Must be one of <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_BUFFER</b>, <b>GL_TEXTURE_2D_MULTISAMPLE</b> or <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param texture Specifies the name of a texture.
* @note The GL_TEXTURE_2D_MULTISAMPLE and GL_TEXTURE_2D_MULTISAMPLE_ARRAY targets are available only if the GL version is 3.2 or
*       higher.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if texture is not a name returned from a previous call to glGenTextures.
* @errors GL_INVALID_OPERATION is generated if texture was previously created with a target that doesn't match that of target.
*
*/
#define glBindTexture glad_glBindTexture
GLAD_API_CALL PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;
/**
* @name glBindTextureUnit - bind an existing texture object to the specified texture unit
* @usage
* @code void glBindTextureUnit(GLuint unit, GLuint texture); @endcode
* @param unit Specifies the texture unit, to which the texture object should be bound to.
* @param texture Specifies the name of a texture.
*
* @errors GL_INVALID_OPERATION error is generated if texture is not zero or the name of an existing texture object.
*
*/
#define glBindTextureUnit glad_glBindTextureUnit
GLAD_API_CALL PFNGLBINDTEXTURESPROC glad_glBindTextures;
/**
* @name glBindTextures - bind one or more named textures to a sequence of consecutive texture units
* @usage
* @code void glBindTextures(GLuint first, GLsizei count, const GLuint *textures); @endcode
* @param first Specifies the first texture unit to which a texture is to be bound.
* @param count Specifies the number of textures to bind.
* @param textures Specifies the address of an array of names of existing texture objects.
* @note glBindTextures is available only if the GL version is 4.4 or higher.
* @note Note that because glBindTextures cannot create new textures (even if a name passed has been previously generated by call
*       to glGenTextures), names passed to glBindTextures must have been bound at least once previously via a call to glBindTexture.
*
* @errors GL_INVALID_OPERATION is generated if first + count is greater than the number of texture image units supported by the implementation.
* @errors GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object.
*
*/
#define glBindTextures glad_glBindTextures
GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;
/**
* @name glBindTransformFeedback - bind a transform feedback object
* @usage
* @code void glBindTransformFeedback(GLenum target, GLuint id); @endcode
* @param target Specifies the target to which to bind the transform feedback object <em class="parameter"><b>id</b></em>. <em class="parameter"><b>target</b></em>
*               must be <b>GL_TRANSFORM_FEEDBACK</b>.
* @param id Specifies the name of a transform feedback object reserved by <a class="citerefentry" href="glGenTransformFeedbacks. xhtml"><span
*           class="citerefentry"><span class="refentrytitle">glGenTransformFeedbacks</span></span></a>.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TRANSFORM_FEEDBACK.
* @errors GL_INVALID_OPERATION is generated if the transform feedback operation is active on the currently bound transform feedback
*         object, and that operation is not paused.
* @errors GL_INVALID_OPERATION is generated if id is not zero or the name of a transform feedback object returned from a previous
*         call to glGenTransformFeedbacks, or if such a name has been deleted by glDeleteTransformFeedbacks.
*
*/
#define glBindTransformFeedback glad_glBindTransformFeedback
GLAD_API_CALL PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
/**
* @name glBindVertexArray - bind a vertex array object
* @usage
* @code void glBindVertexArray(GLuint array); @endcode
* @param array Specifies the name of the vertex array to bind.
*
* @errors GL_INVALID_OPERATION is generated if array is not zero or the name of a vertex array object previously returned from a call
*         to glGenVertexArrays.
*
*/
#define glBindVertexArray glad_glBindVertexArray
GLAD_API_CALL PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;
/**
* @name glBindVertexBuffer, glVertexArrayVertexBuffer - bind a buffer to a vertex buffer bind point
* @usage
* @code void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @code void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @param vaobj Specifies the name of the vertex array object to be used by <b>glVertexArrayVertexBuffer</b> function.
* @param bindingindex The index of the vertex buffer binding point to which to bind the buffer.
* @param buffer The name of a buffer to bind to the vertex buffer binding point.
* @param offset The offset of the first element of the buffer.
* @param stride The distance between elements within the buffer.
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffer if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffer if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_VALUE is generated if offset or stride is less than zero, or if stride is greater than the value of GL_MAX_VERTEX_ATTRIB_STRIDE.
* @errors GL_INVALID_VALUE is generated if buffer is not zero or the name of an existing buffer object (as returned by glGenBuffers
*         or glCreateBuffers).
*
*/
#define glBindVertexBuffer glad_glBindVertexBuffer
GLAD_API_CALL PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;
/**
* @name glBindVertexBuffers, glVertexArrayVertexBuffers - attach multiple buffer objects to a vertex array object
* @usage
* @code void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @code void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayVertexBuffers</b>.
* @param first Specifies the first vertex buffer binding point to which a buffer object is to be bound.
* @param count Specifies the number of buffers to bind.
* @param buffers Specifies the address of an array of names of existing buffer objects.
* @param offsets Specifies the address of an array of offsets to associate with the binding points.
* @param strides Specifies the address of an array of strides to associate with the binding points.
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffers if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffers if vaobj is not the name of the vertex array object.
* @errors GL_INVALID_OPERATION is generated if $first + count$ is greater than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if any value in offsets or strides is negative, or if a value is stride is greater than the
*         value of GL_MAX_VERTEX_ATTRIB_STRIDE.
*
*/
#define glBindVertexBuffers glad_glBindVertexBuffers
GLAD_API_CALL PFNGLBLENDCOLORPROC glad_glBlendColor;
/**
* @name glBlendColor - set the blend color
* @usage
* @code void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); @endcode
* @param red, green, blue, alpha specify the components of <b>GL_BLEND_COLOR</b>
* @note The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent
*       to user code and is described in detail on the removedTypes page.
*
*
*/
#define glBlendColor glad_glBlendColor
GLAD_API_CALL PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
/**
* @name glBlendEquation - specify the equation used for both the RGB blend equation and the Alpha blend equation
* @usage
* @code void glBlendEquation(GLenum mode); @endcode
* @code void glBlendEquationi(GLuint buf, GLenum mode); @endcode
* @param buf for <b>glBlendEquationi</b>, specifies the index of the draw buffer for which to set the blend equation.
* @param mode specifies how source and destination colors are combined. It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>,
*             <b>GL_MIN</b>, <b>GL_MAX</b>.
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquation glad_glBlendEquation
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
/**
* @name glBlendEquationSeparate - set the RGB blend equation and the alpha blend equation separately
* @usage
* @code void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha); @endcode
* @code void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha); @endcode
* @param buf for <b>glBlendEquationSeparatei</b>, specifies the index of the draw buffer for which to set the blend equations.
* @param modeRGB specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
*                It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @param modeAlpha specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be
*                  <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT,
*         GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquationSeparate glad_glBlendEquationSeparate
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;
/**
* @name glBlendEquationSeparate - set the RGB blend equation and the alpha blend equation separately
* @usage
* @code void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha); @endcode
* @code void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha); @endcode
* @param buf for <b>glBlendEquationSeparatei</b>, specifies the index of the draw buffer for which to set the blend equations.
* @param modeRGB specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
*                It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @param modeAlpha specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be
*                  <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b>, <b>GL_MAX</b>.
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT,
*         GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquationSeparatei glad_glBlendEquationSeparatei
GLAD_API_CALL PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;
/**
* @name glBlendEquation - specify the equation used for both the RGB blend equation and the Alpha blend equation
* @usage
* @code void glBlendEquation(GLenum mode); @endcode
* @code void glBlendEquationi(GLuint buf, GLenum mode); @endcode
* @param buf for <b>glBlendEquationi</b>, specifies the index of the draw buffer for which to set the blend equation.
* @param mode specifies how source and destination colors are combined. It must be <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>,
*             <b>GL_MIN</b>, <b>GL_MAX</b>.
* @note The GL_MIN, and GL_MAX equations do not use the source or destination factors, only the source and destination colors.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN.
* @errors GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendEquationi glad_glBlendEquationi
GLAD_API_CALL PFNGLBLENDFUNCPROC glad_glBlendFunc;
/**
* @name glBlendFunc - specify pixel arithmetic
* @usage
* @code void glBlendFunc(GLenum sfactor, GLenum dfactor); @endcode
* @code void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor); @endcode
* @param buf For <b>glBlendFunci</b>, specifies the index of the draw buffer for which to set the blend function.
* @param sfactor Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dfactor Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants
*                are accepted: <b>GL_ZERO</b>, <b>GL_ONE</b>, <b>GL_SRC_COLOR</b>, <b>GL_ONE_MINUS_SRC_COLOR</b>, <b>GL_DST_COLOR</b>,
*                <b>GL_ONE_MINUS_DST_COLOR</b>, <b>GL_SRC_ALPHA</b>, <b>GL_ONE_MINUS_SRC_ALPHA</b>, <b>GL_DST_ALPHA</b>, <b>GL_ONE_MINUS_DST_ALPHA</b>.
*                <b>GL_CONSTANT_COLOR</b>, <b>GL_ONE_MINUS_CONSTANT_COLOR</b>, <b>GL_CONSTANT_ALPHA</b>, and <b>GL_ONE_MINUS_CONSTANT_ALPHA</b>.
*                The initial value is <b>GL_ZERO</b>.
* @note Incoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFunc glad_glBlendFunc
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
/**
* @name glBlendFuncSeparate - specify pixel arithmetic for RGB and alpha components separately
* @usage
* @code void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @code void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @param buf For <b>glBlendFuncSeparatei</b>, specifies the index of the draw buffer for which to set the blend functions.
* @param srcRGB Specifies how the red, green, and blue blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dstRGB Specifies how the red, green, and blue destination blending factors are computed. The initial value is <b>GL_ZERO</b>.
* @param srcAlpha Specified how the alpha source blending factor is computed. The initial value is <b>GL_ONE</b>.
* @param dstAlpha Specified how the alpha destination blending factor is computed. The initial value is <b>GL_ZERO</b>.
* @note Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFuncSeparate glad_glBlendFuncSeparate
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;
/**
* @name glBlendFuncSeparate - specify pixel arithmetic for RGB and alpha components separately
* @usage
* @code void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @code void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); @endcode
* @param buf For <b>glBlendFuncSeparatei</b>, specifies the index of the draw buffer for which to set the blend functions.
* @param srcRGB Specifies how the red, green, and blue blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dstRGB Specifies how the red, green, and blue destination blending factors are computed. The initial value is <b>GL_ZERO</b>.
* @param srcAlpha Specified how the alpha source blending factor is computed. The initial value is <b>GL_ONE</b>.
* @param dstAlpha Specified how the alpha destination blending factor is computed. The initial value is <b>GL_ZERO</b>.
* @note Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFuncSeparatei glad_glBlendFuncSeparatei
GLAD_API_CALL PFNGLBLENDFUNCIPROC glad_glBlendFunci;
/**
* @name glBlendFunc - specify pixel arithmetic
* @usage
* @code void glBlendFunc(GLenum sfactor, GLenum dfactor); @endcode
* @code void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor); @endcode
* @param buf For <b>glBlendFunci</b>, specifies the index of the draw buffer for which to set the blend function.
* @param sfactor Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is <b>GL_ONE</b>.
* @param dfactor Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants
*                are accepted: <b>GL_ZERO</b>, <b>GL_ONE</b>, <b>GL_SRC_COLOR</b>, <b>GL_ONE_MINUS_SRC_COLOR</b>, <b>GL_DST_COLOR</b>,
*                <b>GL_ONE_MINUS_DST_COLOR</b>, <b>GL_SRC_ALPHA</b>, <b>GL_ONE_MINUS_SRC_ALPHA</b>, <b>GL_DST_ALPHA</b>, <b>GL_ONE_MINUS_DST_ALPHA</b>.
*                <b>GL_CONSTANT_COLOR</b>, <b>GL_ONE_MINUS_CONSTANT_COLOR</b>, <b>GL_CONSTANT_ALPHA</b>, and <b>GL_ONE_MINUS_CONSTANT_ALPHA</b>.
*                The initial value is <b>GL_ZERO</b>.
* @note Incoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (KA ), representing complete opacity,
*       to 0.0 (0), representing complete transparency.
* @note When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using
*       the contents of that buffer for destination color. (See glDrawBuffer.)
* @note When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum
*       number of enabled draw buffers is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may be lower than GL_MAX_DRAW_BUFFERS.
*
* @errors GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
*
*/
#define glBlendFunci glad_glBlendFunci
GLAD_API_CALL PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
/**
* @name glBlitFramebuffer, glBlitNamedFramebuffer - copy a block of pixels from one framebuffer object to another
* @usage
* @code void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @code void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @param readFramebuffer Specifies the name of the source framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param drawFramebuffer Specifies the name of the destination framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param srcX0, srcY0, srcX1, srcY1 Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
* @param dstX0, dstY0, dstX1, dstY1 Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
* @param mask The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are <b>GL_COLOR_BUFFER_BIT</b>,
*             <b>GL_DEPTH_BUFFER_BIT</b> and <b>GL_STENCIL_BUFFER_BIT</b>.
* @param filter Specifies the interpolation to be applied if the image is stretched. Must be <b>GL_NEAREST</b> or <b>GL_LINEAR</b>.
*
* @errors GL_INVALID_OPERATION is generated by BlitNamedFramebuffer if readFramebuffer or drawFramebuffer is not zero or the name
*         of an existing framebuffer object.
* @errors GL_INVALID_OPERATION is generated if mask contains any of the GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and filter is
*         not GL_NEAREST.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT and any of the following conditions hold:
* @errors The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point
*         values.
* @errors The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.
* @errors The read buffer contains signed integer values and any draw buffer does not contain signed integer values.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and the source and destination
*         depth and stencil formats do not match.
* @errors GL_INVALID_OPERATION is generated if filter is GL_LINEAR and the read buffer contains integer data.
* @errors GL_INVALID_OPERATION is generated if both the read and draw framebuffers are multisampled, and their effective values of
*         GL_SAMPLES are not identical.
* @errors GL_INVALID_OPERATION is generated if the value of GL_SAMPLE_BUFFERS for either read or draw buffers is greater than zero
*         and the dimensions of the source and destination rectangles is not identical.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the specified read and draw framebuffers are not framebuffer complete.
*
*/
#define glBlitFramebuffer glad_glBlitFramebuffer
GLAD_API_CALL PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;
/**
* @name glBlitFramebuffer, glBlitNamedFramebuffer - copy a block of pixels from one framebuffer object to another
* @usage
* @code void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @code void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); @endcode
* @param readFramebuffer Specifies the name of the source framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param drawFramebuffer Specifies the name of the destination framebuffer object for <b>glBlitNamedFramebuffer</b>.
* @param srcX0, srcY0, srcX1, srcY1 Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
* @param dstX0, dstY0, dstX1, dstY1 Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
* @param mask The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are <b>GL_COLOR_BUFFER_BIT</b>,
*             <b>GL_DEPTH_BUFFER_BIT</b> and <b>GL_STENCIL_BUFFER_BIT</b>.
* @param filter Specifies the interpolation to be applied if the image is stretched. Must be <b>GL_NEAREST</b> or <b>GL_LINEAR</b>.
*
* @errors GL_INVALID_OPERATION is generated by BlitNamedFramebuffer if readFramebuffer or drawFramebuffer is not zero or the name
*         of an existing framebuffer object.
* @errors GL_INVALID_OPERATION is generated if mask contains any of the GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and filter is
*         not GL_NEAREST.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT and any of the following conditions hold:
* @errors The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point
*         values.
* @errors The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.
* @errors The read buffer contains signed integer values and any draw buffer does not contain signed integer values.
* @errors GL_INVALID_OPERATION is generated if mask contains GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and the source and destination
*         depth and stencil formats do not match.
* @errors GL_INVALID_OPERATION is generated if filter is GL_LINEAR and the read buffer contains integer data.
* @errors GL_INVALID_OPERATION is generated if both the read and draw framebuffers are multisampled, and their effective values of
*         GL_SAMPLES are not identical.
* @errors GL_INVALID_OPERATION is generated if the value of GL_SAMPLE_BUFFERS for either read or draw buffers is greater than zero
*         and the dimensions of the source and destination rectangles is not identical.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the specified read and draw framebuffers are not framebuffer complete.
*
*/
#define glBlitNamedFramebuffer glad_glBlitNamedFramebuffer
GLAD_API_CALL PFNGLBUFFERDATAPROC glad_glBufferData;
/**
* @name glBufferData, glNamedBufferData - creates and initializes a buffer object's data
store
* @usage
* @code void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage); @endcode
* @code void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferData</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param usage Specifies the expected usage pattern of the data store. The symbolic constant must be <b>GL_STREAM_DRAW</b>, <b>GL_STREAM_READ</b>,
*              <b>GL_STREAM_COPY</b>, <b>GL_STATIC_DRAW</b>, <b>GL_STATIC_READ</b>, <b>GL_STATIC_COPY</b>, <b>GL_DYNAMIC_DRAW</b>,
*              <b>GL_DYNAMIC_READ</b>, or <b>GL_DYNAMIC_COPY</b>.
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
* @note Clients must align data elements consistently with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ,
*         GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
* @errors GL_INVALID_VALUE is generated if size is negative.
* @errors GL_INVALID_OPERATION is generated by glBufferData if the reserved buffer object name 0 is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size.
*
*/
#define glBufferData glad_glBufferData
GLAD_API_CALL PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;
/**
* @name glBufferStorage, glNamedBufferStorage - creates and initializes a buffer object's immutable data
store
* @usage
* @code void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags); @endcode
* @code void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferStorage</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferStorage</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param flags Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. <b>GL_DYNAMIC_STORAGE_BIT</b>,
*              <b>GL_MAP_READ_BIT</b>
<b>GL_MAP_WRITE_BIT</b>, <b>GL_MAP_PERSISTENT_BIT</b>, <b>GL_MAP_COHERENT_BIT</b>,
*              and <b>GL_CLIENT_STORAGE_BIT</b>.
* @note glBufferStorage is available only if the GL version is 4.4 or greater.
* @note glNamedBufferStorage is available only if the GL version is 4.5 or greater.
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
*
* @errors GL_INVALID_ENUM is generated by glBufferStorage if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferStorage if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if size is less than or equal to zero.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the reserved buffer object name 0 is bound to target.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the properties requested in flags.
* @errors GL_INVALID_VALUE is generated if flags has any bits set other than those defined above.
* @errors GL_INVALID_VALUE error is generated if flags contains GL_MAP_PERSISTENT_BIT but does not contain at least one of GL_MAP_READ_BIT
*         or GL_MAP_WRITE_BIT.
* @errors GL_INVALID_VALUE is generated if flags contains GL_MAP_COHERENT_BIT, but does not also contain GL_MAP_PERSISTENT_BIT.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer bound to target
*         is GL_TRUE.
*
*/
#define glBufferStorage glad_glBufferStorage
GLAD_API_CALL PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
/**
* @name glBufferSubData, glNamedBufferSubData - updates a subset of a buffer object's data store
* @usage
* @code void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data); @endcode
* @code void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferSubData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
* @param size Specifies the size in bytes of the data store region being replaced.
* @param data Specifies a pointer to the new data that will be copied into the data store.
* @note When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with
*       glBufferData. This avoids the cost of reallocating the data store.
* @note Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering
*       in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific
*       region being updated, that rendering must drain from the pipeline before the data store can be updated.
* @note Clients must align data elements consistent with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferSubData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the specified buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and
*         the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set.
*
*/
#define glBufferSubData glad_glBufferSubData
GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
/**
* @name glCheckFramebufferStatus, glCheckNamedFramebufferStatus - check the completeness status of a framebuffer
* @usage
* @code GLenum glCheckFramebufferStatus(GLenum target); @endcode
* @code GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target); @endcode
* @param target Specify the target to which the framebuffer is bound for <b>glCheckFramebufferStatus</b>, and the target against which framebuffer
*               completeness of <em class="parameter"><b>framebuffer</b></em> is checked for <b>glCheckNamedFramebufferStatus</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glCheckNamedFramebufferStatus</b>
*
* @errors GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
* @errors GL_INVALID_OPERATION is generated by glCheckNamedFramebufferStatus if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glCheckFramebufferStatus glad_glCheckFramebufferStatus
GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;
/**
* @name glCheckFramebufferStatus, glCheckNamedFramebufferStatus - check the completeness status of a framebuffer
* @usage
* @code GLenum glCheckFramebufferStatus(GLenum target); @endcode
* @code GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target); @endcode
* @param target Specify the target to which the framebuffer is bound for <b>glCheckFramebufferStatus</b>, and the target against which framebuffer
*               completeness of <em class="parameter"><b>framebuffer</b></em> is checked for <b>glCheckNamedFramebufferStatus</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glCheckNamedFramebufferStatus</b>
*
* @errors GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
* @errors GL_INVALID_OPERATION is generated by glCheckNamedFramebufferStatus if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glCheckNamedFramebufferStatus glad_glCheckNamedFramebufferStatus
GLAD_API_CALL PFNGLCLAMPCOLORPROC glad_glClampColor;
/**
* @name glClampColor - specify whether data read via glReadPixels should be clamped
* @usage
* @code void glClampColor(GLenum target, GLenum clamp); @endcode
* @param target Target for color clamping. <em class="parameter"><b>target</b></em> must be <b>GL_CLAMP_READ_COLOR</b>.
* @param clamp Specifies whether to apply color clamping. <em class="parameter"><b>clamp</b></em> must be <b>GL_TRUE</b> or <b>GL_FALSE</b>.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_CLAMP_READ_COLOR.
* @errors GL_INVALID_ENUM is generated if clamp is not GL_TRUE or GL_FALSE.
*
*/
#define glClampColor glad_glClampColor
GLAD_API_CALL PFNGLCLEARPROC glad_glClear;
/**
* @name glClear - clear buffers to preset values
* @usage
* @code void glClear(GLbitfield mask); @endcode
* @param mask Bitwise OR of masks that indicate the buffers to be cleared. The three masks are <b>GL_COLOR_BUFFER_BIT</b>, <b>GL_DEPTH_BUFFER_BIT</b>,
*             and <b>GL_STENCIL_BUFFER_BIT</b>.
* @note If a buffer is not present, then a glClear directed at that buffer has no effect.
*
* @errors GL_INVALID_VALUE is generated if any bit other than the three defined bits is set in mask.
*
*/
#define glClear glad_glClear
GLAD_API_CALL PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;
/**
* @name glClearBufferData, glClearNamedBufferData - fill a buffer object's data store with a fixed value
* @usage
* @code void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
*
* @errors GL_INVALID_ENUM is generated by glClearBufferData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferData if no buffer is bound target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearBufferData glad_glClearBufferData
GLAD_API_CALL PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;
/**
* @name glClearBufferSubData, glClearNamedBufferSubData - fill all or part of buffer object's data store with a fixed value
* @usage
* @code void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferSubData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param offset The offset in basic machine units into the buffer object's data store at which to start filling.
* @param size The size in basic machine units of the range of the data store to fill.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
*
* @errors GL_INVALID_ENUM is generated by glClearBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferSubData if no buffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_VALUE is generated if offset or range are not multiples of the number of basic machine units per-element for
*         the internal format specified by internalformat. This value may be computed by multiplying the number of components for
*         internalformat from the table by the size of the base type from the table.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearBufferSubData glad_glClearBufferSubData
GLAD_API_CALL PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
// Unable to find the docs for this function!
#define glClearBufferfi glad_glClearBufferfi
GLAD_API_CALL PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
// Unable to find the docs for this function!
#define glClearBufferfv glad_glClearBufferfv
GLAD_API_CALL PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
// Unable to find the docs for this function!
#define glClearBufferiv glad_glClearBufferiv
GLAD_API_CALL PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
// Unable to find the docs for this function!
#define glClearBufferuiv glad_glClearBufferuiv
GLAD_API_CALL PFNGLCLEARCOLORPROC glad_glClearColor;
/**
* @name glClearColor - specify clear values for the color buffers
* @usage
* @code void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); @endcode
* @param red, green, blue, alpha Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
* @note The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent
*       to user code and is described in detail on the removedTypes page.
*
*
*/
#define glClearColor glad_glClearColor
GLAD_API_CALL PFNGLCLEARDEPTHPROC glad_glClearDepth;
/**
* @name glClearDepth - specify the clear value for the depth buffer
* @usage
* @code void glClearDepth(GLdouble depth); @endcode
* @code void glClearDepthf(GLfloat depth); @endcode
* @param depth Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
* @note The type of the depth parameter was changed from GLclampf to GLfloat for glClearDepthf and from GLclampd to GLdouble for
*       glClearDepth. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glClearDepth glad_glClearDepth
GLAD_API_CALL PFNGLCLEARDEPTHFPROC glad_glClearDepthf;
/**
* @name glClearDepth - specify the clear value for the depth buffer
* @usage
* @code void glClearDepth(GLdouble depth); @endcode
* @code void glClearDepthf(GLfloat depth); @endcode
* @param depth Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
* @note The type of the depth parameter was changed from GLclampf to GLfloat for glClearDepthf and from GLclampd to GLdouble for
*       glClearDepth. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glClearDepthf glad_glClearDepthf
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;
/**
* @name glClearBufferData, glClearNamedBufferData - fill a buffer object's data store with a fixed value
* @usage
* @code void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
*
* @errors GL_INVALID_ENUM is generated by glClearBufferData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferData if no buffer is bound target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearNamedBufferData glad_glClearNamedBufferData
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;
/**
* @name glClearBufferSubData, glClearNamedBufferSubData - fill all or part of buffer object's data store with a fixed value
* @usage
* @code void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data); @endcode
* @code void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glClearBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glClearNamedBufferSubData</b>.
* @param internalformat The internal format with which the data will be stored in the buffer object.
* @param offset The offset in basic machine units into the buffer object's data store at which to start filling.
* @param size The size in basic machine units of the range of the data store to fill.
* @param format The format of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param type The type of the data in memory addressed by <em class="parameter"><b>data</b></em>.
* @param data The address of a memory location storing the data to be replicated into the buffer's data store.
*
* @errors GL_INVALID_ENUM is generated by glClearBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_VALUE is generated by glClearBufferSubData if no buffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glClearNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the valid sized internal formats listed in the table above.
* @errors GL_INVALID_VALUE is generated if offset or range are not multiples of the number of basic machine units per-element for
*         the internal format specified by internalformat. This value may be computed by multiplying the number of components for
*         internalformat from the table by the size of the base type from the table.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_VALUE is generated if format is not a valid format, or type is not a valid type.
*
*/
#define glClearNamedBufferSubData glad_glClearNamedBufferSubData
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;
// Unable to find the docs for this function!
#define glClearNamedFramebufferfi glad_glClearNamedFramebufferfi
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;
// Unable to find the docs for this function!
#define glClearNamedFramebufferfv glad_glClearNamedFramebufferfv
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;
// Unable to find the docs for this function!
#define glClearNamedFramebufferiv glad_glClearNamedFramebufferiv
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;
// Unable to find the docs for this function!
#define glClearNamedFramebufferuiv glad_glClearNamedFramebufferuiv
GLAD_API_CALL PFNGLCLEARSTENCILPROC glad_glClearStencil;
/**
* @name glClearStencil - specify the clear value for the stencil buffer
* @usage
* @code void glClearStencil(GLint s); @endcode
* @param s Specifies the index used when the stencil buffer is cleared. The initial value is 0.
*
*
*/
#define glClearStencil glad_glClearStencil
GLAD_API_CALL PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;
/**
* @name glClearTexImage - fills all a texture image with a constant value
* @usage
* @code void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data); @endcode
* @param texture The name of an existing texture object containing the image to be cleared.
* @param level The level of <em class="parameter"><b>texture</b></em> containing the region to be cleared.
* @param format The format of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param type The type of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param data The address in memory of the data to be used to clear the specified region.
* @note glClearTexImage is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if texture is a buffer texture.
* @errors GL_INVALID_OPERATION is generated if texture has a compressed internal format.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX,
*         or GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data.
* @errors GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data.
* @errors GL_INVALID_OPERATION is generated if the image array identified by level has not previously been defined by a call to glTexImage*
*         or glTexStorage*.
*
*/
#define glClearTexImage glad_glClearTexImage
GLAD_API_CALL PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;
/**
* @name glClearTexSubImage - fills all or part of a texture image with a constant value
* @usage
* @code void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data); @endcode
* @param texture The name of an existing texture object containing the image to be cleared.
* @param level The level of <em class="parameter"><b>texture</b></em> containing the region to be cleared.
* @param xoffset The coordinate of the left edge of the region to be cleared.
* @param yoffset The coordinate of the lower edge of the region to be cleared.
* @param zoffset The coordinate of the front of the region to be cleared.
* @param width The width of the region to be cleared.
* @param height The height of the region to be cleared.
* @param depth The depth of the region to be cleared.
* @param format The format of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param type The type of the data whose address in memory is given by <em class="parameter"><b>data</b></em>.
* @param data The address in memory of the data to be used to clear the specified region.
* @note glClearTexSubImage is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if texture is a buffer texture.
* @errors GL_INVALID_OPERATION is generated if texture has a compressed internal format.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX,
*         or GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data.
* @errors GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data.
* @errors GL_INVALID_OPERATION error is generated if the xoffset, yoffset, zoffset, width, height, and depth parameters (or combinations
*         thereof) specify a region that falls outside the defined texture image array (including border, if any).
*
*/
#define glClearTexSubImage glad_glClearTexSubImage
GLAD_API_CALL PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
/**
* @name glClientWaitSync - block and wait for a sync object to become signaled
* @usage
* @code GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout); @endcode
* @param sync The sync object whose status to wait on.
* @param flags A bitfield controlling the command flushing behavior. <em class="parameter"><b>flags</b></em> may be <b>GL_SYNC_FLUSH_COMMANDS_BIT</b>.
* @param timeout The timeout, specified in nanoseconds, for which the implementation should wait for <em class="parameter"><b>sync</b></em>
*                to become signaled.
* @note glClientWaitSync is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_VALUE is generated if sync is not the name of an existing sync object.
* @errors GL_INVALID_VALUE is generated if flags contains any unsupported flag.
*
*/
#define glClientWaitSync glad_glClientWaitSync
GLAD_API_CALL PFNGLCLIPCONTROLPROC glad_glClipControl;
/**
* @name glClipControl - control clip coordinate to window coordinate behavior
* @usage
* @code void glClipControl(GLenum origin, GLenum depth); @endcode
* @param origin Specifies the clip control origin. Must be one of <b>GL_LOWER_LEFT</b> or <b>GL_UPPER_LEFT</b>.
* @param depth Specifies the clip control depth mode. Must be one of <b>GL_NEGATIVE_ONE_TO_ONE</b> or <b>GL_ZERO_TO_ONE</b>.
* @note The default GL clip volume definition is for a origin of GL_LOWER_LEFT and a depth of GL_NEGATIVE_ONE_TO_ONE.
* @note An origin of GL_UPPER_LEFT and a depth of GL_ZERO_TO_ONE corresponds to Direct3D's clip volume definition.
* @note An origin of GL_UPPER_LEFT and a depth of GL_NEGATIVE_ONE_TO_ONE corresponds to the upper-left origin of the window coordinate
*       system of Microsoft Windows and the X Window System.
* @note There is extensive discussion of the uses and further consequences of the different clip volume settings in the GL_ARB_clip_control
*       extension specification in the OpenGL Registry at URL http://www.opengl.org/registry/.
*
* @errors An GL_INVALID_ENUM error is generated if origin is not GL_LOWER_LEFT or GL_UPPER_LEFT.
* @errors An GL_INVALID_ENUM error is generated if depth is not GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE.
*
*/
#define glClipControl glad_glClipControl
GLAD_API_CALL PFNGLCOLORMASKPROC glad_glColorMask;
/**
* @name glColorMask, glColorMaski - enable and disable writing of frame buffer color components
* @usage
* @code void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); @endcode
* @param buf For <b>glColorMaski</b>, specifies the index of the draw buffer whose color mask to set.
* @param red, green, blue, alpha Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all <b>GL_TRUE</b>,
*                                indicating that the color components are written.
*
*
*/
#define glColorMask glad_glColorMask
GLAD_API_CALL PFNGLCOLORMASKIPROC glad_glColorMaski;
// Unable to find the docs for this function!
#define glColorMaski glad_glColorMaski
GLAD_API_CALL PFNGLCOMPILESHADERPROC glad_glCompileShader;
/**
* @name glCompileShader - Compiles a shader object
* @usage
* @code void glCompileShader(GLuint shader); @endcode
* @param shader Specifies the shader object to be compiled.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
*
*/
#define glCompileShader glad_glCompileShader
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
/**
* @name glCompressedTexImage1D - specify a one-dimensional texture image in a compressed format
* @usage
* @code void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_1D</b> or <b>GL_PROXY_TEXTURE_1D</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param width Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The
*              height of the 1D texture image is 1.
* @param border This value must be 0.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is not a supported specific compressed internal formats, or is one of the
*         generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB,
*         or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexImage1D glad_glCompressedTexImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
/**
* @name glCompressedTexImage2D - specify a two-dimensional texture image in a compressed format
* @usage
* @code void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param width Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at
*              least 16384 texels wide.
* @param height Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at
*               least 16384 texels high.
* @param border This value must be 0.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
* @note The specific compressed internal formats GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
*       GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
*       GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, and GL_COMPRESSED_SIGNED_RG11_EAC
*       are available only if the GL version is 4.3 or higher.
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the specific compressed internal formats: GL_COMPRESSED_RED_RGTC1,
*         GL_COMPRESSED_SIGNED_RED_RGTC1, GL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2. GL_COMPRESSED_RGBA_BPTC_UNORM,
*         GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, GL_COMPRESSED_RGB8_ETC2,
*         GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
*         GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC,
*         GL_COMPRESSED_RG11_EAC, or GL_COMPRESSED_SIGNED_RG11_EAC.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexImage2D glad_glCompressedTexImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
/**
* @name glCompressedTexImage3D - specify a three-dimensional texture image in a compressed format
* @usage
* @code void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_TEXTURE_2D_ARRAY</b> or <b>GL_PROXY_TEXTURE_2D_ARRAY</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param width Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
* @param height Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
* @param depth Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
* @param border This value must be 0.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED,
*         GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexImage3D glad_glCompressedTexImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
/**
* @name glCompressedTexSubImage1D, glCompressedTextureSubImage1D - specify a one-dimensional texture subimage in a compressed
format
* @usage
* @code void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target, to which the texture is bound, for <b>glCompressedTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED,
*         GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage1D function if texture is not the name of an existing texture
*         object.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexSubImage1D glad_glCompressedTexSubImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
/**
* @name glCompressedTexSubImage2D, glCompressedTextureSubImage2D - specify a two-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, or <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage2D if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if the effective target is GL_TEXTURE_RECTANGLE.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexSubImage2D glad_glCompressedTexSubImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
/**
* @name glCompressedTexSubImage3D, glCompressedTextureSubImage3D - specify a three-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage3D</b> function. Must be <b>GL_TEXTURE_2D_ARRAY</b>,
*               <b>GL_TEXTURE_3D</b>, or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage3D if target is not GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTexSubImage3D glad_glCompressedTexSubImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;
/**
* @name glCompressedTexSubImage1D, glCompressedTextureSubImage1D - specify a one-dimensional texture subimage in a compressed
format
* @usage
* @code void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target, to which the texture is bound, for <b>glCompressedTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED,
*         GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage1D function if texture is not the name of an existing texture
*         object.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTextureSubImage1D glad_glCompressedTextureSubImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;
/**
* @name glCompressedTexSubImage2D, glCompressedTextureSubImage2D - specify a two-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, or <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage2D if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage2D if the effective target is GL_TEXTURE_RECTANGLE.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTextureSubImage2D glad_glCompressedTextureSubImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;
/**
* @name glCompressedTexSubImage3D, glCompressedTextureSubImage3D - specify a three-dimensional texture subimage in a compressed format
* @usage
* @code void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data); @endcode
* @code void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data); @endcode
* @param target Specifies the target to which the texture is bound for <b>glCompressedTexSubImage3D</b> function. Must be <b>GL_TEXTURE_2D_ARRAY</b>,
*               <b>GL_TEXTURE_3D</b>, or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCompressedTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the compressed image data stored at address <em class="parameter"><b>data</b></em>.
* @param imageSize Specifies the number of unsigned bytes of image data starting at the address specified by <em class="parameter"><b>data</b></em>.
* @param data Specifies a pointer to the compressed image data in memory.
*
* @errors GL_INVALID_ENUM is generated if internalformat is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG,
*         GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA.
* @errors GL_INVALID_ENUM is generated by glCompressedTexSubImage3D if target is not GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCompressedTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified
*         compressed image data.
* @errors GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format
*         as specified in the specific texture compression extension.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with
*         the extension specification defining the internal compression format.
*
*/
#define glCompressedTextureSubImage3D glad_glCompressedTextureSubImage3D
GLAD_API_CALL PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
/**
* @name glCopyBufferSubData, glCopyNamedBufferSubData - copy all or part of the data store of a buffer object to the data store of another buffer object
* @usage
* @code void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @code void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @param readTarget Specifies the target to which the source buffer object is bound for <b>glCopyBufferSubData</b>
* @param writeTarget Specifies the target to which the destination buffer object is bound for <b>glCopyBufferSubData</b>.
* @param readBuffer Specifies the name of the source buffer object for <b>glCopyNamedBufferSubData</b>.
* @param writeBuffer Specifies the name of the destination buffer object for <b>glCopyNamedBufferSubData</b>.
* @param readOffset Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
* @param writeOffset Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will
*                    be written.
* @param size Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer
*             object.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glCopyBufferSubData if readTarget or writeTarget is not one of the buffer binding targets
*         listed above.
* @errors GL_INVALID_OPERATION is generated by glCopyBufferSubData if zero is bound to readTarget or writeTarget.
* @errors GL_INVALID_OPERATION is generated by glCopyNamedBufferSubData if readBuffer or writeBuffer is not the name of an existing
*         buffer object.
* @errors GL_INVALID_VALUE is generated if any of readOffset, writeOffset or size is negative, if $readOffset + size$ is greater than
*         the size of the source buffer object (its value of GL_BUFFER_SIZE), or if $writeOffset + size$ is greater than the size
*         of the destination buffer object.
* @errors GL_INVALID_VALUE is generated if the source and destination are the same buffer object, and the ranges $[readOffset,readOffset+size)$
*         and $[writeOffset,writeOffset+size)$ overlap.
* @errors GL_INVALID_OPERATION is generated if either the source or destination buffer object is mapped with glMapBufferRange or glMapBuffer,
*         unless they were mapped with the GL_MAP_PERSISTENT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glCopyBufferSubData glad_glCopyBufferSubData
GLAD_API_CALL PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;
/**
* @name glCopyImageSubData - perform a raw data copy between two images
* @usage
* @code void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth); @endcode
* @param srcName The name of a texture or renderbuffer object from which to copy.
* @param srcTarget The target representing the namespace of the source name <em class="parameter"><b>srcName</b></em>.
* @param srcLevel The mipmap level to read from the source.
* @param srcX The X coordinate of the left edge of the souce region to copy.
* @param srcY The Y coordinate of the top edge of the souce region to copy.
* @param srcZ The Z coordinate of the near edge of the souce region to copy.
* @param dstName The name of a texture or renderbuffer object to which to copy.
* @param dstTarget The target representing the namespace of the destination name <em class="parameter"><b>dstName</b></em>.
* @param dstX The X coordinate of the left edge of the destination region.
* @param dstY The Y coordinate of the top edge of the destination region.
* @param dstZ The Z coordinate of the near edge of the destination region.
* @param srcWidth The width of the region to be copied.
* @param srcHeight The height of the region to be copied.
* @param srcDepth The depth of the region to be copied.
*
* @errors GL_INVALID_OPERATION is generated if the texel size of the uncompressed image is not equal to the block size of the compressed
*         image.
* @errors GL_INVALID_ENUM is generated if either target parameter is not GL_RENDERBUFFER, a valid non-proxy texture target other than
*         GL_TEXTURE_BUFFER, or is one of the cubemap face selectors.
* @errors GL_INVALID_ENUM is generated if target does not match the type of the object.
* @errors GL_INVALID_OPERATION is generated if either object is a texture and the texture is not complete.
* @errors GL_INVALID_OPERATION is generated if the source and destination internal formats are not compatible, or if the number of
*         samples do not match.
* @errors GL_INVALID_VALUE is generated if either name does not correspond to a valid renderbuffer or texture object according to
*         the corresponding target parameter.
* @errors GL_INVALID_VALUE is generated if the specified level of either the source or destination is not a valid level for the corresponding
*         image.
* @errors GL_INVALID_VALUE is generated if the dimensions of the either subregion exceeds the boundaries of the corresponding image
*         object, or if the image format is compressed and the dimensions of the subregion fail to meet the alignment constraints
*         of the format.
*
*/
#define glCopyImageSubData glad_glCopyImageSubData
GLAD_API_CALL PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;
/**
* @name glCopyBufferSubData, glCopyNamedBufferSubData - copy all or part of the data store of a buffer object to the data store of another buffer object
* @usage
* @code void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @code void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); @endcode
* @param readTarget Specifies the target to which the source buffer object is bound for <b>glCopyBufferSubData</b>
* @param writeTarget Specifies the target to which the destination buffer object is bound for <b>glCopyBufferSubData</b>.
* @param readBuffer Specifies the name of the source buffer object for <b>glCopyNamedBufferSubData</b>.
* @param writeBuffer Specifies the name of the destination buffer object for <b>glCopyNamedBufferSubData</b>.
* @param readOffset Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
* @param writeOffset Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will
*                    be written.
* @param size Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer
*             object.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glCopyBufferSubData if readTarget or writeTarget is not one of the buffer binding targets
*         listed above.
* @errors GL_INVALID_OPERATION is generated by glCopyBufferSubData if zero is bound to readTarget or writeTarget.
* @errors GL_INVALID_OPERATION is generated by glCopyNamedBufferSubData if readBuffer or writeBuffer is not the name of an existing
*         buffer object.
* @errors GL_INVALID_VALUE is generated if any of readOffset, writeOffset or size is negative, if $readOffset + size$ is greater than
*         the size of the source buffer object (its value of GL_BUFFER_SIZE), or if $writeOffset + size$ is greater than the size
*         of the destination buffer object.
* @errors GL_INVALID_VALUE is generated if the source and destination are the same buffer object, and the ranges $[readOffset,readOffset+size)$
*         and $[writeOffset,writeOffset+size)$ overlap.
* @errors GL_INVALID_OPERATION is generated if either the source or destination buffer object is mapped with glMapBufferRange or glMapBuffer,
*         unless they were mapped with the GL_MAP_PERSISTENT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glCopyNamedBufferSubData glad_glCopyNamedBufferSubData
GLAD_API_CALL PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
/**
* @name glCopyTexImage1D - copy pixels into a 1D texture image
* @usage
* @code void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_1D</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: <b>GL_COMPRESSED_RED</b>,
*                       <b>GL_COMPRESSED_RG</b>, <b>GL_COMPRESSED_RGB</b>, <b>GL_COMPRESSED_RGBA</b>. <b>GL_COMPRESSED_SRGB</b>, <b>GL_COMPRESSED_SRGB_ALPHA</b>.
*                       <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>, <b>GL_DEPTH_COMPONENT24</b>, <b>GL_DEPTH_COMPONENT32</b>,
*                       <b>GL_STENCIL_INDEX8</b>, <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_R3_G3_B2</b>, <b>GL_RGB4</b>, <b>GL_RGB5</b>,
*                       <b>GL_RGB8</b>, <b>GL_RGB10</b>, <b>GL_RGB12</b>, <b>GL_RGB16</b>, <b>GL_RGBA</b>, <b>GL_RGBA2</b>, <b>GL_RGBA4</b>,
*                       <b>GL_RGB5_A1</b>, <b>GL_RGBA8</b>, <b>GL_RGB10_A2</b>, <b>GL_RGBA12</b>, <b>GL_RGBA16</b>, <b>GL_SRGB</b>,
*                       <b>GL_SRGB8</b>, <b>GL_SRGB_ALPHA</b>, or <b>GL_SRGB8_ALPHA8</b>.
* @param x, y Specify the window coordinates of the left corner of the row of pixels to be copied.
* @param width Specifies the width of the texture image. The height of the texture image is 1.
* @param border Must be 0.
* @note 1, 2, 3, and 4 are not accepted values for internalformat.
* @note An image with 0 width indicates a NULL texture.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁢max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not an allowable value.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32 and there is no depth buffer.
*
*/
#define glCopyTexImage1D glad_glCopyTexImage1D
GLAD_API_CALL PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
/**
* @name glCopyTexImage2D - copy pixels into a 2D texture image
* @usage
* @code void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               or <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: <b>GL_COMPRESSED_RED</b>,
*                       <b>GL_COMPRESSED_RG</b>, <b>GL_COMPRESSED_RGB</b>, <b>GL_COMPRESSED_RGBA</b>. <b>GL_COMPRESSED_SRGB</b>, <b>GL_COMPRESSED_SRGB_ALPHA</b>.
*                       <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>, <b>GL_DEPTH_COMPONENT24</b>, <b>GL_DEPTH_COMPONENT32</b>,
*                       <b>GL_STENCIL_INDEX8</b>, <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_R3_G3_B2</b>, <b>GL_RGB4</b>, <b>GL_RGB5</b>,
*                       <b>GL_RGB8</b>, <b>GL_RGB10</b>, <b>GL_RGB12</b>, <b>GL_RGB16</b>, <b>GL_RGBA</b>, <b>GL_RGBA2</b>, <b>GL_RGBA4</b>,
*                       <b>GL_RGB5_A1</b>, <b>GL_RGBA8</b>, <b>GL_RGB10_A2</b>, <b>GL_RGBA12</b>, <b>GL_RGBA16</b>, <b>GL_SRGB</b>,
*                       <b>GL_SRGB8</b>, <b>GL_SRGB_ALPHA</b>, or <b>GL_SRGB8_ALPHA8</b>.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture image.
* @param height Specifies the height of the texture image.
* @param border Must be 0.
* @note 1, 2, 3, and 4 are not accepted values for internalformat.
* @note An image with height or width of 0 indicates a NULL texture.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁢max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_VALUE is generated if internalformat is not an accepted format.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32 and there is no depth buffer.
*
*/
#define glCopyTexImage2D glad_glCopyTexImage2D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
/**
* @name glCopyTexSubImage1D, glCopyTextureSubImage1D - copy a one-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @code void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies the texel offset within the texture array.
* @param x, y Specify the window coordinates of the left corner of the row of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @note The glPixelStore mode affects texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage1D if target is not GL_TEXTURE_1D.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage1D if texture is not the name of an existing texture object, or
*         if the effective target of texture is not GL_TEXTURE_1D.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D, glCopyTexImage1D,
*         or glTexStorage1D operation.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , or xoffset+width >w , where w is the GL_TEXTURE_WIDTH of the texture image
*         being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTexSubImage1D glad_glCopyTexSubImage1D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
/**
* @name glCopyTexSubImage2D, glCopyTextureSubImage2D - copy a two-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               or <b>GL_TEXTURE_RECTANGLE</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
*         GL_TEXTURE_1D_ARRAY or GL_RECTANGLE.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D, glTexStorage2D or
*         glCopyTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if the effective target of texture does not correspond to one
*         of the texture targets supported by the function.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE is generated if the effective target is GL_TEXTURE_RECTANGLE and level is not zero.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 ,  xoffset+width >w , yoffset<0 , or yoffset+height >h , where w is the GL_TEXTURE_WIDTH
*         and h is the GL_TEXTURE_HEIGHT of the texture image being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTexSubImage2D glad_glCopyTexSubImage2D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
/**
* @name glCopyTexSubImage3D, glCopyTextureSubImage3D - copy a three-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage3D</b> function. Must be <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b> or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage3D if target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if the effective target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY,
*         GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_CUBE_MAP.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_3D_TEXTURE_SIZE if target
*         is GL_TEXTURE_3D or the returned value of GL_MAX_ARRAY_TEXTURE_LAYERS if target is GL_TEXTURE_2D_ARRAY.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , xoffset+width >w , yoffset<0 , yoffset+height >h , zoffset<0 , or zoffset+1
*         >d , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and of the texture image being
*         modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTexSubImage3D glad_glCopyTexSubImage3D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;
/**
* @name glCopyTexSubImage1D, glCopyTextureSubImage1D - copy a one-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @code void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage1D</b> function. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage1D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies the texel offset within the texture array.
* @param x, y Specify the window coordinates of the left corner of the row of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @note The glPixelStore mode affects texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage1D if target is not GL_TEXTURE_1D.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage1D if texture is not the name of an existing texture object, or
*         if the effective target of texture is not GL_TEXTURE_1D.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D, glCopyTexImage1D,
*         or glTexStorage1D operation.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , or xoffset+width >w , where w is the GL_TEXTURE_WIDTH of the texture image
*         being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTextureSubImage1D glad_glCopyTextureSubImage1D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;
/**
* @name glCopyTexSubImage2D, glCopyTextureSubImage2D - copy a two-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage2D</b> function. Must be <b>GL_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               or <b>GL_TEXTURE_RECTANGLE</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage2D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
*         GL_TEXTURE_1D_ARRAY or GL_RECTANGLE.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D, glTexStorage2D or
*         glCopyTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage2D if the effective target of texture does not correspond to one
*         of the texture targets supported by the function.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE is generated if the effective target is GL_TEXTURE_RECTANGLE and level is not zero.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset<0 ,  xoffset+width >w , yoffset<0 , or yoffset+height >h , where w is the GL_TEXTURE_WIDTH
*         and h is the GL_TEXTURE_HEIGHT of the texture image being modified.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTextureSubImage2D glad_glCopyTextureSubImage2D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;
/**
* @name glCopyTexSubImage3D, glCopyTextureSubImage3D - copy a three-dimensional texture subimage
* @usage
* @code void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @code void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glCopyTexSubImage3D</b> function. Must be <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b> or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glCopyTextureSubImage3D</b> function.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param x, y Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @note glPixelStore modes affect texture images.
*
* @errors GL_INVALID_ENUM is generated by glCopyTexSubImage3D if target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if the effective target is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY,
*         GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_CUBE_MAP.
* @errors GL_INVALID_FRAMEBUFFER_OPERATION is generated if the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated by glCopyTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level> log2 ⁡ max , where max is the returned value of GL_MAX_3D_TEXTURE_SIZE if target
*         is GL_TEXTURE_3D or the returned value of GL_MAX_ARRAY_TEXTURE_LAYERS if target is GL_TEXTURE_2D_ARRAY.
* @errors GL_INVALID_VALUE is generated if xoffset<0 , xoffset+width >w , yoffset<0 , yoffset+height >h , zoffset<0 , or zoffset+1
*         >d , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and of the texture image being
*         modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_OPERATION is generated if:
* @errors the read buffer is GL_NONE, or
* @errors the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
* @errors the read buffer selects an attachment that has no image attached, or
* @errors the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.
*
*/
#define glCopyTextureSubImage3D glad_glCopyTextureSubImage3D
GLAD_API_CALL PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;
/**
* @name glCreateBuffers - create buffer objects
* @usage
* @code void glCreateBuffers(GLsizei n, GLuint *buffers); @endcode
* @param n Specifies the number of buffer objects to create.
* @param buffers Specifies an array in which names of the new buffer objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateBuffers glad_glCreateBuffers
GLAD_API_CALL PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;
/**
* @name glCreateFramebuffers - create framebuffer objects
* @usage
* @code void glCreateFramebuffers(GLsizei n, GLuint *framebuffers); @endcode
* @param n Number of framebuffer objects to create.
* @param framebuffers Specifies an array in which names of the new framebuffer objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateFramebuffers glad_glCreateFramebuffers
GLAD_API_CALL PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
/**
* @name glCreateProgram - Creates a program object
* @usage
* @code GLuint glCreateProgram(void); @endcode
* @note Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the
*       server sides of the contexts share the same address space. If the name space is shared across contexts, any attached
*       objects and the data associated with those attached objects are shared as well.
* @note Applications are responsible for providing the synchronization across API calls when objects are accessed from different
*       execution threads.
*
* @errors This function returns 0 if an error occurs creating the program object.
*
*/
#define glCreateProgram glad_glCreateProgram
GLAD_API_CALL PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;
/**
* @name glCreateProgramPipelines - create program pipeline objects
* @usage
* @code void glCreateProgramPipelines(GLsizei n, GLuint *pipelines); @endcode
* @param n Number of program pipeline objects to create.
* @param pipelines Specifies an array in which names of the new program pipeline objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateProgramPipelines glad_glCreateProgramPipelines
GLAD_API_CALL PFNGLCREATEQUERIESPROC glad_glCreateQueries;
/**
* @name glCreateQueries - create query objects
* @usage
* @code void glCreateQueries(GLenum target, GLsizei n, GLuint *ids); @endcode
* @param target Specifies the target of each created query object.
* @param n Number of query objects to create.
* @param ids Specifies an array in which names of the new query objects are stored.
*
* @errors GL_INVALID_ENUM is generated if target is not an accepted value.
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateQueries glad_glCreateQueries
GLAD_API_CALL PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;
/**
* @name glCreateRenderbuffers - create renderbuffer objects
* @usage
* @code void glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers); @endcode
* @param n Number of renderbuffer objects to create.
* @param renderbuffers Specifies an array in which names of the new renderbuffer objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateRenderbuffers glad_glCreateRenderbuffers
GLAD_API_CALL PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;
/**
* @name glCreateSamplers - create sampler objects
* @usage
* @code void glCreateSamplers(GLsizei n, GLuint *samplers); @endcode
* @param n Number of sampler objects to create.
* @param samplers Specifies an array in which names of the new sampler objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateSamplers glad_glCreateSamplers
GLAD_API_CALL PFNGLCREATESHADERPROC glad_glCreateShader;
/**
* @name glCreateShader - Creates a shader object
* @usage
* @code GLuint glCreateShader(GLenum shaderType); @endcode
* @param shaderType Specifies the type of shader to be created. Must be one of <b>GL_COMPUTE_SHADER</b>, <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>,
*                   <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>, or <b>GL_FRAGMENT_SHADER</b>.
* @note Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the
*       server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects
*       and the data associated with those attached objects are shared as well.
* @note Applications are responsible for providing the synchronization across API calls when objects are accessed from different
*       execution threads.
* @note GL_COMPUTE_SHADER is available only if the GL version is 4.3 or higher.
*
* @errors This function returns 0 if an error occurs creating the shader object.
* @errors GL_INVALID_ENUM is generated if shaderType is not an accepted value.
*
*/
#define glCreateShader glad_glCreateShader
GLAD_API_CALL PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;
// Unable to find the docs for this function!
#define glCreateShaderProgramv glad_glCreateShaderProgramv
GLAD_API_CALL PFNGLCREATETEXTURESPROC glad_glCreateTextures;
/**
* @name glCreateTextures - create texture objects
* @usage
* @code void glCreateTextures(GLenum target, GLsizei n, GLuint *textures); @endcode
* @param target Specifies the effective texture target of each created texture.
* @param n Number of texture objects to create.
* @param textures Specifies an array in which names of the new texture objects are stored.
*
* @errors GL_INVALID_ENUM is generated if target is not one of the allowable values.
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateTextures glad_glCreateTextures
GLAD_API_CALL PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;
/**
* @name glCreateTransformFeedbacks - create transform feedback objects
* @usage
* @code void glCreateTransformFeedbacks(GLsizei n, GLuint *ids); @endcode
* @param n Number of transform feedback objects to create.
* @param ids Specifies an array in which names of the new transform feedback objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateTransformFeedbacks glad_glCreateTransformFeedbacks
GLAD_API_CALL PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;
/**
* @name glCreateVertexArrays - create vertex array objects
* @usage
* @code void glCreateVertexArrays(GLsizei n, GLuint *arrays); @endcode
* @param n Number of vertex array objects to create.
* @param arrays Specifies an array in which names of the new vertex array objects are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glCreateVertexArrays glad_glCreateVertexArrays
GLAD_API_CALL PFNGLCULLFACEPROC glad_glCullFace;
/**
* @name glCullFace - specify whether front- or back-facing facets can be culled
* @usage
* @code void glCullFace(GLenum mode); @endcode
* @param mode Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants <b>GL_FRONT</b>, <b>GL_BACK</b>,
*             and <b>GL_FRONT_AND_BACK</b> are accepted. The initial value is <b>GL_BACK</b>.
* @note If mode is GL_FRONT_AND_BACK, no facets are drawn, but other primitives such as points and lines are drawn.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
*
*/
#define glCullFace glad_glCullFace
GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;
/**
* @name glDebugMessageCallback - specify a callback to receive debugging messages from the GL
* @usage
* @code void glDebugMessageCallback(DEBUGPROC callback, const void * userParam); @endcode
* @param callback The address of a callback function that will be called when a debug message is generated.
* @param userParam A user supplied pointer that will be passed on each invocation of <em class="parameter"><b>callback</b></em>.
* @note When the GL is in use remotely, the server may not be able to call functions in the client's address space. In such cases,
*       the callback function may not be invoked and the user should retrieve debug messages from the context's debug message
*       log by calling glGetDebugMessageLog.
*
*
*/
#define glDebugMessageCallback glad_glDebugMessageCallback
GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;
/**
* @name glDebugMessageControl - control the reporting of debug messages in a debug context
* @usage
* @code void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled); @endcode
* @param source The source of debug messages to enable or disable.
* @param type The type of debug messages to enable or disable.
* @param severity The severity of debug messages to enable or disable.
* @param count The length of the array <em class="parameter"><b>ids</b></em>.
* @param ids The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
* @param enabled A Boolean flag determining whether the selected messages should be enabled or disabled.
* @note Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially
*       inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug
*       context may produce no messages at all.
* @note GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, and GL_DEBUG_SEVERITY_NOTIFICATION are available
*       only if the GL version is 4.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types.
* @errors GL_INVALID_OPERATION is generated if count is non-zero and either source or type is GL_DONT_CARE or if severity is not GL_DONT_CARE.
*
*/
#define glDebugMessageControl glad_glDebugMessageControl
GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;
/**
* @name glDebugMessageInsert - inject an application-supplied message into the debug message queue
* @usage
* @code void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message); @endcode
* @param source The source of the debug message to insert.
* @param type The type of the debug message insert.
* @param id The user-supplied identifier of the message to insert.
* @param severity The severity of the debug messages to insert.
* @param length The length string contained in the character array whose address is given by <em class="parameter"><b>message</b></em>.
* @param message The address of a character array containing the message to insert.
* @note GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, and GL_DEBUG_SEVERITY_NOTIFICATION are available
*       only if the GL version is 4.3 or higher.
*
* @errors GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types.
* @errors GL_INVALID_VALUE is generated if the length of the message is greater than the value of GL_MAX_DEBUG_MESSAGE_LENGTH.
*
*/
#define glDebugMessageInsert glad_glDebugMessageInsert
GLAD_API_CALL PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
/**
* @name glDeleteBuffers - delete named buffer objects
* @usage
* @code void glDeleteBuffers(GLsizei n, const GLuint * buffers); @endcode
* @param n Specifies the number of buffer objects to be deleted.
* @param buffers Specifies an array of buffer objects to be deleted.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteBuffers glad_glDeleteBuffers
GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
/**
* @name glDeleteFramebuffers - delete framebuffer objects
* @usage
* @code void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers); @endcode
* @param n Specifies the number of framebuffer objects to be deleted.
* @param framebuffers A pointer to an array containing <em class="parameter"><b>n</b></em> framebuffer objects to be deleted.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteFramebuffers glad_glDeleteFramebuffers
GLAD_API_CALL PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
/**
* @name glDeleteProgram - Deletes a program object
* @usage
* @code void glDeleteProgram(GLuint program); @endcode
* @param program Specifies the program object to be deleted.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
*
*/
#define glDeleteProgram glad_glDeleteProgram
GLAD_API_CALL PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;
/**
* @name glDeleteProgramPipelines - delete program pipeline objects
* @usage
* @code void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines); @endcode
* @param n Specifies the number of program pipeline objects to delete.
* @param pipelines Specifies an array of names of program pipeline objects to delete.
*
*
*/
#define glDeleteProgramPipelines glad_glDeleteProgramPipelines
GLAD_API_CALL PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
/**
* @name glDeleteQueries - delete named query objects
* @usage
* @code void glDeleteQueries(GLsizei n, const GLuint * ids); @endcode
* @param n Specifies the number of query objects to be deleted.
* @param ids Specifies an array of query objects to be deleted.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteQueries glad_glDeleteQueries
GLAD_API_CALL PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
/**
* @name glDeleteRenderbuffers - delete renderbuffer objects
* @usage
* @code void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers); @endcode
* @param n Specifies the number of renderbuffer objects to be deleted.
* @param renderbuffers A pointer to an array containing <em class="parameter"><b>n</b></em> renderbuffer objects to be deleted.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteRenderbuffers glad_glDeleteRenderbuffers
GLAD_API_CALL PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
/**
* @name glDeleteSamplers - delete named sampler objects
* @usage
* @code void glDeleteSamplers(GLsizei n, const GLuint * samplers); @endcode
* @param n Specifies the number of sampler objects to be deleted.
* @param samplers Specifies an array of sampler objects to be deleted.
* @note glDeleteSamplers is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteSamplers glad_glDeleteSamplers
GLAD_API_CALL PFNGLDELETESHADERPROC glad_glDeleteShader;
/**
* @name glDeleteShader - Deletes a shader object
* @usage
* @code void glDeleteShader(GLuint shader); @endcode
* @param shader Specifies the shader object to be deleted.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
*
*/
#define glDeleteShader glad_glDeleteShader
GLAD_API_CALL PFNGLDELETESYNCPROC glad_glDeleteSync;
/**
* @name glDeleteSync - delete a sync object
* @usage
* @code void glDeleteSync(GLsync sync); @endcode
* @param sync The sync object to be deleted.
* @note glSync is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is supported.
*
* @errors GL_INVALID_VALUE is generated if sync is neither zero or the name of a sync object.
*
*/
#define glDeleteSync glad_glDeleteSync
GLAD_API_CALL PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
/**
* @name glDeleteTextures - delete named textures
* @usage
* @code void glDeleteTextures(GLsizei n, const GLuint * textures); @endcode
* @param n Specifies the number of textures to be deleted.
* @param textures Specifies an array of textures to be deleted.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteTextures glad_glDeleteTextures
GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;
/**
* @name glDeleteTransformFeedbacks - delete transform feedback objects
* @usage
* @code void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids); @endcode
* @param n Specifies the number of transform feedback objects to delete.
* @param ids Specifies an array of names of transform feedback objects to delete.
*
*
*/
#define glDeleteTransformFeedbacks glad_glDeleteTransformFeedbacks
GLAD_API_CALL PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
/**
* @name glDeleteVertexArrays - delete vertex array objects
* @usage
* @code void glDeleteVertexArrays(GLsizei n, const GLuint *arrays); @endcode
* @param n Specifies the number of vertex array objects to be deleted.
* @param arrays Specifies the address of an array containing the <em class="parameter"><b>n</b></em> names of the objects to be deleted.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glDeleteVertexArrays glad_glDeleteVertexArrays
GLAD_API_CALL PFNGLDEPTHFUNCPROC glad_glDepthFunc;
/**
* @name glDepthFunc - specify the value used for depth buffer comparisons
* @usage
* @code void glDepthFunc(GLenum func); @endcode
* @param func Specifies the depth comparison function. Symbolic constants <b>GL_NEVER</b>, <b>GL_LESS</b>, <b>GL_EQUAL</b>, <b>GL_LEQUAL</b>,
*             <b>GL_GREATER</b>, <b>GL_NOTEQUAL</b>, <b>GL_GEQUAL</b>, and <b>GL_ALWAYS</b> are accepted. The initial value is
*             <b>GL_LESS</b>.
* @note Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled.
*       In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS.
*
* @errors GL_INVALID_ENUM is generated if func is not an accepted value.
*
*/
#define glDepthFunc glad_glDepthFunc
GLAD_API_CALL PFNGLDEPTHMASKPROC glad_glDepthMask;
/**
* @name glDepthMask - enable or disable writing into the depth buffer
* @usage
* @code void glDepthMask(GLboolean flag); @endcode
* @param flag Specifies whether the depth buffer is enabled for writing. If <em class="parameter"><b>flag</b></em> is <b>GL_FALSE</b>,
*             depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
* @note Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled.
*       In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS (see
*       glDepthFunc).
*
*
*/
#define glDepthMask glad_glDepthMask
GLAD_API_CALL PFNGLDEPTHRANGEPROC glad_glDepthRange;
/**
* @name glDepthRange - specify mapping of depth values from normalized device coordinates to window coordinates
* @usage
* @code void glDepthRange(GLdouble nearVal, GLdouble farVal); @endcode
* @code void glDepthRangef(GLfloat nearVal, GLfloat farVal); @endcode
* @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
* @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
* @note It is not necessary that nearVal be less than farVal. Reverse mappings such as nearVal=1 , and farVal=0 are acceptable.
* @note The type of the nearVal and farVal parameters was changed from GLclampf to GLfloat for glDepthRangef and from GLclampd to
*       GLdouble for glDepthRange. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glDepthRange glad_glDepthRange
GLAD_API_CALL PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;
// Unable to find the docs for this function!
#define glDepthRangeArrayv glad_glDepthRangeArrayv
GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;
/**
* @name glDepthRangeIndexed - specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
* @usage
* @code void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal); @endcode
* @param index Specifies the index of the viewport whose depth range to update.
* @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
* @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
* @note It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as nearVal=1
*       , and farVal=0 are acceptable.
* @note The type of the nearVal and farVal parameters was changed from GLclampd to GLdouble. This change is transparent to user
*       code and is described in detail on the removedTypes page.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS.
*
*/
#define glDepthRangeIndexed glad_glDepthRangeIndexed
GLAD_API_CALL PFNGLDEPTHRANGEFPROC glad_glDepthRangef;
/**
* @name glDepthRange - specify mapping of depth values from normalized device coordinates to window coordinates
* @usage
* @code void glDepthRange(GLdouble nearVal, GLdouble farVal); @endcode
* @code void glDepthRangef(GLfloat nearVal, GLfloat farVal); @endcode
* @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
* @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
* @note It is not necessary that nearVal be less than farVal. Reverse mappings such as nearVal=1 , and farVal=0 are acceptable.
* @note The type of the nearVal and farVal parameters was changed from GLclampf to GLfloat for glDepthRangef and from GLclampd to
*       GLdouble for glDepthRange. This change is transparent to user code and is described in detail on the removedTypes page.
*
*
*/
#define glDepthRangef glad_glDepthRangef
GLAD_API_CALL PFNGLDETACHSHADERPROC glad_glDetachShader;
/**
* @name glDetachShader - Detaches a shader object from a program object to which it is attached
* @usage
* @code void glDetachShader(GLuint program, GLuint shader); @endcode
* @param program Specifies the program object from which to detach the shader object.
* @param shader Specifies the shader object to be detached.
*
* @errors GL_INVALID_VALUE is generated if either program or shader is a value that was not generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_OPERATION is generated if shader is not attached to program.
*
glAttachShader
*/
#define glDetachShader glad_glDetachShader
GLAD_API_CALL PFNGLDISABLEPROC glad_glDisable;
// Unable to find the docs for this function!
#define glDisable glad_glDisable
GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glDisableVertexArrayAttrib glad_glDisableVertexArrayAttrib
GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glDisableVertexAttribArray glad_glDisableVertexAttribArray
GLAD_API_CALL PFNGLDISABLEIPROC glad_glDisablei;
// Unable to find the docs for this function!
#define glDisablei glad_glDisablei
GLAD_API_CALL PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;
/**
* @name glDispatchCompute - launch one or more compute work groups
* @usage
* @code void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z); @endcode
* @param num_groups_x The number of work groups to be launched in the X dimension.
* @param num_groups_y The number of work groups to be launched in the Y dimension.
* @param num_groups_z The number of work groups to be launched in the Z dimension.
*
* @errors GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage.
* @errors GL_INVALID_VALUE is generated if any of num_groups_x, num_groups_y, or num_groups_z is greater than or equal to the maximum
*         work-group count for the corresponding dimension.
*
*/
#define glDispatchCompute glad_glDispatchCompute
GLAD_API_CALL PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;
/**
* @name glDispatchComputeIndirect - launch one or more compute work groups using parameters stored in a buffer
* @usage
* @code void glDispatchComputeIndirect(GLintptr indirect); @endcode
* @param indirect The offset into the buffer object currently bound to the <b>GL_DISPATCH_INDIRECT_BUFFER</b> buffer target at which the dispatch
*                 parameters are stored.
*
* @errors GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage.
* @errors GL_INVALID_VALUE is generated if indirect is less than zero or not a multiple of four.
* @errors GL_INVALID_OPERATION is generated if no buffer is bound to the GL_DISPATCH_INDIRECT_BUFFER target or if the command would
*         source data beyond the end of the buffer object's data store.
*
*/
#define glDispatchComputeIndirect glad_glDispatchComputeIndirect
GLAD_API_CALL PFNGLDRAWARRAYSPROC glad_glDrawArrays;
/**
* @name glDrawArrays - render primitives from array data
* @usage
* @code void glDrawArrays(GLenum mode, GLint first, GLsizei count); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param first Specifies the starting index in the enabled arrays.
* @param count Specifies the number of indices to be rendered.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
*
*/
#define glDrawArrays glad_glDrawArrays
GLAD_API_CALL PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;
/**
* @name glDrawArraysIndirect - render primitives from array data, taking parameters from memory
* @usage
* @code void glDrawArraysIndirect(GLenum mode, const void *indirect); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param indirect Specifies the address of a structure containing the draw parameters.
* @note The baseInstance member of the DrawArraysIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions
*       of the GL, behavior is undefined if it is non-zero.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glDrawArraysIndirect glad_glDrawArraysIndirect
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
/**
* @name glDrawArraysInstanced - draw multiple instances of a range of elements
* @usage
* @code void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>
<b>GL_LINES_ADJACENCY</b>, <b>GL_LINE_STRIP_ADJACENCY</b>,
*             <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b> are
*             accepted.
* @param first Specifies the starting index in the enabled arrays.
* @param count Specifies the number of indices to be rendered.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the accepted values.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawArraysInstanced glad_glDrawArraysInstanced
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;
/**
* @name glDrawArraysInstancedBaseInstance - draw multiple instances of a range of elements with offset applied to instanced attributes
* @usage
* @code void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>
<b>GL_LINES_ADJACENCY</b>, <b>GL_LINE_STRIP_ADJACENCY</b>,
*             <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b> are
*             accepted.
* @param first Specifies the starting index in the enabled arrays.
* @param count Specifies the number of indices to be rendered.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the accepted values.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawArraysInstancedBaseInstance glad_glDrawArraysInstancedBaseInstance
GLAD_API_CALL PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
/**
* @name glDrawBuffer, glNamedFramebufferDrawBuffer - specify which color buffers are to be drawn into
* @usage
* @code void glDrawBuffer(GLenum buf); @endcode
* @code void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffer</b> function. Must be zero or the name
*                    of a framebuffer object.
* @param buf For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants <b>GL_NONE</b>,
*            <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>, <b>GL_FRONT</b>, <b>GL_BACK</b>,
*            <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and <b>GL_FRONT_AND_BACK</b> are accepted. The initial value is <b>GL_FRONT</b>
*            for single-buffered contexts, and <b>GL_BACK</b> for double-buffered contexts. For framebuffer objects, <b>GL_COLOR_ATTACHMENT$m$</b>
*            and <b>GL_NONE</b> enums are accepted, where <b>$m$</b> is a value between 0 and <b>GL_MAX_COLOR_ATTACHMENTS</b>.
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if buf is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if the default framebuffer is affected and none of the buffers indicated by buf exists.
* @errors GL_INVALID_OPERATION is generated if a framebuffer object is affected and buf is not equal to GL_NONE or GL_COLOR_ATTACHMENT$m$,
*         where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glDrawBuffer glad_glDrawBuffer
GLAD_API_CALL PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
/**
* @name glDrawBuffers, glNamedFramebufferDrawBuffers - Specifies a list of color buffers to be drawn
into
* @usage
* @code void glDrawBuffers(GLsizei n, const GLenum *bufs); @endcode
* @code void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffers</b>.
* @param n Specifies the number of buffers in <em class="parameter"><b>bufs</b></em>.
* @param bufs Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
* @note The symbolic constants GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are not allowed in the bufs array since
*       they may refer to multiple buffers.
* @note If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader
*       execution are undefined. For each fragment generated in this situation, a different value may be written into each of
*       the buffers specified by bufs.
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffers if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if one of the values in bufs is not an accepted value.
* @errors GL_INVALID_ENUM is generated if the API call refers to the default framebuffer and one or more of the values in bufs is
*         one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if the API call refers to a framebuffer object and one or more of the values in bufs is anything
*         other than GL_NONE or one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if n is less than 0.
* @errors GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
* @errors GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does
*         not exist in the current GL context.
* @errors GL_INVALID_OPERATION is generated if any value in bufs is GL_BACK, and n is not one.
* @errors GL_INVALID_VALUE is generated if n is greater than GL_MAX_DRAW_BUFFERS.
*
*/
#define glDrawBuffers glad_glDrawBuffers
GLAD_API_CALL PFNGLDRAWELEMENTSPROC glad_glDrawElements;
/**
* @name glDrawElements - render primitives from array data
* @usage
* @code void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElements glad_glDrawElements
GLAD_API_CALL PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
/**
* @name glDrawElementsBaseVertex - render primitives from array data with a per-element offset
* @usage
* @code void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @note glDrawElementsBaseVertex is only supported if the GL version is 3.2 or greater, or if the ARB_draw_elements_base_vertex
*       extension is supported.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElementsBaseVertex glad_glDrawElementsBaseVertex
GLAD_API_CALL PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;
/**
* @name glDrawElementsIndirect - render indexed primitives from array data, taking parameters from memory
* @usage
* @code void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param type Specifies the type of data in the buffer bound to the <b>GL_ELEMENT_ARRAY_BUFFER</b> binding.
* @param indirect Specifies the address of a structure containing the draw parameters.
* @note The baseInstance member of the DrawElementsIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier
*       versions of the GL, behavior is undefined if it is non-zero.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glDrawElementsIndirect glad_glDrawElementsIndirect
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
/**
* @name glDrawElementsInstanced - draw multiple instances of a set of elements
* @usage
* @code void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @note glDrawElementsInstanced is available only if the GL version is 3.1 or greater.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP,
*         GL_TRIANGLE_FAN, or GL_TRIANGLES.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawElementsInstanced glad_glDrawElementsInstanced
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;
/**
* @name glDrawElementsInstancedBaseInstance - draw multiple instances of a set of elements with offset applied to instanced attributes
* @usage
* @code void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the specified range of indices to be rendered.
* @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.
* @note glDrawElementsInstancedBaseInstance is available only if the GL version is 4.2 or greater.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP,
*         GL_TRIANGLE_FAN, or GL_TRIANGLES.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glDrawElementsInstancedBaseInstance glad_glDrawElementsInstancedBaseInstance
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
/**
* @name glDrawElementsInstancedBaseVertex - render multiple instances of a set of primitives from array data with a per-element offset
* @usage
* @code void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the indexed geometry that should be drawn.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @note glDrawElementsInstancedBaseVertex is only supported if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElementsInstancedBaseVertex glad_glDrawElementsInstancedBaseVertex
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;
/**
* @name glDrawElementsInstancedBaseVertexBaseInstance - render multiple instances of a set of primitives from array data with a per-element offset
* @usage
* @code void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param instancecount Specifies the number of instances of the indexed geometry that should be drawn.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
* @param baseinstance Specifies the base instance for use in fetching instanced vertex attributes.
* @note glDrawElementsInstancedBaseVertex is only supported if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count or instancecount is negative.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawElementsInstancedBaseVertexBaseInstance glad_glDrawElementsInstancedBaseVertexBaseInstance
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
/**
* @name glDrawRangeElements - render primitives from array data
* @usage
* @code void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param start Specifies the minimum array index contained in <em class="parameter"><b>indices</b></em>.
* @param end Specifies the maximum array index contained in <em class="parameter"><b>indices</b></em>.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors It is an error for indices to lie outside the range startend , but implementations may not check for this situation. Such
*         indices cause implementation-dependent behavior.
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_VALUE is generated if end<start .
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawRangeElements glad_glDrawRangeElements
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
/**
* @name glDrawRangeElementsBaseVertex - render primitives from array data with a per-element offset
* @usage
* @code void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLES</b>, <b>GL_LINES_ADJACENCY</b>,
*             <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param start Specifies the minimum array index contained in <em class="parameter"><b>indices</b></em>.
* @param end Specifies the maximum array index contained in <em class="parameter"><b>indices</b></em>.
* @param count Specifies the number of elements to be rendered.
* @param type Specifies the type of the values in indices. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param basevertex Specifies a constant that should be added to each element of <em class="parameter"><b>indices</b></em> when chosing elements
*                   from the enabled vertex arrays.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if count is negative.
* @errors GL_INVALID_VALUE is generated if end < start.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glDrawRangeElementsBaseVertex glad_glDrawRangeElementsBaseVertex
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;
/**
* @name glDrawTransformFeedback - render primitives using a count derived from a transform feedback object
* @usage
* @code void glDrawTransformFeedback(GLenum mode, GLuint id); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedback glad_glDrawTransformFeedback
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;
/**
* @name glDrawTransformFeedbackInstanced - render multiple instances of primitives using a count derived from a transform feedback object
* @usage
* @code void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @param instancecount Specifies the number of instances of the geometry to render.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedbackInstanced glad_glDrawTransformFeedbackInstanced
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;
/**
* @name glDrawTransformFeedbackStream - render primitives using a count derived from a specifed stream of a transform feedback object
* @usage
* @code void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @param stream Specifies the index of the transform feedback stream from which to retrieve a primitive count.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedbackStream glad_glDrawTransformFeedbackStream
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;
/**
* @name glDrawTransformFeedbackStreamInstanced - render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
* @usage
* @code void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param id Specifies the name of a transform feedback object from which to retrieve a primitive count.
* @param stream Specifies the index of the transform feedback stream from which to retrieve a primitive count.
* @param instancecount Specifies the number of instances of the geometry to render.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if id is not the name of a transform feedback object.
* @errors GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
* @errors GL_INVALID_OPERATION is generated if  glEndTransformFeedback has never been called while the transform feedback object named
*         by id was bound.
*
*/
#define glDrawTransformFeedbackStreamInstanced glad_glDrawTransformFeedbackStreamInstanced
GLAD_API_CALL PFNGLENABLEPROC glad_glEnable;
/**
* @name glEnable - enable or disable server-side GL capabilities
* @usage
* @code void glEnable(GLenum cap); @endcode
* @param cap Specifies a symbolic constant indicating a GL capability.
* @param index Specifies the index of the switch to disable (for <b>glEnablei</b> and <b>glDisablei</b> only).
* @note GL_PRIMITIVE_RESTART is available only if the GL version is 3.1 or greater.
* @note GL_TEXTURE_CUBE_MAP_SEAMLESS is available only if the GL version is 3.2 or greater.
* @note GL_PRIMITIVE_RESTART_FIXED_INDEX is available only if the GL version is 4.3 or greater.
* @note GL_DEBUG_OUTPUT and GL_DEBUG_OUTPUT_SYNCHRONOUS are available only if the GL version is 4.3 or greater.
* @note Any token accepted by glEnable or glDisable is also accepted by glEnablei and glDisablei, but if the capability is not indexed,
*       the maximum value that index may take is zero.
* @note In general, passing an indexed capability to glEnable or glDisable will enable or disable that capability for all indices,
*       resepectively.
*
* @errors GL_INVALID_ENUM is generated if cap is not one of the values listed previously.
* @errors GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities
*         for cap.
*
*/
#define glEnable glad_glEnable
GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glEnableVertexArrayAttrib glad_glEnableVertexArrayAttrib
GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
/**
* @name glEnableVertexAttribArray - Enable or disable a generic vertex attribute
array
* @usage
* @code void glEnableVertexAttribArray(GLuint index); @endcode
* @code void glDisableVertexAttribArray(GLuint index); @endcode
* @code void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @code void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glDisableVertexArrayAttrib</b> and <b>glEnableVertexArrayAttrib</b>
*              functions.
* @param index Specifies the index of the generic vertex attribute to be enabled or disabled.
*
* @errors GL_INVALID_OPERATION is generated by glEnableVertexAttribArray and glDisableVertexAttribArray if no vertex array object
*         is bound.
* @errors GL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and glDisableVertexArrayAttrib if vaobj is not the name of
*         an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glEnableVertexAttribArray glad_glEnableVertexAttribArray
GLAD_API_CALL PFNGLENABLEIPROC glad_glEnablei;
// Unable to find the docs for this function!
#define glEnablei glad_glEnablei
GLAD_API_CALL PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
// Unable to find the docs for this function!
#define glEndConditionalRender glad_glEndConditionalRender
GLAD_API_CALL PFNGLENDQUERYPROC glad_glEndQuery;
// Unable to find the docs for this function!
#define glEndQuery glad_glEndQuery
GLAD_API_CALL PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;
// Unable to find the docs for this function!
#define glEndQueryIndexed glad_glEndQueryIndexed
GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
// Unable to find the docs for this function!
#define glEndTransformFeedback glad_glEndTransformFeedback
GLAD_API_CALL PFNGLFENCESYNCPROC glad_glFenceSync;
/**
* @name glFenceSync - create a new sync object and insert it into the GL command stream
* @usage
* @code GLsync glFenceSync(GLenum condition, GLbitfield flags); @endcode
* @param condition Specifies the condition that must be met to set the sync object's state to signaled. <em class="parameter"><b>condition</b></em>
*                  must be <b>GL_SYNC_GPU_COMMANDS_COMPLETE</b>.
* @param flags Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for
*              this operation and <em class="parameter"><b>flags</b></em> must be zero. <a class="footnote" href="#ftn. id-1. 5. 2. 2.
*              2. 1. 2"><sup class="footnote" id="id-1. 5. 2. 2. 2. 1. 2">[1]</sup></a>
* @note glFenceSync is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is supported.
*
* @errors GL_INVALID_ENUM is generated if condition is not GL_SYNC_GPU_COMMANDS_COMPLETE.
* @errors GL_INVALID_VALUE is generated if flags is not zero.
* @errors Additionally, if glFenceSync fails, it will return zero.
*
*/
#define glFenceSync glad_glFenceSync
GLAD_API_CALL PFNGLFINISHPROC glad_glFinish;
/**
* @name glFinish - block until all GL execution is complete
* @usage
* @code void glFinish( void); @endcode
* @note glFinish requires a round trip to the server.
*
*
*/
#define glFinish glad_glFinish
GLAD_API_CALL PFNGLFLUSHPROC glad_glFlush;
/**
* @name glFlush - force execution of GL commands in finite time
* @usage
* @code void glFlush( void); @endcode
* @note glFlush can return at any time. It does not wait until the execution of all previously issued GL commands is complete.
*
*
*/
#define glFlush glad_glFlush
GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
/**
* @name glFlushMappedBufferRange, glFlushMappedNamedBufferRange - indicate modifications to a range of a mapped buffer
* @usage
* @code void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length); @endcode
* @code void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glFlushMappedBufferRange</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glFlushMappedNamedBufferRange</b>.
* @param offset Specifies the start of the buffer subrange, in basic machine units.
* @param length Specifies the length of the buffer subrange, in basic machine units.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glFlushMappedBufferRange if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedBufferRange if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedNamedBufferRange if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length exceeds the size of the mapping.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not mapped, or is mapped without the GL_MAP_FLUSH_EXPLICIT_BIT
*         flag.
*
*/
#define glFlushMappedBufferRange glad_glFlushMappedBufferRange
GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;
/**
* @name glFlushMappedBufferRange, glFlushMappedNamedBufferRange - indicate modifications to a range of a mapped buffer
* @usage
* @code void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length); @endcode
* @code void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glFlushMappedBufferRange</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glFlushMappedNamedBufferRange</b>.
* @param offset Specifies the start of the buffer subrange, in basic machine units.
* @param length Specifies the length of the buffer subrange, in basic machine units.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glFlushMappedBufferRange if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedBufferRange if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glFlushMappedNamedBufferRange if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length exceeds the size of the mapping.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not mapped, or is mapped without the GL_MAP_FLUSH_EXPLICIT_BIT
*         flag.
*
*/
#define glFlushMappedNamedBufferRange glad_glFlushMappedNamedBufferRange
GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;
/**
* @name glFramebufferParameteri, glNamedFramebufferParameteri - set a named parameter of a framebuffer object
* @usage
* @code void glFramebufferParameteri(GLenum target, GLenum pname, GLint param); @endcode
* @code void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferParameteri</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferParameteri</b>.
* @param pname Specifies the framebuffer parameter to be modified.
* @param param The new value for the parameter named <em class="parameter"><b>pname</b></em>.
*
* @errors GL_INVALID_ENUM is generated by glFramebufferParameteri if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferParameteri if the default framebuffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferParameteri if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_WIDTH and param is less than zero or greater than the value
*         of GL_MAX_FRAMEBUFFER_WIDTH.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_HEIGHT and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_HEIGHT.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_LAYERS and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_LAYERS.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_SAMPLES and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_SAMPLES.
*
*/
#define glFramebufferParameteri glad_glFramebufferParameteri
GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
/**
* @name glFramebufferRenderbuffer, glNamedFramebufferRenderbuffer - attach a renderbuffer as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @code void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferRenderbuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferRenderbuffer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param renderbuffertarget Specifies the renderbuffer target. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of an existing renderbuffer object of type <em class="parameter"><b>renderbuffertarget</b></em> to attach.
*
* @errors GL_INVALID_ENUM is generated by glFramebufferRenderbuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferRenderbuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferRenderbuffer if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated if renderbuffertarget is not zero or the name of an existing renderbuffer object of type
*         GL_RENDERBUFFER.
*
*/
#define glFramebufferRenderbuffer glad_glFramebufferRenderbuffer
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture glad_glFramebufferTexture
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture1D glad_glFramebufferTexture1D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture2D glad_glFramebufferTexture2D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTexture3D glad_glFramebufferTexture3D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
/**
* @name glFramebufferTextureLayer, glNamedFramebufferTextureLayer - attach a single layer of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferTextureLayer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTextureLayer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @param layer Specifies the layer of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by glFramebufferTexture if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferTexture if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_OPERATION is generated if texture is not zero and is not the name of an existing three-dimensional, two-dimensional
*         multisample array, one- or two-dimensional array, cube map, or cube map array texture.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture, as described
*         above.
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE minus
*         one (for three-dimensional texture objects), or larger than the value of GL_MAX_ARRAY_TEXTURE_LAYERS minus one (for array
*         texture objects).
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is negative.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glFramebufferTextureLayer glad_glFramebufferTextureLayer
GLAD_API_CALL PFNGLFRONTFACEPROC glad_glFrontFace;
/**
* @name glFrontFace - define front- and back-facing polygons
* @usage
* @code void glFrontFace(GLenum mode); @endcode
* @param mode Specifies the orientation of front-facing polygons. <b>GL_CW</b> and <b>GL_CCW</b> are accepted. The initial value is <b>GL_CCW</b>.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
*
*/
#define glFrontFace glad_glFrontFace
GLAD_API_CALL PFNGLGENBUFFERSPROC glad_glGenBuffers;
/**
* @name glGenBuffers - generate buffer object names
* @usage
* @code void glGenBuffers(GLsizei n, GLuint * buffers); @endcode
* @param n Specifies the number of buffer object names to be generated.
* @param buffers Specifies an array in which the generated buffer object names are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenBuffers glad_glGenBuffers
GLAD_API_CALL PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
/**
* @name glGenFramebuffers - generate framebuffer object names
* @usage
* @code void glGenFramebuffers(GLsizei n, GLuint *ids); @endcode
* @param n Specifies the number of framebuffer object names to generate.
* @param ids Specifies an array in which the generated framebuffer object names are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenFramebuffers glad_glGenFramebuffers
GLAD_API_CALL PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;
/**
* @name glGenProgramPipelines - reserve program pipeline object names
* @usage
* @code void glGenProgramPipelines(GLsizei n, GLuint *pipelines); @endcode
* @param n Specifies the number of program pipeline object names to reserve.
* @param pipelines Specifies an array of into which the reserved names will be written.
*
*
*/
#define glGenProgramPipelines glad_glGenProgramPipelines
GLAD_API_CALL PFNGLGENQUERIESPROC glad_glGenQueries;
/**
* @name glGenQueries - generate query object names
* @usage
* @code void glGenQueries(GLsizei n, GLuint * ids); @endcode
* @param n Specifies the number of query object names to be generated.
* @param ids Specifies an array in which the generated query object names are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenQueries glad_glGenQueries
GLAD_API_CALL PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
/**
* @name glGenRenderbuffers - generate renderbuffer object names
* @usage
* @code void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers); @endcode
* @param n Specifies the number of renderbuffer object names to generate.
* @param renderbuffers Specifies an array in which the generated renderbuffer object names are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenRenderbuffers glad_glGenRenderbuffers
GLAD_API_CALL PFNGLGENSAMPLERSPROC glad_glGenSamplers;
/**
* @name glGenSamplers - generate sampler object names
* @usage
* @code void glGenSamplers(GLsizei n, GLuint *samplers); @endcode
* @param n Specifies the number of sampler object names to generate.
* @param samplers Specifies an array in which the generated sampler object names are stored.
* @note glGenSamplers is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenSamplers glad_glGenSamplers
GLAD_API_CALL PFNGLGENTEXTURESPROC glad_glGenTextures;
/**
* @name glGenTextures - generate texture names
* @usage
* @code void glGenTextures(GLsizei n, GLuint * textures); @endcode
* @param n Specifies the number of texture names to be generated.
* @param textures Specifies an array in which the generated texture names are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenTextures glad_glGenTextures
GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;
/**
* @name glGenTransformFeedbacks - reserve transform feedback object names
* @usage
* @code void glGenTransformFeedbacks(GLsizei n, GLuint *ids); @endcode
* @param n Specifies the number of transform feedback object names to reserve.
* @param ids Specifies an array of into which the reserved names will be written.
*
*
*/
#define glGenTransformFeedbacks glad_glGenTransformFeedbacks
GLAD_API_CALL PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
/**
* @name glGenVertexArrays - generate vertex array object names
* @usage
* @code void glGenVertexArrays(GLsizei n, GLuint *arrays); @endcode
* @param n Specifies the number of vertex array object names to generate.
* @param arrays Specifies an array in which the generated vertex array object names are stored.
*
* @errors GL_INVALID_VALUE is generated if n is negative.
*
*/
#define glGenVertexArrays glad_glGenVertexArrays
GLAD_API_CALL PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
/**
* @name glGenerateMipmap, glGenerateTextureMipmap - generate mipmaps for a specified texture object
* @usage
* @code void glGenerateMipmap(GLenum target); @endcode
* @code void glGenerateTextureMipmap(GLuint texture); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glGenerateMipmap</b>. Must be one of <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP</b>,
*               or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glGenerateTextureMipmap</b>.
* @note Cube map array textures are accepted only if the GL version is 4.0 or higher.
*
* @errors GL_INVALID_ENUM is generated by glGenerateMipmap if target is not one of the accepted texture targets.
* @errors GL_INVALID_OPERATION is generated by glGenerateTextureMipmap if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_CUBE_MAP or GL_TEXTURE_CUBE_MAP_ARRAY, and the specified texture
*         object is not cube complete or cube array complete, respectively.
*
*/
#define glGenerateMipmap glad_glGenerateMipmap
GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;
/**
* @name glGenerateMipmap, glGenerateTextureMipmap - generate mipmaps for a specified texture object
* @usage
* @code void glGenerateMipmap(GLenum target); @endcode
* @code void glGenerateTextureMipmap(GLuint texture); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glGenerateMipmap</b>. Must be one of <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP</b>,
*               or <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glGenerateTextureMipmap</b>.
* @note Cube map array textures are accepted only if the GL version is 4.0 or higher.
*
* @errors GL_INVALID_ENUM is generated by glGenerateMipmap if target is not one of the accepted texture targets.
* @errors GL_INVALID_OPERATION is generated by glGenerateTextureMipmap if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_CUBE_MAP or GL_TEXTURE_CUBE_MAP_ARRAY, and the specified texture
*         object is not cube complete or cube array complete, respectively.
*
*/
#define glGenerateTextureMipmap glad_glGenerateTextureMipmap
GLAD_API_CALL PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;
/**
* @name glGetActiveAtomicCounterBufferiv - retrieve information about the set of active atomic counter buffers for a program
* @usage
* @code void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params); @endcode
* @param program The name of a program object from which to retrieve information.
* @param bufferIndex Specifies index of an active atomic counter buffer.
* @param pname Specifies which parameter of the atomic counter buffer to retrieve.
* @param params Specifies the address of a variable into which to write the retrieved information.
* @note glGetActiveAtomicCounterBufferiv is available only if the GL version is 4.2 or higher.
* @note GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER is available only of the GL version is 4.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been called in
*         the past.
* @errors GL_INVALID_VALUE is generated if bufferIndex is greater than or equal to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for
*         program.
* @errors GL_INVALID_ENUM is generated if pname is not one of the accepted tokens.
*
*/
#define glGetActiveAtomicCounterBufferiv glad_glGetActiveAtomicCounterBufferiv
GLAD_API_CALL PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
/**
* @name glGetActiveAttrib - Returns information about an active attribute variable for the specified program object
* @usage
* @code void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param index Specifies the index of the attribute variable to be queried.
* @param bufSize Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <em class="parameter"><b>name</b></em>.
* @param length Returns the number of characters actually written by OpenGL in the string indicated by <em class="parameter"><b>name</b></em>
*               (excluding the null terminator) if a value other than <b>NULL</b> is passed.
* @param size Returns the size of the attribute variable.
* @param type Returns the data type of the attribute variable.
* @param name Returns a null terminated string containing the name of the attribute variable.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of active attribute variables in program.
* @errors GL_INVALID_VALUE is generated if bufSize is less than 0.
*
*/
#define glGetActiveAttrib glad_glGetActiveAttrib
GLAD_API_CALL PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;
/**
* @name glGetActiveSubroutineName - query the name of an active shader subroutine
* @usage
* @code void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name); @endcode
* @param program Specifies the name of the program containing the subroutine.
* @param shadertype Specifies the shader stage from which to query the subroutine name.
* @param index Specifies the index of the shader subroutine uniform.
* @param bufSize Specifies the size of the buffer whose address is given in <em class="parameter"><b>name</b></em>.
* @param length Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.
* @param name Specifies the address of an array into which the name of the shader subroutine uniform will be written.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetActiveSubroutineName glad_glGetActiveSubroutineName
GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;
/**
* @name glGetActiveSubroutineUniformName - query the name of an active shader subroutine uniform
* @usage
* @code void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name); @endcode
* @param program Specifies the name of the program containing the subroutine.
* @param shadertype Specifies the shader stage from which to query for the subroutine parameter. <em class="parameter"><b>shadertype</b></em>
*                   must be one of <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>, <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param index Specifies the index of the shader subroutine uniform.
* @param bufSize Specifies the size of the buffer whose address is given in <em class="parameter"><b>name</b></em>.
* @param length Specifies the address of a variable into which is written the number of characters copied into <em class="parameter"><b>name</b></em>.
* @param name Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.
*
* @errors GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORMS.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetActiveSubroutineUniformName glad_glGetActiveSubroutineUniformName
GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;
// Unable to find the docs for this function!
#define glGetActiveSubroutineUniformiv glad_glGetActiveSubroutineUniformiv
GLAD_API_CALL PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
/**
* @name glGetActiveUniform - Returns information about an active uniform variable for the specified program object
* @usage
* @code void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param index Specifies the index of the uniform variable to be queried.
* @param bufSize Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <em class="parameter"><b>name</b></em>.
* @param length Returns the number of characters actually written by OpenGL in the string indicated by <em class="parameter"><b>name</b></em>
*               (excluding the null terminator) if a value other than <b>NULL</b> is passed.
* @param size Returns the size of the uniform variable.
* @param type Returns the data type of the uniform variable.
* @param name Returns a null terminated string containing the name of the uniform variable.
* @note The double types, GL_DOUBLE, GL_DOUBLE_VEC2, GL_DOUBLE_VEC3, GL_DOUBLE_VEC4, GL_DOUBLE_MAT2, GL_DOUBLE_MAT3, GL_DOUBLE_MAT4,
*       GL_DOUBLE_MAT2x3, GL_DOUBLE_MAT2x4, GL_DOUBLE_MAT3x2, GL_DOUBLE_MAT3x4, GL_DOUBLE_MAT4x2, and GL_DOUBLE_MAT4x3 are
*       only available if the GL version is 4.1 or higher.
* @note The image types, GL_IMAGE_1D, GL_IMAGE_2D, GL_IMAGE_3D, GL_IMAGE_2D_RECT, GL_IMAGE_CUBE, GL_IMAGE_BUFFER, GL_IMAGE_1D_ARRAY,
*       GL_IMAGE_2D_ARRAY, GL_IMAGE_2D_MULTISAMPLE, GL_IMAGE_2D_MULTISAMPLE_ARRAY, GL_INT_IMAGE_1D, GL_INT_IMAGE_2D, GL_INT_IMAGE_3D,
*       GL_INT_IMAGE_2D_RECT, GL_INT_IMAGE_CUBE, GL_INT_IMAGE_BUFFER, GL_INT_IMAGE_1D_ARRAY, GL_INT_IMAGE_2D_ARRAY, GL_INT_IMAGE_2D_MULTISAMPLE,
*       GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY, GL_UNSIGNED_INT_IMAGE_1D, GL_UNSIGNED_INT_IMAGE_2D, GL_UNSIGNED_INT_IMAGE_3D,
*       GL_UNSIGNED_INT_IMAGE_2D_RECT, GL_UNSIGNED_INT_IMAGE_CUBE, GL_UNSIGNED_INT_IMAGE_BUFFER, GL_UNSIGNED_INT_IMAGE_1D_ARRAY,
*       GL_UNSIGNED_INT_IMAGE_2D_ARRAY, GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE, GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY,
*       and the atomic counter type, GL_UNSIGNED_INT_ATOMIC_COUNTER are only available if the GL version is 4.2
*       or higher.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of active uniform variables in program.
* @errors GL_INVALID_VALUE is generated if bufSize is less than 0.
*
*/
#define glGetActiveUniform glad_glGetActiveUniform
GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
/**
* @name glGetActiveUniformBlockName - retrieve the name of an active uniform block
* @usage
* @code void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName); @endcode
* @param program Specifies the name of a program containing the uniform block.
* @param uniformBlockIndex Specifies the index of the uniform block within <em class="parameter"><b>program</b></em>.
* @param bufSize Specifies the size of the buffer addressed by <em class="parameter"><b>uniformBlockName</b></em>.
* @param length Specifies the address of a variable to receive the number of characters that were written to <em class="parameter"><b>uniformBlockName</b></em>.
* @param uniformBlockName Specifies the address an array of characters to receive the name of the uniform block at <em class="parameter"><b>uniformBlockIndex</b></em>.
* @note glGetActiveUniformBlockName is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called
*         in the past.
* @errors GL_INVALID_VALUE is generated if uniformBlockIndex is greater than or equal to the value of GL_ACTIVE_UNIFORM_BLOCKS or
*         is not the index of an active uniform block in program.
*
*/
#define glGetActiveUniformBlockName glad_glGetActiveUniformBlockName
GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
// Unable to find the docs for this function!
#define glGetActiveUniformBlockiv glad_glGetActiveUniformBlockiv
GLAD_API_CALL PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
/**
* @name glGetActiveUniformName - query the name of an active uniform
* @usage
* @code void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName); @endcode
* @param program Specifies the program containing the active uniform index <em class="parameter"><b>uniformIndex</b></em>.
* @param uniformIndex Specifies the index of the active uniform whose name to query.
* @param bufSize Specifies the size of the buffer, in units of <b>GLchar</b>, of the buffer whose address is specified in <em class="parameter"><b>uniformName</b></em>.
* @param length Specifies the address of a variable that will receive the number of characters that were or would have been written to the
*               buffer addressed by <em class="parameter"><b>uniformName</b></em>.
* @param uniformName Specifies the address of a buffer into which the GL will place the name of the active uniform at <em class="parameter"><b>uniformIndex</b></em>
*                    within <em class="parameter"><b>program</b></em>.
*
* @errors GL_INVALID_VALUE is generated if uniformIndex is greater than or equal to the value of GL_ACTIVE_UNIFORMS.
* @errors GL_INVALID_VALUE is generated if bufSize is negative.
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been issued.
*
*/
#define glGetActiveUniformName glad_glGetActiveUniformName
GLAD_API_CALL PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
/**
* @name glGetActiveUniformsiv - Returns information about several active uniform variables for the specified program object
* @usage
* @code void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params); @endcode
* @param program Specifies the program object to be queried.
* @param uniformCount Specifies both the number of elements in the array of indices <em class="parameter"><b>uniformIndices</b></em> and the number
*                     of parameters written to <em class="parameter"><b>params</b></em> upon successful return.
* @param uniformIndices Specifies the address of an array of <em class="parameter"><b>uniformCount</b></em> integers containing the indices of uniforms
*                       within <em class="parameter"><b>program</b></em> whose parameter <em class="parameter"><b>pname</b></em> should
*                       be queried.
* @param pname Specifies the property of each uniform in <em class="parameter"><b>uniformIndices</b></em> that should be written into the
*              corresponding element of <em class="parameter"><b>params</b></em>.
* @param params Specifies the address of an array of <em class="parameter"><b>uniformCount</b></em> integers which are to receive the value
*               of <em class="parameter"><b>pname</b></em> for each uniform in <em class="parameter"><b>uniformIndices</b></em>.
* @note The double types, GL_DOUBLE, GL_DOUBLE_VEC2, GL_DOUBLE_VEC3, GL_DOUBLE_VEC4, GL_DOUBLE_MAT2, GL_DOUBLE_MAT3, GL_DOUBLE_MAT4,
*       GL_DOUBLE_MAT2x3, GL_DOUBLE_MAT2x4, GL_DOUBLE_MAT3x2, GL_DOUBLE_MAT3x4, GL_DOUBLE_MAT4x2, and GL_DOUBLE_MAT4x3 are
*       only available if the GL version is 4.1 or higher.
* @note GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX is only accepted by pname if the GL version is 4.2 or higher.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if uniformCount is greater than or equal to the value of GL_ACTIVE_UNIFORMS for program.
* @errors GL_INVALID_ENUM is generated if pname is not an accepted token.
*
*/
#define glGetActiveUniformsiv glad_glGetActiveUniformsiv
GLAD_API_CALL PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
/**
* @name glGetAttachedShaders - Returns the handles of the shader objects attached to a program object
* @usage
* @code void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders); @endcode
* @param program Specifies the program object to be queried.
* @param maxCount Specifies the size of the array for storing the returned object names.
* @param count Returns the number of names actually returned in <em class="parameter"><b>shaders</b></em>.
* @param shaders Specifies an array that is used to return the names of attached shader objects.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if maxCount is less than 0.
*
*/
#define glGetAttachedShaders glad_glGetAttachedShaders
GLAD_API_CALL PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
/**
* @name glGetAttribLocation - Returns the location of an attribute variable
* @usage
* @code GLint glGetAttribLocation(GLuint program, const GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param name Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
*
* @errors GL_INVALID_OPERATION is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program has not been successfully linked.
*
*/
#define glGetAttribLocation glad_glGetAttribLocation
GLAD_API_CALL PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
// Unable to find the docs for this function!
#define glGetBooleani_v glad_glGetBooleani_v
GLAD_API_CALL PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
// Unable to find the docs for this function!
#define glGetBooleanv glad_glGetBooleanv
GLAD_API_CALL PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
// Unable to find the docs for this function!
#define glGetBufferParameteri64v glad_glGetBufferParameteri64v
GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
// Unable to find the docs for this function!
#define glGetBufferParameteriv glad_glGetBufferParameteriv
GLAD_API_CALL PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
/**
* @name glGetBufferPointerv, glGetNamedBufferPointerv - return the pointer to a mapped buffer object's data store
* @usage
* @code void glGetBufferPointerv(GLenum target, GLenum pname, void ** params); @endcode
* @code void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferPointerv</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferPointerv</b>.
* @param pname Specifies the name of the pointer to be returned. Must be <b>GL_BUFFER_MAP_POINTER</b>.
* @param params Returns the pointer value specified by <em class="parameter"><b>pname</b></em>.
* @note If an error is generated, no change is made to the contents of params.
* @note The initial value for the pointer is NULL.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated if by glGetBufferPointerv if target is not one of the accepted buffer targets, or if pname
*         is not GL_BUFFER_MAP_POINTER.
* @errors GL_INVALID_OPERATION is generated by glGetBufferPointerv if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferPointerv if buffer is not the name of an existing buffer object.
*
*/
#define glGetBufferPointerv glad_glGetBufferPointerv
GLAD_API_CALL PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
/**
* @name glGetBufferSubData, glGetNamedBufferSubData - returns a subset of a buffer object's data store
* @usage
* @code void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data); @endcode
* @code void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
* @param size Specifies the size in bytes of the data store region being returned.
* @param data Specifies a pointer to the location where buffer object data is returned.
* @note If an error is generated, no change is made to the contents of data.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_OPERATION is generated by glGetBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is mapped with glMapBufferRange or glMapBuffer, unless it was mapped
*         with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glGetBufferSubData glad_glGetBufferSubData
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
/**
* @name glGetCompressedTexImage - return a compressed texture image
* @usage
* @code void glGetCompressedTexImage(GLenum target, GLint level, void * pixels); @endcode
* @code void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels); @endcode
* @code void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetCompressedTexImage</b> and <b>glGetnCompressedTexImage</b>
*               functions. <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, <b>GL_TEXTURE_RECTANGLE</b> are accepted.
* @param texture Specifies the texture object name for <b>glGetCompressedTextureImage</b> function.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap
*              reduction image.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetCompressedTextureImage</b> and <b>glGetnCompressedTexImage</b>
*                functions.
* @param pixels Returns the compressed texture image.
*
* @errors GL_INVALID_OPERATION is generated by glGetCompressedTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than zero or greater than the maximum number of LODs permitted by the implementation.
* @errors GL_INVALID_OPERATION is generated if glGetCompressedTexImage, glGetnCompressedTexImage, and glGetCompressedTextureImage
*         is used to retrieve a texture that is in an uncompressed internal format.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target, the buffer
*         storage was not initialized with glBufferStorage using GL_MAP_PERSISTENT_BIT flag, and the buffer object's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
*
*/
#define glGetCompressedTexImage glad_glGetCompressedTexImage
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;
/**
* @name glGetCompressedTexImage - return a compressed texture image
* @usage
* @code void glGetCompressedTexImage(GLenum target, GLint level, void * pixels); @endcode
* @code void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels); @endcode
* @code void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetCompressedTexImage</b> and <b>glGetnCompressedTexImage</b>
*               functions. <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, <b>GL_TEXTURE_RECTANGLE</b> are accepted.
* @param texture Specifies the texture object name for <b>glGetCompressedTextureImage</b> function.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap
*              reduction image.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetCompressedTextureImage</b> and <b>glGetnCompressedTexImage</b>
*                functions.
* @param pixels Returns the compressed texture image.
*
* @errors GL_INVALID_OPERATION is generated by glGetCompressedTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than zero or greater than the maximum number of LODs permitted by the implementation.
* @errors GL_INVALID_OPERATION is generated if glGetCompressedTexImage, glGetnCompressedTexImage, and glGetCompressedTextureImage
*         is used to retrieve a texture that is in an uncompressed internal format.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target, the buffer
*         storage was not initialized with glBufferStorage using GL_MAP_PERSISTENT_BIT flag, and the buffer object's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
*
*/
#define glGetCompressedTextureImage glad_glGetCompressedTextureImage
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;
/**
* @name glGetCompressedTextureSubImage - retrieve a sub-region of a compressed texture image from a
compressed texture object
* @usage
* @code void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels); @endcode
* @param texture Specifies the name of the source texture object. Must be <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>,
*                <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>
*                or <b>GL_TEXTURE_RECTANGLE</b>. In specific, buffer and multisample textures are not permitted.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the <em class="parameter"><b>offset</b></em>
*              is zero and the size equals the texture image size.
* @param height Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the <em class="parameter"><b>offset</b></em>
*               is zero and the size equals the texture image size.
* @param depth Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the <em class="parameter"><b>offset</b></em>
*              is zero and the size equals the texture image size.
* @param bufSize Specifies the size of the buffer to receive the retrieved pixel data.
* @param pixels Returns the texture subimage. Should be a pointer to an array of the type specified by type.
*
* @errors GL_INVALID_OPERATION error is generated if texture is the name of a buffer or multisample texture.
* @errors GL_INVALID_OPERATION error is generated if the buffer size required to store the requested data is greater than bufSize.
* @errors GL_INVALID_OPERATION error is generated if the texture compression format is not based on fixed-size blocks.
* @errors GL_INVALID_VALUE error is generated if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset are negative.
* @errors GL_INVALID_VALUE is generated if xoffset + width is greater than the texture's width, yoffset + height is greater than the
*         texture's height, or zoffset + depth is greater than the texture's depth.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D and either yoffset is not zero, or height is
*         not one.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE
*         and either zoffset is not zero, or depth is not one.
* @errors GL_INVALID_VALUE error is generated if xoffset, yoffset or zoffset is not a multiple of the compressed block width, height
*         or depth respectively.
* @errors GL_INVALID_VALUE error is generated if width, height or depth is not a multiple of the compressed block width, height or
*         depth respectively, unless the offset is zero and the size equals the texture image size.
*
*/
#define glGetCompressedTextureSubImage glad_glGetCompressedTextureSubImage
GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;
/**
* @name glGetDebugMessageLog - retrieve messages from the debug message log
* @usage
* @code GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog); @endcode
* @param count The number of debug messages to retrieve from the log.
* @param bufSize The size of the buffer whose address is given by <em class="parameter"><b>messageLog</b></em>.
* @param sources The address of an array of variables to receive the sources of the retrieved messages.
* @param types The address of an array of variables to receive the types of the retrieved messages.
* @param ids The address of an array of unsigned integers to receive the ids of the retrieved messages.
* @param severities The address of an array of variables to receive the severites of the retrieved messages.
* @param lengths The address of an array of variables to receive the lengths of the received messages.
* @param messageLog The address of an array of characters that will receive the messages.
* @note Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially
*       inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug
*       context may produce no messages at all.
*
* @errors GL_INVALID_VALUE is generated if count or bufSize is negative.
*
*/
#define glGetDebugMessageLog glad_glGetDebugMessageLog
GLAD_API_CALL PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;
// Unable to find the docs for this function!
#define glGetDoublei_v glad_glGetDoublei_v
GLAD_API_CALL PFNGLGETDOUBLEVPROC glad_glGetDoublev;
// Unable to find the docs for this function!
#define glGetDoublev glad_glGetDoublev
GLAD_API_CALL PFNGLGETERRORPROC glad_glGetError;
/**
* @name glGetError - return error information
* @usage
* @code GLenum glGetError( void); @endcode
*
*
*/
#define glGetError glad_glGetError
GLAD_API_CALL PFNGLGETFLOATI_VPROC glad_glGetFloati_v;
// Unable to find the docs for this function!
#define glGetFloati_v glad_glGetFloati_v
GLAD_API_CALL PFNGLGETFLOATVPROC glad_glGetFloatv;
// Unable to find the docs for this function!
#define glGetFloatv glad_glGetFloatv
GLAD_API_CALL PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
/**
* @name glGetFragDataIndex - query the bindings of color indices to user-defined varying out variables
* @usage
* @code GLint glGetFragDataIndex(GLuint program, const char * name); @endcode
* @param program The name of the program containing varying out variable whose binding to query
* @param name The name of the user-defined varying out variable whose index to query
* @note glGetFragDataIndex is available only if the GL version is 3.3 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glGetFragDataIndex glad_glGetFragDataIndex
GLAD_API_CALL PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
/**
* @name glGetFragDataLocation - query the bindings of color numbers to user-defined varying out variables
* @usage
* @code GLint glGetFragDataLocation(GLuint program, const char * name); @endcode
* @param program The name of the program containing varying out variable whose binding to query
* @param name The name of the user-defined varying out variable whose binding to query
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object.
*
*/
#define glGetFragDataLocation glad_glGetFragDataLocation
GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;
// Unable to find the docs for this function!
#define glGetFramebufferAttachmentParameteriv glad_glGetFramebufferAttachmentParameteriv
GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;
// Unable to find the docs for this function!
#define glGetFramebufferParameteriv glad_glGetFramebufferParameteriv
GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;
/**
* @name glGetGraphicsResetStatus - check if the rendering context has not been lost due to software or hardware issues
* @usage
* @code GLenum glGetGraphicsResetStatus(void); @endcode
*
*
*/
#define glGetGraphicsResetStatus glad_glGetGraphicsResetStatus
GLAD_API_CALL PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
// Unable to find the docs for this function!
#define glGetInteger64i_v glad_glGetInteger64i_v
GLAD_API_CALL PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
// Unable to find the docs for this function!
#define glGetInteger64v glad_glGetInteger64v
GLAD_API_CALL PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
// Unable to find the docs for this function!
#define glGetIntegeri_v glad_glGetIntegeri_v
GLAD_API_CALL PFNGLGETINTEGERVPROC glad_glGetIntegerv;
// Unable to find the docs for this function!
#define glGetIntegerv glad_glGetIntegerv
GLAD_API_CALL PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;
// Unable to find the docs for this function!
#define glGetInternalformati64v glad_glGetInternalformati64v
GLAD_API_CALL PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;
// Unable to find the docs for this function!
#define glGetInternalformativ glad_glGetInternalformativ
GLAD_API_CALL PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
// Unable to find the docs for this function!
#define glGetMultisamplefv glad_glGetMultisamplefv
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;
// Unable to find the docs for this function!
#define glGetNamedBufferParameteri64v glad_glGetNamedBufferParameteri64v
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;
// Unable to find the docs for this function!
#define glGetNamedBufferParameteriv glad_glGetNamedBufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;
/**
* @name glGetBufferPointerv, glGetNamedBufferPointerv - return the pointer to a mapped buffer object's data store
* @usage
* @code void glGetBufferPointerv(GLenum target, GLenum pname, void ** params); @endcode
* @code void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferPointerv</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferPointerv</b>.
* @param pname Specifies the name of the pointer to be returned. Must be <b>GL_BUFFER_MAP_POINTER</b>.
* @param params Returns the pointer value specified by <em class="parameter"><b>pname</b></em>.
* @note If an error is generated, no change is made to the contents of params.
* @note The initial value for the pointer is NULL.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated if by glGetBufferPointerv if target is not one of the accepted buffer targets, or if pname
*         is not GL_BUFFER_MAP_POINTER.
* @errors GL_INVALID_OPERATION is generated by glGetBufferPointerv if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferPointerv if buffer is not the name of an existing buffer object.
*
*/
#define glGetNamedBufferPointerv glad_glGetNamedBufferPointerv
GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;
/**
* @name glGetBufferSubData, glGetNamedBufferSubData - returns a subset of a buffer object's data store
* @usage
* @code void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data); @endcode
* @code void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glGetBufferSubData</b>, which must be one of the buffer
*               binding targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glGetNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
* @param size Specifies the size in bytes of the data store region being returned.
* @param data Specifies a pointer to the location where buffer object data is returned.
* @note If an error is generated, no change is made to the contents of data.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetBufferSubData if target is not one of the generic buffer binding targets.
* @errors GL_INVALID_OPERATION is generated by glGetBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glGetNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is mapped with glMapBufferRange or glMapBuffer, unless it was mapped
*         with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
*
*/
#define glGetNamedBufferSubData glad_glGetNamedBufferSubData
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;
// Unable to find the docs for this function!
#define glGetNamedFramebufferAttachmentParameteriv glad_glGetNamedFramebufferAttachmentParameteriv
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;
// Unable to find the docs for this function!
#define glGetNamedFramebufferParameteriv glad_glGetNamedFramebufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;
// Unable to find the docs for this function!
#define glGetNamedRenderbufferParameteriv glad_glGetNamedRenderbufferParameteriv
GLAD_API_CALL PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;
/**
* @name glGetObjectLabel - retrieve the label of a named object identified within a namespace
* @usage
* @code void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label); @endcode
* @param identifier The namespace from which the name of the object is allocated.
* @param name The name of the object whose label to retrieve.
* @param bufSize The length of the buffer whose address is in <em class="parameter"><b>label</b></em>.
* @param length The address of a variable to receive the length of the object label.
* @param label The address of a string that will receive the object label.
*
* @errors GL_INVALID_ENUM is generated if identifier is not one of the accepted object types.
* @errors GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier.
* @errors GL_INVALID_VALUE is generated if bufSize is zero.
* @errors If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including
*         process termination may occur.
*
*/
#define glGetObjectLabel glad_glGetObjectLabel
GLAD_API_CALL PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;
/**
* @name glGetObjectPtrLabel - retrieve the label of a sync object identified by a pointer
* @usage
* @code void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label); @endcode
* @param ptr The name of the sync object whose label to retrieve.
* @param bufSize The length of the buffer whose address is in <em class="parameter"><b>label</b></em>.
* @param length The address of a variable to receive the length of the object label.
* @param label The address of a string that will receive the object label.
*
* @errors GL_INVALID_ENUM is generated if identifier is not one of the accepted object types.
* @errors GL_INVALID_VALUE is generated if ptr is not the name of an existing sync object.
* @errors GL_INVALID_VALUE is generated if bufSize is zero.
* @errors If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including
*         process termination may occur.
*
*/
#define glGetObjectPtrLabel glad_glGetObjectPtrLabel
GLAD_API_CALL PFNGLGETPOINTERVPROC glad_glGetPointerv;
/**
* @name glGetPointerv - return the address of the specified pointer
* @usage
* @code void glGetPointerv(GLenum pname, void ** params); @endcode
* @param pname Specifies the pointer to be returned. Must be one of <b>GL_DEBUG_CALLBACK_FUNCTION</b> or <b>GL_DEBUG_CALLBACK_USER_PARAM</b>.
* @param params Returns the pointer value specified by <em class="parameter"><b>pname</b></em>.
* @note glGetPointerv is available in the OpenGL core profile only if the GL version is 4.3 or later. It is available in the compatibility
*       profile for all GL versions, and accepts additional queries. However, these reference pages document only the
*       core profile.
*
* @errors GL_INVALID_ENUM is generated if pname is not an accepted value.
*
*/
#define glGetPointerv glad_glGetPointerv
GLAD_API_CALL PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;
/**
* @name glGetProgramBinary - return a binary representation of a program object's compiled and linked executable source
* @usage
* @code void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary); @endcode
* @param program Specifies the name of a program object whose binary representation to retrieve.
* @param bufSize Specifies the size of the buffer whose address is given by <em class="parameter"><b>binary</b></em>.
* @param length Specifies the address of a variable to receive the number of bytes written into <em class="parameter"><b>binary</b></em>.
* @param binaryFormat Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
* @param binary Specifies the address an array into which the GL will return <em class="parameter"><b>program</b></em>'s binary representation.
*
* @errors GL_INVALID_OPERATION is generated if bufSize is less than the size of GL_PROGRAM_BINARY_LENGTH for program.
* @errors GL_INVALID_OPERATION is generated if GL_LINK_STATUS for the program object is false.
*
*/
#define glGetProgramBinary glad_glGetProgramBinary
GLAD_API_CALL PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
/**
* @name glGetProgramInfoLog - Returns the information log for a program object
* @usage
* @code void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog); @endcode
* @param program Specifies the program object whose information log is to be queried.
* @param maxLength Specifies the size of the character buffer for storing the returned information log.
* @param length Returns the length of the string returned in <em class="parameter"><b>infoLog</b></em> (excluding the null terminator).
* @param infoLog Specifies an array of characters that is used to return the information log.
* @note The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking
*       and validating. Therefore, the information log can be helpful to application developers during the development process,
*       even when these operations are successful. Application developers should not expect different OpenGL implementations
*       to produce identical information logs.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_VALUE is generated if maxLength is less than 0.
*
*/
#define glGetProgramInfoLog glad_glGetProgramInfoLog
GLAD_API_CALL PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;
// Unable to find the docs for this function!
#define glGetProgramInterfaceiv glad_glGetProgramInterfaceiv
GLAD_API_CALL PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;
/**
* @name glGetProgramPipelineInfoLog - retrieve the info log string from a program pipeline object
* @usage
* @code void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog); @endcode
* @param pipeline Specifies the name of a program pipeline object from which to retrieve the info log.
* @param bufSize Specifies the maximum number of characters, including the null terminator, that may be written into <em class="parameter"><b>infoLog</b></em>.
* @param length Specifies the address of a variable into which will be written the number of characters written into <em class="parameter"><b>infoLog</b></em>.
* @param infoLog Specifies the address of an array of characters into which will be written the info log for <em class="parameter"><b>pipeline</b></em>.
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glGetProgramPipelineInfoLog glad_glGetProgramPipelineInfoLog
GLAD_API_CALL PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;
// Unable to find the docs for this function!
#define glGetProgramPipelineiv glad_glGetProgramPipelineiv
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;
/**
* @name glGetProgramResourceIndex - query the index of a named resource within a program
* @usage
* @code GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the resource named <em class="parameter"><b>name</b></em>.
* @param name The name of the resource to query the index of.
*
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active
*         atomic counter and transform feedback buffer resources are not assigned name strings.
* @errors Although not an error, GL_INVALID_INDEX is returned if name is not the name of a resource within the interface identified
*         by programInterface.
*
*/
#define glGetProgramResourceIndex glad_glGetProgramResourceIndex
GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;
/**
* @name glGetProgramResourceLocation - query the location of a named resource within a program
* @usage
* @code GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the resource named <em class="parameter"><b>name</b></em>.
* @param name The name of the resource to query the location of.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_OPERATION is generated if program has not been linked successfully.
*
*/
#define glGetProgramResourceLocation glad_glGetProgramResourceLocation
GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;
/**
* @name glGetProgramResourceLocationIndex - query the fragment color index of a named variable within a program
* @usage
* @code GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the resource named <em class="parameter"><b>name</b></em>.
* @param name The name of the resource to query the location of.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_OPERATION is generated if program has not been linked successfully.
*
*/
#define glGetProgramResourceLocationIndex glad_glGetProgramResourceLocationIndex
GLAD_API_CALL PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;
/**
* @name glGetProgramResourceName - query the name of an indexed resource within a program
* @usage
* @code void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name); @endcode
* @param program The name of a program object whose resources to query.
* @param programInterface A token identifying the interface within <em class="parameter"><b>program</b></em> containing the indexed resource.
* @param index The index of the resource within <em class="parameter"><b>programInterface</b></em> of <em class="parameter"><b>program</b></em>.
* @param bufSize The size of the character array whose address is given by <em class="parameter"><b>name</b></em>.
* @param length The address of a variable which will receive the length of the resource name.
* @param name The address of a character array into which will be written the name of the resource.
*
* @errors GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types.
* @errors GL_INVALID_VALUE is generated if progam is not the name of an existing program.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of entries in the active resource list for
*         programInterface.
* @errors GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active
*         atomic counter and transform feedback buffer resources are not assigned name strings.
*
*/
#define glGetProgramResourceName glad_glGetProgramResourceName
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;
// Unable to find the docs for this function!
#define glGetProgramResourceiv glad_glGetProgramResourceiv
GLAD_API_CALL PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;
// Unable to find the docs for this function!
#define glGetProgramStageiv glad_glGetProgramStageiv
GLAD_API_CALL PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
// Unable to find the docs for this function!
#define glGetProgramiv glad_glGetProgramiv
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;
// Unable to find the docs for this function!
#define glGetQueryBufferObjecti64v glad_glGetQueryBufferObjecti64v
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;
// Unable to find the docs for this function!
#define glGetQueryBufferObjectiv glad_glGetQueryBufferObjectiv
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;
// Unable to find the docs for this function!
#define glGetQueryBufferObjectui64v glad_glGetQueryBufferObjectui64v
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;
// Unable to find the docs for this function!
#define glGetQueryBufferObjectuiv glad_glGetQueryBufferObjectuiv
GLAD_API_CALL PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;
// Unable to find the docs for this function!
#define glGetQueryIndexediv glad_glGetQueryIndexediv
GLAD_API_CALL PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
// Unable to find the docs for this function!
#define glGetQueryObjecti64v glad_glGetQueryObjecti64v
GLAD_API_CALL PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
// Unable to find the docs for this function!
#define glGetQueryObjectiv glad_glGetQueryObjectiv
GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
// Unable to find the docs for this function!
#define glGetQueryObjectui64v glad_glGetQueryObjectui64v
GLAD_API_CALL PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
// Unable to find the docs for this function!
#define glGetQueryObjectuiv glad_glGetQueryObjectuiv
GLAD_API_CALL PFNGLGETQUERYIVPROC glad_glGetQueryiv;
/**
* @name glGetQueryiv - return parameters of a query object target
* @usage
* @code void glGetQueryiv(GLenum target, GLenum pname, GLint * params); @endcode
* @param target Specifies a query object target. Must be <b>GL_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED</b>, <b>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</b>
<b>GL_PRIMITIVES_GENERATED</b>,
*               <b>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</b>, <b>GL_TIME_ELAPSED</b>,
*               or <b>GL_TIMESTAMP</b>.
* @param pname Specifies the symbolic name of a query object target parameter. Accepted values are <b>GL_CURRENT_QUERY</b> or <b>GL_QUERY_COUNTER_BITS</b>.
* @param params Returns the requested data.
* @note The target GL_ANY_SAMPLES_PASSED_CONSERVATIVE is available only if the GL version is 4.3 or greater.
* @note If an error is generated, no change is made to the contents of params.
*
* @errors GL_INVALID_ENUM is generated if target or pname is not an accepted value.
*
*/
#define glGetQueryiv glad_glGetQueryiv
GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
// Unable to find the docs for this function!
#define glGetRenderbufferParameteriv glad_glGetRenderbufferParameteriv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
// Unable to find the docs for this function!
#define glGetSamplerParameterIiv glad_glGetSamplerParameterIiv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
// Unable to find the docs for this function!
#define glGetSamplerParameterIuiv glad_glGetSamplerParameterIuiv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
// Unable to find the docs for this function!
#define glGetSamplerParameterfv glad_glGetSamplerParameterfv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
// Unable to find the docs for this function!
#define glGetSamplerParameteriv glad_glGetSamplerParameteriv
GLAD_API_CALL PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
/**
* @name glGetShaderInfoLog - Returns the information log for a shader object
* @usage
* @code void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog); @endcode
* @param shader Specifies the shader object whose information log is to be queried.
* @param maxLength Specifies the size of the character buffer for storing the returned information log.
* @param length Returns the length of the string returned in <em class="parameter"><b>infoLog</b></em> (excluding the null terminator).
* @param infoLog Specifies an array of characters that is used to return the information log.
* @note The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the
*       compilation process. Therefore, the information log can be helpful to application developers during the development process,
*       even when compilation is successful. Application developers should not expect different OpenGL implementations to
*       produce identical information logs.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_VALUE is generated if maxLength is less than 0.
*
*/
#define glGetShaderInfoLog glad_glGetShaderInfoLog
GLAD_API_CALL PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;
/**
* @name glGetShaderPrecisionFormat - retrieve the range and precision for numeric formats supported by the shader compiler
* @usage
* @code void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision); @endcode
* @param shaderType Specifies the type of shader whose precision to query. <em class="parameter"><b>shaderType</b></em> must be <b>GL_VERTEX_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param precisionType Specifies the numeric format whose precision and range to query.
* @param range Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
* @param precision Specifies the address of an integer into which the numeric precision of the implementation is written.
*
* @errors GL_INVALID_ENUM is generated if shaderType or precisionType is not an accepted value.
*
*/
#define glGetShaderPrecisionFormat glad_glGetShaderPrecisionFormat
GLAD_API_CALL PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
/**
* @name glGetShaderSource - Returns the source code string from a shader object
* @usage
* @code void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source); @endcode
* @param shader Specifies the shader object to be queried.
* @param bufSize Specifies the size of the character buffer for storing the returned source code string.
* @param length Returns the length of the string returned in <em class="parameter"><b>source</b></em> (excluding the null terminator).
* @param source Specifies an array of characters that is used to return the source code string.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_VALUE is generated if bufSize is less than 0.
*
*/
#define glGetShaderSource glad_glGetShaderSource
GLAD_API_CALL PFNGLGETSHADERIVPROC glad_glGetShaderiv;
// Unable to find the docs for this function!
#define glGetShaderiv glad_glGetShaderiv
GLAD_API_CALL PFNGLGETSTRINGPROC glad_glGetString;
/**
* @name glGetString - return a string describing the current GL connection
* @usage
* @code const GLubyte *glGetString(GLenum name); @endcode
* @param name Specifies a symbolic constant, one of <b>GL_VENDOR</b>, <b>GL_RENDERER</b>, <b>GL_VERSION</b>, or <b>GL_SHADING_LANGUAGE_VERSION</b>.
*             Additionally, <b>glGetStringi</b> accepts the <b>GL_EXTENSIONS</b> token.
* @param index For <b>glGetStringi</b>, specifies the index of the string to return.
* @note If an error is generated, glGetString returns 0.
* @note The client and server may support different versions. glGetString always returns a compatible version number. The release
*       number always describes the server.
*
* @errors GL_INVALID_ENUM is generated if name is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glGetStringi if index is outside the valid range for indexed state name.
*
*/
#define glGetString glad_glGetString
GLAD_API_CALL PFNGLGETSTRINGIPROC glad_glGetStringi;
// Unable to find the docs for this function!
#define glGetStringi glad_glGetStringi
GLAD_API_CALL PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;
/**
* @name glGetSubroutineIndex - retrieve the index of a subroutine uniform of a given shader stage within a program
* @usage
* @code GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name); @endcode
* @param program Specifies the name of the program containing shader stage.
* @param shadertype Specifies the shader stage from which to query for subroutine uniform index. <em class="parameter"><b>shadertype</b></em>
*                   must be one of <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>, <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param name Specifies the name of the subroutine uniform whose index to query.
*
* @errors GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetSubroutineIndex glad_glGetSubroutineIndex
GLAD_API_CALL PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;
/**
* @name glGetSubroutineUniformLocation - retrieve the location of a subroutine uniform of a given shader stage within a program
* @usage
* @code GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name); @endcode
* @param program Specifies the name of the program containing shader stage.
* @param shadertype Specifies the shader stage from which to query for subroutine uniform index. <em class="parameter"><b>shadertype</b></em>
*                   must be one of <b>GL_VERTEX_SHADER</b>, <b>GL_TESS_CONTROL_SHADER</b>, <b>GL_TESS_EVALUATION_SHADER</b>, <b>GL_GEOMETRY_SHADER</b>
*                   or <b>GL_FRAGMENT_SHADER</b>.
* @param name Specifies the name of the subroutine uniform whose index to query.
*
* @errors GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if program is not the name of an existing program object.
*
*/
#define glGetSubroutineUniformLocation glad_glGetSubroutineUniformLocation
GLAD_API_CALL PFNGLGETSYNCIVPROC glad_glGetSynciv;
// Unable to find the docs for this function!
#define glGetSynciv glad_glGetSynciv
GLAD_API_CALL PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
/**
* @name glGetTexImage - return a texture image
* @usage
* @code void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels); @endcode
* @code void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @code void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetTexImage</b> and <b>glGetnTexImage</b> functions. <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_ARRAY</b> are acceptable.
* @param texture Specifies the texture object name.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <math overflow="scroll"><mi
*              mathvariant="italic">n</mi></math> is the <math overflow="scroll"><mi mathvariant="italic">n</mi></math>th mipmap
*              reduction image.
* @param format Specifies a pixel format for the returned data. The supported formats are <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGBA</b>,
*               <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_GREEN_INTEGER</b>, <b>GL_BLUE_INTEGER</b>, <b>GL_RG_INTEGER</b>,
*               <b>GL_RGB_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGR_INTEGER</b>, <b>GL_BGRA_INTEGER</b>.
* @param type Specifies a pixel type for the returned data. The supported types are <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
*             <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetnTexImage</b> and <b>glGetTextureImage</b>
*                functions.
* @param pixels Returns the texture image. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @note If an error is generated, no change is made to the contents of pixels.
* @note glGetTexImage and glGetnTexImage return the texture image for the active texture unit.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetTexImage and glGetnTexImage functions if target is not an accepted value. These include:
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z for glGetTexImage and glGetnTexImage
*         functions.
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         and GL_TEXTURE_CUBE_MAP for glGetTextureImage function.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format, or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than  log2 ⁡ max , where maxis the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if level is non-zero and the effective target is GL_TEXTURE_RECTANGLE.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or
*         GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage and glGetnTexImage if the buffer size required to store the requested
*         data is greater than bufSize.
*
*/
#define glGetTexImage glad_glGetTexImage
GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
// Unable to find the docs for this function!
#define glGetTexLevelParameterfv glad_glGetTexLevelParameterfv
GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
// Unable to find the docs for this function!
#define glGetTexLevelParameteriv glad_glGetTexLevelParameteriv
GLAD_API_CALL PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
// Unable to find the docs for this function!
#define glGetTexParameterIiv glad_glGetTexParameterIiv
GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
// Unable to find the docs for this function!
#define glGetTexParameterIuiv glad_glGetTexParameterIuiv
GLAD_API_CALL PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
// Unable to find the docs for this function!
#define glGetTexParameterfv glad_glGetTexParameterfv
GLAD_API_CALL PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
// Unable to find the docs for this function!
#define glGetTexParameteriv glad_glGetTexParameteriv
GLAD_API_CALL PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;
/**
* @name glGetTexImage - return a texture image
* @usage
* @code void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels); @endcode
* @code void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @code void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetTexImage</b> and <b>glGetnTexImage</b> functions. <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_ARRAY</b> are acceptable.
* @param texture Specifies the texture object name.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <math overflow="scroll"><mi
*              mathvariant="italic">n</mi></math> is the <math overflow="scroll"><mi mathvariant="italic">n</mi></math>th mipmap
*              reduction image.
* @param format Specifies a pixel format for the returned data. The supported formats are <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGBA</b>,
*               <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_GREEN_INTEGER</b>, <b>GL_BLUE_INTEGER</b>, <b>GL_RG_INTEGER</b>,
*               <b>GL_RGB_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGR_INTEGER</b>, <b>GL_BGRA_INTEGER</b>.
* @param type Specifies a pixel type for the returned data. The supported types are <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
*             <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetnTexImage</b> and <b>glGetTextureImage</b>
*                functions.
* @param pixels Returns the texture image. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @note If an error is generated, no change is made to the contents of pixels.
* @note glGetTexImage and glGetnTexImage return the texture image for the active texture unit.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetTexImage and glGetnTexImage functions if target is not an accepted value. These include:
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z for glGetTexImage and glGetnTexImage
*         functions.
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         and GL_TEXTURE_CUBE_MAP for glGetTextureImage function.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format, or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than  log2 ⁡ max , where maxis the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if level is non-zero and the effective target is GL_TEXTURE_RECTANGLE.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or
*         GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage and glGetnTexImage if the buffer size required to store the requested
*         data is greater than bufSize.
*
*/
#define glGetTextureImage glad_glGetTextureImage
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;
// Unable to find the docs for this function!
#define glGetTextureLevelParameterfv glad_glGetTextureLevelParameterfv
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;
// Unable to find the docs for this function!
#define glGetTextureLevelParameteriv glad_glGetTextureLevelParameteriv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;
// Unable to find the docs for this function!
#define glGetTextureParameterIiv glad_glGetTextureParameterIiv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;
// Unable to find the docs for this function!
#define glGetTextureParameterIuiv glad_glGetTextureParameterIuiv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;
// Unable to find the docs for this function!
#define glGetTextureParameterfv glad_glGetTextureParameterfv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;
// Unable to find the docs for this function!
#define glGetTextureParameteriv glad_glGetTextureParameteriv
GLAD_API_CALL PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;
/**
* @name glGetTextureSubImage - retrieve a sub-region of a texture image from a texture
object
* @usage
* @code void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param texture Specifies the name of the source texture object. Must be <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>,
*                <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>
*                or <b>GL_TEXTURE_RECTANGLE</b>. In specific, buffer and multisample textures are not permitted.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_DEPTH_COMPONENT</b> and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param bufSize Specifies the size of the buffer to receive the retrieved pixel data.
* @param pixels Returns the texture subimage. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
*
* @errors GL_INVALID_VALUE error is generated if texture is not the name of an existing texture object.
* @errors GL_INVALID_OPERATION error is generated if texture is the name of a buffer or multisample texture.
* @errors GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset are negative.
* @errors GL_INVALID_VALUE is generated if xoffset + width is greater than the texture's width, yoffset + height is greater than the
*         texture's height, or zoffset + depth is greater than the texture's depth.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D and either yoffset is not zero, or height is
*         not one.
* @errors GL_INVALID_VALUE error is generated if the effective target is GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE
*         and either zoffset is not zero, or depth is not one.
* @errors GL_INVALID_OPERATION error is generated if the buffer size required to store the requested data is greater than bufSize.
*
*/
#define glGetTextureSubImage glad_glGetTextureSubImage
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
/**
* @name glGetTransformFeedbackVarying - retrieve information about varying variables selected for transform feedback
* @usage
* @code void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name); @endcode
* @param program The name of the target program object.
* @param index The index of the varying variable whose information to retrieve.
* @param bufSize The maximum number of characters, including the null terminator, that may be written into <em class="parameter"><b>name</b></em>.
* @param length The address of a variable which will receive the number of characters written into <em class="parameter"><b>name</b></em>,
*               excluding the null-terminator. If <em class="parameter"><b>length</b></em> is <b>NULL</b> no length is returned.
* @param size The address of a variable that will receive the size of the varying.
* @param type The address of a variable that will receive the type of the varying.
* @param name The address of a buffer into which will be written the name of the varying.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object.
* @errors GL_INVALID_VALUE is generated if index is greater or equal to the value of GL_TRANSFORM_FEEDBACK_VARYINGS.
* @errors GL_INVALID_OPERATION is generated program has not been linked.
*
*/
#define glGetTransformFeedbackVarying glad_glGetTransformFeedbackVarying
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;
// Unable to find the docs for this function!
#define glGetTransformFeedbacki64_v glad_glGetTransformFeedbacki64_v
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;
// Unable to find the docs for this function!
#define glGetTransformFeedbacki_v glad_glGetTransformFeedbacki_v
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;
// Unable to find the docs for this function!
#define glGetTransformFeedbackiv glad_glGetTransformFeedbackiv
GLAD_API_CALL PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
/**
* @name glGetUniformBlockIndex - retrieve the index of a named uniform block
* @usage
* @code GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName); @endcode
* @param program Specifies the name of a program containing the uniform block.
* @param uniformBlockName Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.
* @note glGetUniformBlockIndex is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called
*         in the past.
*
*/
#define glGetUniformBlockIndex glad_glGetUniformBlockIndex
GLAD_API_CALL PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
/**
* @name glGetUniformIndices - retrieve the index of a named uniform block
* @usage
* @code void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices); @endcode
* @param program Specifies the name of a program containing uniforms whose indices to query.
* @param uniformCount Specifies the number of uniforms whose indices to query.
* @param uniformNames Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
* @param uniformIndices Specifies the address of an array that will receive the indices of the uniforms.
* @note glGetUniformIndices is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called
*         in the past.
*
*/
#define glGetUniformIndices glad_glGetUniformIndices
GLAD_API_CALL PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
/**
* @name glGetUniformLocation - Returns the location of a uniform variable
* @usage
* @code GLint glGetUniformLocation(GLuint program, const GLchar *name); @endcode
* @param program Specifies the program object to be queried.
* @param name Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program has not been successfully linked.
*
*/
#define glGetUniformLocation glad_glGetUniformLocation
GLAD_API_CALL PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;
// Unable to find the docs for this function!
#define glGetUniformSubroutineuiv glad_glGetUniformSubroutineuiv
GLAD_API_CALL PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;
// Unable to find the docs for this function!
#define glGetUniformdv glad_glGetUniformdv
GLAD_API_CALL PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
// Unable to find the docs for this function!
#define glGetUniformfv glad_glGetUniformfv
GLAD_API_CALL PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
// Unable to find the docs for this function!
#define glGetUniformiv glad_glGetUniformiv
GLAD_API_CALL PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
// Unable to find the docs for this function!
#define glGetUniformuiv glad_glGetUniformuiv
GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;
/**
* @name glGetVertexArrayIndexed - retrieve parameters of an attribute of a vertex array
object
* @usage
* @code void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param); @endcode
* @param vaobj Specifies the name of a vertex array object.
* @param index Specifies the index of the vertex array object attribute. Must be a number between 0 and (<b>GL_MAX_VERTEX_ATTRIBS</b> -
*              1).
* @param pname Specifies the property to be used for the query. For <b>glGetVertexArrayIndexediv</b>, it must be one of the following values:
*              <b>GL_VERTEX_ATTRIB_ARRAY_ENABLED</b>, <b>GL_VERTEX_ATTRIB_ARRAY_SIZE</b>, <b>GL_VERTEX_ATTRIB_ARRAY_STRIDE</b>,
*              <b>GL_VERTEX_ATTRIB_ARRAY_TYPE</b>, <b>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</b>, <b>GL_VERTEX_ATTRIB_ARRAY_INTEGER</b>, <b>GL_VERTEX_ATTRIB_ARRAY_LONG</b>,
*              <b>GL_VERTEX_ATTRIB_ARRAY_DIVISOR</b>, or <b>GL_VERTEX_ATTRIB_RELATIVE_OFFSET</b>. For
*              <b>glGetVertexArrayIndexed64v</b>, it must be equal to <b>GL_VERTEX_BINDING_OFFSET</b>.
* @param param Returns the requested value.
*
* @errors GL_INVALID_OPERATION error is generated if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE error is generated if index is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM error is generated if pname is not one of the valid values. For more details, please see above.
*
*/
#define glGetVertexArrayIndexed64iv glad_glGetVertexArrayIndexed64iv
GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;
// Unable to find the docs for this function!
#define glGetVertexArrayIndexediv glad_glGetVertexArrayIndexediv
GLAD_API_CALL PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;
/**
* @name glGetVertexArrayiv - retrieve parameters of a vertex array object
* @usage
* @code void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param); @endcode
* @param vaobj specifies the name of the vertex array object to use for the query.
* @param pname Name of the property to use for the query. Must be <b>GL_ELEMENT_ARRAY_BUFFER_BINDING</b>.
* @param param Returns the requested value.
*
* @errors GL_INVALID_OPERATION error is generated if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_ENUM error is generated if pname is not GL_ELEMENT_ARRAY_BUFFER_BINDING.
*
*/
#define glGetVertexArrayiv glad_glGetVertexArrayiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
// Unable to find the docs for this function!
#define glGetVertexAttribIiv glad_glGetVertexAttribIiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
// Unable to find the docs for this function!
#define glGetVertexAttribIuiv glad_glGetVertexAttribIuiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;
// Unable to find the docs for this function!
#define glGetVertexAttribLdv glad_glGetVertexAttribLdv
GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
/**
* @name glGetVertexAttribPointerv - return the address of the specified generic vertex attribute pointer
* @usage
* @code void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer); @endcode
* @param index Specifies the generic vertex attribute parameter to be returned.
* @param pname Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be <b>GL_VERTEX_ATTRIB_ARRAY_POINTER</b>.
* @param pointer Returns the pointer value.
* @note The state returned is retrieved from the currently bound vertex array object.
* @note The initial value for each pointer is 0.
*
* @errors GL_INVALID_OPERATION is generated if no vertex array object is currently bound.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if pname is not an accepted value.
*
*/
#define glGetVertexAttribPointerv glad_glGetVertexAttribPointerv
GLAD_API_CALL PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
// Unable to find the docs for this function!
#define glGetVertexAttribdv glad_glGetVertexAttribdv
GLAD_API_CALL PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
// Unable to find the docs for this function!
#define glGetVertexAttribfv glad_glGetVertexAttribfv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
// Unable to find the docs for this function!
#define glGetVertexAttribiv glad_glGetVertexAttribiv
GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;
/**
* @name glGetCompressedTexImage - return a compressed texture image
* @usage
* @code void glGetCompressedTexImage(GLenum target, GLint level, void * pixels); @endcode
* @code void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels); @endcode
* @code void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetCompressedTexImage</b> and <b>glGetnCompressedTexImage</b>
*               functions. <b>GL_TEXTURE_1D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, <b>GL_TEXTURE_RECTANGLE</b> are accepted.
* @param texture Specifies the texture object name for <b>glGetCompressedTextureImage</b> function.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap
*              reduction image.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetCompressedTextureImage</b> and <b>glGetnCompressedTexImage</b>
*                functions.
* @param pixels Returns the compressed texture image.
*
* @errors GL_INVALID_OPERATION is generated by glGetCompressedTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if level is less than zero or greater than the maximum number of LODs permitted by the implementation.
* @errors GL_INVALID_OPERATION is generated if glGetCompressedTexImage, glGetnCompressedTexImage, and glGetCompressedTextureImage
*         is used to retrieve a texture that is in an uncompressed internal format.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target, the buffer
*         storage was not initialized with glBufferStorage using GL_MAP_PERSISTENT_BIT flag, and the buffer object's data store
*         is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
*
*/
#define glGetnCompressedTexImage glad_glGetnCompressedTexImage
GLAD_API_CALL PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;
/**
* @name glGetTexImage - return a texture image
* @usage
* @code void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels); @endcode
* @code void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @code void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glGetTexImage</b> and <b>glGetnTexImage</b> functions. <b>GL_TEXTURE_1D</b>,
*               <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_3D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>,
*               and <b>GL_TEXTURE_CUBE_MAP_ARRAY</b> are acceptable.
* @param texture Specifies the texture object name.
* @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <math overflow="scroll"><mi
*              mathvariant="italic">n</mi></math> is the <math overflow="scroll"><mi mathvariant="italic">n</mi></math>th mipmap
*              reduction image.
* @param format Specifies a pixel format for the returned data. The supported formats are <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGBA</b>,
*               <b>GL_BGR</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_GREEN_INTEGER</b>, <b>GL_BLUE_INTEGER</b>, <b>GL_RG_INTEGER</b>,
*               <b>GL_RGB_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGR_INTEGER</b>, <b>GL_BGRA_INTEGER</b>.
* @param type Specifies a pixel type for the returned data. The supported types are <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
*             <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>pixels</b></em> for <b>glGetnTexImage</b> and <b>glGetTextureImage</b>
*                functions.
* @param pixels Returns the texture image. Should be a pointer to an array of the type specified by <em class="parameter"><b>type</b></em>.
* @note If an error is generated, no change is made to the contents of pixels.
* @note glGetTexImage and glGetnTexImage return the texture image for the active texture unit.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glGetTexImage and glGetnTexImage functions if target is not an accepted value. These include:
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z for glGetTexImage and glGetnTexImage
*         functions.
* @errors GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE,
*         and GL_TEXTURE_CUBE_MAP for glGetTextureImage function.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format, or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than  log2 ⁡ max , where maxis the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if level is non-zero and the effective target is GL_TEXTURE_RECTANGLE.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or
*         GL_DEPTH_STENCIL.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated by glGetTextureImage and glGetnTexImage if the buffer size required to store the requested
*         data is greater than bufSize.
*
*/
#define glGetnTexImage glad_glGetnTexImage
GLAD_API_CALL PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;
// Unable to find the docs for this function!
#define glGetnUniformdv glad_glGetnUniformdv
GLAD_API_CALL PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;
// Unable to find the docs for this function!
#define glGetnUniformfv glad_glGetnUniformfv
GLAD_API_CALL PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;
// Unable to find the docs for this function!
#define glGetnUniformiv glad_glGetnUniformiv
GLAD_API_CALL PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;
// Unable to find the docs for this function!
#define glGetnUniformuiv glad_glGetnUniformuiv
GLAD_API_CALL PFNGLHINTPROC glad_glHint;
/**
* @name glHint - specify implementation-specific hints
* @usage
* @code void glHint(GLenum target, GLenum mode); @endcode
* @param target Specifies a symbolic constant indicating the behavior to be controlled. <b>GL_LINE_SMOOTH_HINT</b>, <b>GL_POLYGON_SMOOTH_HINT</b>,
*               <b>GL_TEXTURE_COMPRESSION_HINT</b>, and <b>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</b> are accepted.
* @param mode Specifies a symbolic constant indicating the desired behavior. <b>GL_FASTEST</b>, <b>GL_NICEST</b>, and <b>GL_DONT_CARE</b>
*             are accepted.
* @note The interpretation of hints depends on the implementation. Some implementations ignore glHint settings.
*
* @errors GL_INVALID_ENUM is generated if either target or mode is not an accepted value.
*
*/
#define glHint glad_glHint
GLAD_API_CALL PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;
/**
* @name glInvalidateBufferData - invalidate the content of a buffer object's data store
* @usage
* @code void glInvalidateBufferData(GLuint buffer); @endcode
* @param buffer The name of a buffer object whose data store to invalidate.
*
* @errors GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of buffer is currently mapped.
*
*/
#define glInvalidateBufferData glad_glInvalidateBufferData
GLAD_API_CALL PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;
/**
* @name glInvalidateBufferSubData - invalidate a region of a buffer object's data store
* @usage
* @code void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length); @endcode
* @param buffer The name of a buffer object, a subrange of whose data store to invalidate.
* @param offset The offset within the buffer's data store of the start of the range to be invalidated.
* @param length The length of the range within the buffer's data store to be invalidated.
*
* @errors GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length is greater than the value of GL_BUFFER_SIZE
*         for buffer.
* @errors GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of buffer is currently mapped.
*
*/
#define glInvalidateBufferSubData glad_glInvalidateBufferSubData
GLAD_API_CALL PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;
/**
* @name glInvalidateFramebuffer, glInvalidateNamedFramebufferData - invalidate the content of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments); @endcode
* @code void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
*
* @errors GL_INVALID_ENUM is generated by glInvalidateFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glInvalidateNamedFramebufferData if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_VALUE is generated if numAttachments is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateFramebuffer glad_glInvalidateFramebuffer
GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;
/**
* @name glInvalidateFramebuffer, glInvalidateNamedFramebufferData - invalidate the content of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments); @endcode
* @code void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
*
* @errors GL_INVALID_ENUM is generated by glInvalidateFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glInvalidateNamedFramebufferData if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_VALUE is generated if numAttachments is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateNamedFramebufferData glad_glInvalidateNamedFramebufferData
GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;
/**
* @name glInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData - invalidate the content of a region of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height); @endcode
* @code void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateSubFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferSubData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
* @param x Specifies the X offset of the region to be invalidated.
* @param y Specifies the Y offset of the region to be invalidated.
* @param width Specifies the width of the region to be invalidated.
* @param height Specifies the height of the region to be invalidated.
*
* @errors GL_INVALID_ENUM by glInvalidateSubFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION by glInvalidateNamedFramebufferSubData if framebuffer is not zero of the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if numAttachments, width or height is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateNamedFramebufferSubData glad_glInvalidateNamedFramebufferSubData
GLAD_API_CALL PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;
/**
* @name glInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData - invalidate the content of a region of some or all of a framebuffer's attachments
* @usage
* @code void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height); @endcode
* @code void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the framebuffer object is attached for <b>glInvalidateSubFramebuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glInvalidateNamedFramebufferSubData</b>.
* @param numAttachments Specifies the number of entries in the <em class="parameter"><b>attachments</b></em> array.
* @param attachments Specifies a pointer to an array identifying the attachments to be invalidated.
* @param x Specifies the X offset of the region to be invalidated.
* @param y Specifies the Y offset of the region to be invalidated.
* @param width Specifies the width of the region to be invalidated.
* @param height Specifies the height of the region to be invalidated.
*
* @errors GL_INVALID_ENUM by glInvalidateSubFramebuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION by glInvalidateNamedFramebufferSubData if framebuffer is not zero of the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if numAttachments, width or height is negative.
* @errors GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment points, as
*         described above.
* @errors GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTm where m is greater than or equal to
*         the value of GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glInvalidateSubFramebuffer glad_glInvalidateSubFramebuffer
GLAD_API_CALL PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;
/**
* @name glInvalidateTexImage - invalidate the entirety a texture image
* @usage
* @code void glInvalidateTexImage(GLuint texture, GLint level); @endcode
* @param texture The name of a texture object to invalidate.
* @param level The level of detail of the texture object to invalidate.
*
* @errors GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum
*         texture width, height, or depth.
* @errors GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE,
*         or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero.
* @errors GL_INVALID_VALUE is generated if texture is not the name of an existing texture object.
*
*/
#define glInvalidateTexImage glad_glInvalidateTexImage
GLAD_API_CALL PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;
/**
* @name glInvalidateTexSubImage - invalidate a region of a texture image
* @usage
* @code void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @param texture The name of a texture object a subregion of which to invalidate.
* @param level The level of detail of the texture object within which the region resides.
* @param xoffset The X offset of the region to be invalidated.
* @param yoffset The Y offset of the region to be invalidated.
* @param zoffset The Z offset of the region to be invalidated.
* @param width The width of the region to be invalidated.
* @param height The height of the region to be invalidated.
* @param depth The depth of the region to be invalidated.
*
* @errors GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset is less than zero, or if any of them is greater than the size
*         of the image in the corresponding dimension.
* @errors GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum
*         texture width, height, or depth.
* @errors GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE,
*         or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero.
* @errors GL_INVALID_VALUE is generated if texture is not the name of an existing texture object.
*
*/
#define glInvalidateTexSubImage glad_glInvalidateTexSubImage
GLAD_API_CALL PFNGLISBUFFERPROC glad_glIsBuffer;
/**
* @name glIsBuffer - determine if a name corresponds to a buffer object
* @usage
* @code GLboolean glIsBuffer(GLuint buffer); @endcode
* @param buffer Specifies a value that may be the name of a buffer object.
*
*
*/
#define glIsBuffer glad_glIsBuffer
GLAD_API_CALL PFNGLISENABLEDPROC glad_glIsEnabled;
/**
* @name glIsEnabled, glIsEnabledi - test whether a capability is enabled
* @usage
* @code GLboolean glIsEnabled(GLenum cap); @endcode
* @param cap Specifies a symbolic constant indicating a GL capability.
* @param index Specifies the index of the capability.
* @note If an error is generated, glIsEnabled and glIsEnabledi return GL_FALSE.
* @note GL_PRIMITIVE_RESTART_FIXED_INDEX are available only if the GL version is 4.3 or greater.
* @note GL_DEBUG_OUTPUT and GL_DEBUG_OUTPUT_SYNCHRONOUS are available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if cap is not an accepted value.
* @errors GL_INVALID_VALUE is generated by glIsEnabledi if index is outside the valid range for the indexed state cap.
*
*/
#define glIsEnabled glad_glIsEnabled
GLAD_API_CALL PFNGLISENABLEDIPROC glad_glIsEnabledi;
// Unable to find the docs for this function!
#define glIsEnabledi glad_glIsEnabledi
GLAD_API_CALL PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
/**
* @name glIsFramebuffer - determine if a name corresponds to a framebuffer object
* @usage
* @code GLboolean glIsFramebuffer(GLuint framebuffer); @endcode
* @param framebuffer Specifies a value that may be the name of a framebuffer object.
*
*
*/
#define glIsFramebuffer glad_glIsFramebuffer
GLAD_API_CALL PFNGLISPROGRAMPROC glad_glIsProgram;
/**
* @name glIsProgram - Determines if a name corresponds to a program object
* @usage
* @code GLboolean glIsProgram(GLuint program); @endcode
* @param program Specifies a potential program object.
* @note No error is generated if program is not a valid program object name.
* @note A program object marked for deletion with glDeleteProgram but still in use as part of current rendering state is still considered
*       a program object and glIsProgram will return GL_TRUE.
*
*
*/
#define glIsProgram glad_glIsProgram
GLAD_API_CALL PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;
/**
* @name glIsProgramPipeline - determine if a name corresponds to a program pipeline object
* @usage
* @code GLboolean glIsProgramPipeline(GLuint pipeline); @endcode
* @param pipeline Specifies a value that may be the name of a program pipeline object.
*
*
*/
#define glIsProgramPipeline glad_glIsProgramPipeline
GLAD_API_CALL PFNGLISQUERYPROC glad_glIsQuery;
/**
* @name glIsQuery - determine if a name corresponds to a query object
* @usage
* @code GLboolean glIsQuery(GLuint id); @endcode
* @param id Specifies a value that may be the name of a query object.
*
*
*/
#define glIsQuery glad_glIsQuery
GLAD_API_CALL PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
/**
* @name glIsRenderbuffer - determine if a name corresponds to a renderbuffer object
* @usage
* @code GLboolean glIsRenderbuffer(GLuint renderbuffer); @endcode
* @param renderbuffer Specifies a value that may be the name of a renderbuffer object.
*
*
*/
#define glIsRenderbuffer glad_glIsRenderbuffer
GLAD_API_CALL PFNGLISSAMPLERPROC glad_glIsSampler;
/**
* @name glIsSampler - determine if a name corresponds to a sampler object
* @usage
* @code GLboolean glIsSampler(GLuint id); @endcode
* @param id Specifies a value that may be the name of a sampler object.
* @note glIsSampler is available only if the GL version is 3.3 or higher.
*
*
*/
#define glIsSampler glad_glIsSampler
GLAD_API_CALL PFNGLISSHADERPROC glad_glIsShader;
/**
* @name glIsShader - Determines if a name corresponds to a shader object
* @usage
* @code GLboolean glIsShader(GLuint shader); @endcode
* @param shader Specifies a potential shader object.
* @note No error is generated if shader is not a valid shader object name.
* @note A shader object marked for deletion with glDeleteShader but still attached to a program object is still considered a shader
*       object and glIsShader will return GL_TRUE.
*
*
*/
#define glIsShader glad_glIsShader
GLAD_API_CALL PFNGLISSYNCPROC glad_glIsSync;
/**
* @name glIsSync - determine if a name corresponds to a sync object
* @usage
* @code GLboolean glIsSync(GLsync sync); @endcode
* @param sync Specifies a value that may be the name of a sync object.
* @note glIsSync is available only if the GL version is 3.2 or greater.
*
*
*/
#define glIsSync glad_glIsSync
GLAD_API_CALL PFNGLISTEXTUREPROC glad_glIsTexture;
/**
* @name glIsTexture - determine if a name corresponds to a texture
* @usage
* @code GLboolean glIsTexture(GLuint texture); @endcode
* @param texture Specifies a value that may be the name of a texture.
*
*
*/
#define glIsTexture glad_glIsTexture
GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;
/**
* @name glIsTransformFeedback - determine if a name corresponds to a transform feedback object
* @usage
* @code GLboolean glIsTransformFeedback(GLuint id); @endcode
* @param id Specifies a value that may be the name of a transform feedback object.
*
*
*/
#define glIsTransformFeedback glad_glIsTransformFeedback
GLAD_API_CALL PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
/**
* @name glIsVertexArray - determine if a name corresponds to a vertex array object
* @usage
* @code GLboolean glIsVertexArray(GLuint array); @endcode
* @param array Specifies a value that may be the name of a vertex array object.
*
*
*/
#define glIsVertexArray glad_glIsVertexArray
GLAD_API_CALL PFNGLLINEWIDTHPROC glad_glLineWidth;
/**
* @name glLineWidth - specify the width of rasterized lines
* @usage
* @code void glLineWidth(GLfloat width); @endcode
* @param width Specifies the width of rasterized lines. The initial value is 1.
* @note The line width specified by glLineWidth is always returned when GL_LINE_WIDTH is queried. Clamping and rounding for aliased
*       and antialiased lines have no effect on the specified value.
* @note Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call glGet with GL_ALIASED_LINE_WIDTH_RANGE
*       to determine the maximum width.
* @note In OpenGL 1.2, the tokens GL_LINE_WIDTH_RANGE and GL_LINE_WIDTH_GRANULARITY were replaced by GL_ALIASED_LINE_WIDTH_RANGE,
*       GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY.  The old names are retained for backward compatibility,
*       but should not be used in new code.
*
* @errors GL_INVALID_VALUE is generated if width is less than or equal to 0.
*
*/
#define glLineWidth glad_glLineWidth
GLAD_API_CALL PFNGLLINKPROGRAMPROC glad_glLinkProgram;
/**
* @name glLinkProgram - Links a program object
* @usage
* @code void glLinkProgram(GLuint program); @endcode
* @param program Specifies the handle of the program object to be linked.
* @note If the link operation is unsuccessful, any information about a previous link operation on program is lost (i.e., a failed
*       link does not restore the old state of program ). Certain information can still be retrieved from program even after an
*       unsuccessful link operation. See for instance glGetActiveAttrib and glGetActiveUniform.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program is the currently active program object and transform feedback mode is active.
*
*/
#define glLinkProgram glad_glLinkProgram
GLAD_API_CALL PFNGLLOGICOPPROC glad_glLogicOp;
/**
* @name glLogicOp - specify a logical pixel operation for rendering
* @usage
* @code void glLogicOp(GLenum opcode); @endcode
* @param opcode Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: <b>GL_CLEAR</b>, <b>GL_SET</b>,
*               <b>GL_COPY</b>, <b>GL_COPY_INVERTED</b>, <b>GL_NOOP</b>, <b>GL_INVERT</b>, <b>GL_AND</b>, <b>GL_NAND</b>, <b>GL_OR</b>,
*               <b>GL_NOR</b>, <b>GL_XOR</b>, <b>GL_EQUIV</b>, <b>GL_AND_REVERSE</b>, <b>GL_AND_INVERTED</b>, <b>GL_OR_REVERSE</b>,
*               and <b>GL_OR_INVERTED</b>. The initial value is <b>GL_COPY</b>.
* @note When more than one RGBA color buffer is enabled for drawing, logical operations are performed separately for each enabled
*       buffer, using for the destination value the contents of that buffer (see glDrawBuffer).
* @note Logic operations have no effect on floating point draw buffers. However, if GL_COLOR_LOGIC_OP is enabled, blending is still
*       disabled in this case.
*
* @errors GL_INVALID_ENUM is generated if opcode is not an accepted value.
*
*/
#define glLogicOp glad_glLogicOp
GLAD_API_CALL PFNGLMAPBUFFERPROC glad_glMapBuffer;
/**
* @name glMapBuffer, glMapNamedBuffer - map all of a buffer object's data store into the client's address space
* @usage
* @code void *glMapBuffer(GLenum target, GLenum access); @endcode
* @code void *glMapNamedBuffer(GLuint buffer, GLenum access); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glMapBuffer</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glMapNamedBuffer</b>.
* @param access Specifies the access policy for <b>glMapBuffer</b> and <b>glMapNamedBuffer</b>, indicating whether it will be possible to
*               read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must
*               be <b>GL_READ_ONLY</b>, <b>GL_WRITE_ONLY</b>, or <b>GL_READ_WRITE</b>.
* @note Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the GL_ATOMIC_COUNTER_BUFFER
*       target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glMapBuffer if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glMapBuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glMapNamedBuffer if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_ENUM is generated if access is not GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to map the buffer object's data store. This may occur for a variety of
*         system-specific reasons, such as the absence of sufficient remaining virtual memory.
* @errors GL_INVALID_OPERATION is generated if the buffer object is in a mapped state.
*
*/
#define glMapBuffer glad_glMapBuffer
GLAD_API_CALL PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
/**
* @name glMapBufferRange, glMapNamedBufferRange - map all or part of a buffer object's data store into the client's address space
* @usage
* @code void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access); @endcode
* @code void *glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glMapBufferRange</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glMapNamedBufferRange</b>.
* @param offset Specifies the starting offset within the buffer of the range to be mapped.
* @param length Specifies the length of the range to be mapped.
* @param access Specifies a combination of access flags indicating the desired access to the mapped range.
* @note Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the GL_ATOMIC_COUNTER_BUFFER
*       target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are accepted only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
* @note The GL_MAP_PERSISTENT_BIT and GL_MAP_COHERENT_BIT flags are available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glMapBufferRange if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glMapBufferRange if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glMapNamedBufferRange if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or length is negative, if $offset + length$ is greater than the value of GL_BUFFER_SIZE
*         for the buffer object, or if access has any bits set other than those defined above.
* @errors GL_INVALID_OPERATION is generated for any of the following conditions:
* @errors length is zero.
* @errors The buffer object is already in a mapped state.
* @errors Neither GL_MAP_READ_BIT nor GL_MAP_WRITE_BIT is set.
* @errors GL_MAP_READ_BIT is set and any of GL_MAP_INVALIDATE_RANGE_BIT, GL_MAP_INVALIDATE_BUFFER_BIT or GL_MAP_UNSYNCHRONIZED_BIT
*         is set.
* @errors GL_MAP_FLUSH_EXPLICIT_BIT is set and GL_MAP_WRITE_BIT is not set.
* @errors Any of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, or GL_MAP_COHERENT_BIT are set, but the same bit is not
*         included in the buffer's storage flags.
* @errors No error is generated if memory outside the mapped range is modified or queried, but the result is undefined and system
*         errors (possibly including program termination) may occur.
*
*/
#define glMapBufferRange glad_glMapBufferRange
GLAD_API_CALL PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;
// Unable to find the docs for this function!
#define glMapNamedBuffer glad_glMapNamedBuffer
GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;
// Unable to find the docs for this function!
#define glMapNamedBufferRange glad_glMapNamedBufferRange
GLAD_API_CALL PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;
/**
* @name glMemoryBarrier - defines a barrier ordering memory transactions
* @usage
* @code void glMemoryBarrier(GLbitfield barriers); @endcode
* @code void glMemoryBarrierByRegion(GLbitfield barriers); @endcode
* @param barriers Specifies the barriers to insert.
* @note GL_SHADER_STORAGE_BARRIER_BIT is available only if the GL version is 4.3 or higher.
* @note GL_QUERY_BUFFER_BARRIER_BIT is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if barriers is not the special value GL_ALL_BARRIER_BITS, and has any bits set other than
*         those described above for glMemoryBarrier or glMemoryBarrierByRegion respectively.
*
*/
#define glMemoryBarrier glad_glMemoryBarrier
GLAD_API_CALL PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;
/**
* @name glMemoryBarrier - defines a barrier ordering memory transactions
* @usage
* @code void glMemoryBarrier(GLbitfield barriers); @endcode
* @code void glMemoryBarrierByRegion(GLbitfield barriers); @endcode
* @param barriers Specifies the barriers to insert.
* @note GL_SHADER_STORAGE_BARRIER_BIT is available only if the GL version is 4.3 or higher.
* @note GL_QUERY_BUFFER_BARRIER_BIT is available only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if barriers is not the special value GL_ALL_BARRIER_BITS, and has any bits set other than
*         those described above for glMemoryBarrier or glMemoryBarrierByRegion respectively.
*
*/
#define glMemoryBarrierByRegion glad_glMemoryBarrierByRegion
GLAD_API_CALL PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;
/**
* @name glMinSampleShading - specifies minimum rate at which sample shading takes place
* @usage
* @code void glMinSampleShading(GLfloat value); @endcode
* @param value Specifies the rate at which samples are shaded within each covered pixel.
* @note The type of the value parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described
*       in detail on the removedTypes page.
*
* @errors None.
*
*/
#define glMinSampleShading glad_glMinSampleShading
GLAD_API_CALL PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
/**
* @name glMultiDrawArrays - render multiple sets of primitives from array data
* @usage
* @code void glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param first Points to an array of starting indices in the enabled arrays.
* @param count Points to an array of the number of indices to be rendered.
* @param drawcount Specifies the size of the first and count
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's
*         data store is currently mapped.
*
*/
#define glMultiDrawArrays glad_glMultiDrawArrays
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;
/**
* @name glMultiDrawArraysIndirect - render multiple sets of primitives from array data, taking parameters from memory
* @usage
* @code void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param indirect Specifies the address of an array of structures containing the draw parameters.
* @param drawcount Specifies the number of elements in the array of draw parameter structures.
* @param stride Specifies the distance in basic machine units between elements of the draw parameter array.
* @note The baseInstance member of the DrawArraysIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions
*       of the GL, behavior is undefined if it is non-zero.
* @note glMultiDrawArraysIndirect is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is not a multiple of four.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glMultiDrawArraysIndirect glad_glMultiDrawArraysIndirect
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount;
// Unable to find the docs for this function!
#define glMultiDrawArraysIndirectCount glad_glMultiDrawArraysIndirectCount
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
/**
* @name glMultiDrawElements - render multiple sets of primitives by specifying indices of array data elements
* @usage
* @code void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Points to an array of the elements counts.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param drawcount Specifies the size of the <em class="parameter"><b>count</b></em> and <em class="parameter"><b>indices</b></em> arrays.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glMultiDrawElements glad_glMultiDrawElements
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
/**
* @name glMultiDrawElementsBaseVertex - render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
* @usage
* @code void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const void * const *indices, GLsizei drawcount, const GLint *basevertex); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b> and <b>GL_PATCHES</b>
*             are accepted.
* @param count Points to an array of the elements counts.
* @param type Specifies the type of the values in <em class="parameter"><b>indices</b></em>. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             or <b>GL_UNSIGNED_INT</b>.
* @param indices Specifies a pointer to the location where the indices are stored.
* @param drawcount Specifies the size of the <em class="parameter"><b>count</b></em>, <em class="parameter"><b>indices</b></em> and <em class="parameter"><b>basevertex</b></em>
*                  arrays.
* @param basevertex Specifies a pointer to the location where the base vertices are stored.
* @note glMultiDrawElementsBaseVertex is available only if the GL version is 3.1 or greater.
* @note GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_TRIANGLES_ADJACENCY are available only if
*       the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and
*         the buffer object's data store is currently mapped.
*
*/
#define glMultiDrawElementsBaseVertex glad_glMultiDrawElementsBaseVertex
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;
/**
* @name glMultiDrawElementsIndirect - render indexed primitives from array data, taking parameters from memory
* @usage
* @code void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride); @endcode
* @param mode Specifies what kind of primitives to render. Symbolic constants <b>GL_POINTS</b>, <b>GL_LINE_STRIP</b>, <b>GL_LINE_LOOP</b>,
*             <b>GL_LINES</b>, <b>GL_LINE_STRIP_ADJACENCY</b>, <b>GL_LINES_ADJACENCY</b>, <b>GL_TRIANGLE_STRIP</b>, <b>GL_TRIANGLE_FAN</b>,
*             <b>GL_TRIANGLES</b>, <b>GL_TRIANGLE_STRIP_ADJACENCY</b>, <b>GL_TRIANGLES_ADJACENCY</b>, and <b>GL_PATCHES</b>
*             are accepted.
* @param type Specifies the type of data in the buffer bound to the <b>GL_ELEMENT_ARRAY_BUFFER</b> binding.
* @param indirect Specifies the address of a structure containing an array of draw parameters.
* @param drawcount Specifies the number of elements in the array addressed by <em class="parameter"><b>indirect</b></em>.
* @param stride Specifies the distance in basic machine units between elements of the draw parameter array.
* @note The baseInstance member of the DrawElementsIndirectCommand structure is defined only if the GL version is 4.2 or greater.
*       For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier
*       versions of the GL, behavior is undefined if it is non-zero.
*
* @errors GL_INVALID_ENUM is generated if mode is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is not a multiple of four.
* @errors GL_INVALID_VALUE is generated if drawcount is negative.
* @errors GL_INVALID_OPERATION is generated if no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data
*         store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER
*         binding and the buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type
*         of the geometry shader in the currently installed program object.
* @errors GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active.
*
*/
#define glMultiDrawElementsIndirect glad_glMultiDrawElementsIndirect
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount;
// Unable to find the docs for this function!
#define glMultiDrawElementsIndirectCount glad_glMultiDrawElementsIndirectCount
GLAD_API_CALL PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;
/**
* @name glBufferData, glNamedBufferData - creates and initializes a buffer object's data
store
* @usage
* @code void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage); @endcode
* @code void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferData</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param usage Specifies the expected usage pattern of the data store. The symbolic constant must be <b>GL_STREAM_DRAW</b>, <b>GL_STREAM_READ</b>,
*              <b>GL_STREAM_COPY</b>, <b>GL_STATIC_DRAW</b>, <b>GL_STATIC_READ</b>, <b>GL_STATIC_COPY</b>, <b>GL_DYNAMIC_DRAW</b>,
*              <b>GL_DYNAMIC_READ</b>, or <b>GL_DYNAMIC_COPY</b>.
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
* @note Clients must align data elements consistently with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ,
*         GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
* @errors GL_INVALID_VALUE is generated if size is negative.
* @errors GL_INVALID_OPERATION is generated by glBufferData if the reserved buffer object name 0 is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size.
*
*/
#define glNamedBufferData glad_glNamedBufferData
GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;
/**
* @name glBufferStorage, glNamedBufferStorage - creates and initializes a buffer object's immutable data
store
* @usage
* @code void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags); @endcode
* @code void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferStorage</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferStorage</b> function.
* @param size Specifies the size in bytes of the buffer object's new data store.
* @param data Specifies a pointer to data that will be copied into the data store for initialization, or <b>NULL</b> if no data is to
*             be copied.
* @param flags Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. <b>GL_DYNAMIC_STORAGE_BIT</b>,
*              <b>GL_MAP_READ_BIT</b>
<b>GL_MAP_WRITE_BIT</b>, <b>GL_MAP_PERSISTENT_BIT</b>, <b>GL_MAP_COHERENT_BIT</b>,
*              and <b>GL_CLIENT_STORAGE_BIT</b>.
* @note glBufferStorage is available only if the GL version is 4.4 or greater.
* @note glNamedBufferStorage is available only if the GL version is 4.5 or greater.
* @note If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
*
* @errors GL_INVALID_ENUM is generated by glBufferStorage if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferStorage if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if size is less than or equal to zero.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the reserved buffer object name 0 is bound to target.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the properties requested in flags.
* @errors GL_INVALID_VALUE is generated if flags has any bits set other than those defined above.
* @errors GL_INVALID_VALUE error is generated if flags contains GL_MAP_PERSISTENT_BIT but does not contain at least one of GL_MAP_READ_BIT
*         or GL_MAP_WRITE_BIT.
* @errors GL_INVALID_VALUE is generated if flags contains GL_MAP_COHERENT_BIT, but does not also contain GL_MAP_PERSISTENT_BIT.
* @errors GL_INVALID_OPERATION is generated by glBufferStorage if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer bound to target
*         is GL_TRUE.
*
*/
#define glNamedBufferStorage glad_glNamedBufferStorage
GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;
/**
* @name glBufferSubData, glNamedBufferSubData - updates a subset of a buffer object's data store
* @usage
* @code void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data); @endcode
* @code void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glBufferSubData</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glNamedBufferSubData</b>.
* @param offset Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
* @param size Specifies the size in bytes of the data store region being replaced.
* @param data Specifies a pointer to the new data that will be copied into the data store.
* @note When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with
*       glBufferData. This avoids the cost of reallocating the data store.
* @note Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering
*       in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific
*       region being updated, that rendering must drain from the pipeline before the data store can be updated.
* @note Clients must align data elements consistent with the requirements of the client platform, with an additional base-level
*       requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.
* @note The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glBufferSubData if target is not one of the accepted buffer targets.
* @errors GL_INVALID_OPERATION is generated by glBufferSubData if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedBufferSubData if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset or size is negative, or if $offset + size$ is greater than the value of GL_BUFFER_SIZE
*         for the specified buffer object.
* @errors GL_INVALID_OPERATION is generated if any part of the specified range of the buffer object is mapped with glMapBufferRange
*         or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRangeaccess flags.
* @errors GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and
*         the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set.
*
*/
#define glNamedBufferSubData glad_glNamedBufferSubData
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;
/**
* @name glDrawBuffer, glNamedFramebufferDrawBuffer - specify which color buffers are to be drawn into
* @usage
* @code void glDrawBuffer(GLenum buf); @endcode
* @code void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffer</b> function. Must be zero or the name
*                    of a framebuffer object.
* @param buf For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants <b>GL_NONE</b>,
*            <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>, <b>GL_FRONT</b>, <b>GL_BACK</b>,
*            <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and <b>GL_FRONT_AND_BACK</b> are accepted. The initial value is <b>GL_FRONT</b>
*            for single-buffered contexts, and <b>GL_BACK</b> for double-buffered contexts. For framebuffer objects, <b>GL_COLOR_ATTACHMENT$m$</b>
*            and <b>GL_NONE</b> enums are accepted, where <b>$m$</b> is a value between 0 and <b>GL_MAX_COLOR_ATTACHMENTS</b>.
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if buf is not an accepted value.
* @errors GL_INVALID_OPERATION is generated if the default framebuffer is affected and none of the buffers indicated by buf exists.
* @errors GL_INVALID_OPERATION is generated if a framebuffer object is affected and buf is not equal to GL_NONE or GL_COLOR_ATTACHMENT$m$,
*         where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
*
*/
#define glNamedFramebufferDrawBuffer glad_glNamedFramebufferDrawBuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;
/**
* @name glDrawBuffers, glNamedFramebufferDrawBuffers - Specifies a list of color buffers to be drawn
into
* @usage
* @code void glDrawBuffers(GLsizei n, const GLenum *bufs); @endcode
* @code void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferDrawBuffers</b>.
* @param n Specifies the number of buffers in <em class="parameter"><b>bufs</b></em>.
* @param bufs Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
* @note The symbolic constants GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are not allowed in the bufs array since
*       they may refer to multiple buffers.
* @note If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader
*       execution are undefined. For each fragment generated in this situation, a different value may be written into each of
*       the buffers specified by bufs.
*
* @errors GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffers if framebuffer is not zero or the name of an existing
*         framebuffer object.
* @errors GL_INVALID_ENUM is generated if one of the values in bufs is not an accepted value.
* @errors GL_INVALID_ENUM is generated if the API call refers to the default framebuffer and one or more of the values in bufs is
*         one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if the API call refers to a framebuffer object and one or more of the values in bufs is anything
*         other than GL_NONE or one of the GL_COLOR_ATTACHMENTn tokens.
* @errors GL_INVALID_ENUM is generated if n is less than 0.
* @errors GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
* @errors GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does
*         not exist in the current GL context.
* @errors GL_INVALID_OPERATION is generated if any value in bufs is GL_BACK, and n is not one.
* @errors GL_INVALID_VALUE is generated if n is greater than GL_MAX_DRAW_BUFFERS.
*
*/
#define glNamedFramebufferDrawBuffers glad_glNamedFramebufferDrawBuffers
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;
/**
* @name glFramebufferParameteri, glNamedFramebufferParameteri - set a named parameter of a framebuffer object
* @usage
* @code void glFramebufferParameteri(GLenum target, GLenum pname, GLint param); @endcode
* @code void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferParameteri</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferParameteri</b>.
* @param pname Specifies the framebuffer parameter to be modified.
* @param param The new value for the parameter named <em class="parameter"><b>pname</b></em>.
*
* @errors GL_INVALID_ENUM is generated by glFramebufferParameteri if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferParameteri if the default framebuffer is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferParameteri if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_WIDTH and param is less than zero or greater than the value
*         of GL_MAX_FRAMEBUFFER_WIDTH.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_HEIGHT and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_HEIGHT.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_LAYERS and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_LAYERS.
* @errors GL_INVALID_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_SAMPLES and param is less than zero or greater than the
*         value of GL_MAX_FRAMEBUFFER_SAMPLES.
*
*/
#define glNamedFramebufferParameteri glad_glNamedFramebufferParameteri
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;
/**
* @name glReadBuffer, glNamedFramebufferReadBuffer - select a color buffer source for pixels
* @usage
* @code void glReadBuffer(GLenum mode); @endcode
* @code void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferReadBuffer</b> function.
* @param mode Specifies a color buffer. Accepted values are <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>,
*             <b>GL_FRONT</b>, <b>GL_BACK</b>, <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and the constants <b>GL_COLOR_ATTACHMENT</b><span
*             class="emphasis"><em>i</em></span>.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values.
* @errors GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferReadBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glNamedFramebufferReadBuffer glad_glNamedFramebufferReadBuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;
/**
* @name glFramebufferRenderbuffer, glNamedFramebufferRenderbuffer - attach a renderbuffer as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @code void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferRenderbuffer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferRenderbuffer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param renderbuffertarget Specifies the renderbuffer target. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of an existing renderbuffer object of type <em class="parameter"><b>renderbuffertarget</b></em> to attach.
*
* @errors GL_INVALID_ENUM is generated by glFramebufferRenderbuffer if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferRenderbuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferRenderbuffer if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated if renderbuffertarget is not zero or the name of an existing renderbuffer object of type
*         GL_RENDERBUFFER.
*
*/
#define glNamedFramebufferRenderbuffer glad_glNamedFramebufferRenderbuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;
/**
* @name glFramebufferTexture - attach a level of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); @endcode
* @code void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); @endcode
* @param target Specifies the target to which the framebuffer is bound for all commands <span class="emphasis"><em>except</em></span>
<b>glNamedFramebufferTexture</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTexture</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param textarget For <b>glFramebufferTexture1D</b>, <b>glFramebufferTexture2D</b> and <b>glFramebufferTexture3D</b>, specifies what type
*                  of texture is expected in the <em class="parameter"><b>texture</b></em> parameter, or for cube map textures, which face
*                  is to be attached.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by all commands accepting a target parameter if it is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a target parameter if zero is bound to that target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture.
* @errors GL_INVALID_VALUE is generated by glFramebufferTexture3D if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE
*         minus one.
* @errors GL_INVALID_OPERATION is generated by all commands accepting a textarget parameter if texture is not zero, and textarget
*         and the effective target of texture are not compatible.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glNamedFramebufferTexture glad_glNamedFramebufferTexture
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;
/**
* @name glFramebufferTextureLayer, glNamedFramebufferTextureLayer - attach a single layer of a texture object as a logical buffer of a framebuffer object
* @usage
* @code void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @code void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer); @endcode
* @param target Specifies the target to which the framebuffer is bound for <b>glFramebufferTextureLayer</b>.
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferTextureLayer</b>.
* @param attachment Specifies the attachment point of the framebuffer.
* @param texture Specifies the name of an existing texture object to attach.
* @param level Specifies the mipmap level of the texture object to attach.
* @param layer Specifies the layer of the texture object to attach.
*
* @errors GL_INVALID_ENUM is generated by glFramebufferTexture if target is not one of the accepted framebuffer targets.
* @errors GL_INVALID_OPERATION is generated by glFramebufferTexture if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferTexture if framebuffer is not the name of an existing framebuffer
*         object.
* @errors GL_INVALID_ENUM is generated if attachment is not one of the accepted attachment points.
* @errors GL_INVALID_OPERATION is generated if texture is not zero and is not the name of an existing three-dimensional, two-dimensional
*         multisample array, one- or two-dimensional array, cube map, or cube map array texture.
* @errors GL_INVALID_VALUE is generated if texture is not zero and level is not a supported texture level for texture, as described
*         above.
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is larger than the value of GL_MAX_3D_TEXTURE_SIZE minus
*         one (for three-dimensional texture objects), or larger than the value of GL_MAX_ARRAY_TEXTURE_LAYERS minus one (for array
*         texture objects).
* @errors GL_INVALID_VALUE is generated if texture is not zero and layer is negative.
* @errors GL_INVALID_OPERATION is generated by if texture is a buffer texture.
*
*/
#define glNamedFramebufferTextureLayer glad_glNamedFramebufferTextureLayer
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;
/**
* @name glRenderbufferStorage, glNamedRenderbufferStorage - establish data storage, format and dimensions of a
renderbuffer object's image
* @usage
* @code void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorage</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorage</b> function.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorage if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorage if renderbuffer is not the name of an existing renderbuffer
*         object.
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glNamedRenderbufferStorage glad_glNamedRenderbufferStorage
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;
/**
* @name glRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample - establish data storage, format, dimensions and sample count of
a renderbuffer object's image
* @usage
* @code void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorageMultisample</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorageMultisample</b> function.
* @param samples Specifies the number of samples to be used for the renderbuffer object's storage.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorageMultisample function if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorageMultisample function if renderbuffer is not the name of an
*         existing renderbuffer object.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for internalformat.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glNamedRenderbufferStorageMultisample glad_glNamedRenderbufferStorageMultisample
GLAD_API_CALL PFNGLOBJECTLABELPROC glad_glObjectLabel;
/**
* @name glObjectLabel - label a named object identified within a namespace
* @usage
* @code void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label); @endcode
* @param identifier The namespace from which the name of the object is allocated.
* @param name The name of the object to label.
* @param length The length of the label to be used for the object.
* @param label The address of a string containing the label to assign to the object.
*
* @errors GL_INVALID_ENUM is generated if identifier is not one of the accepted object types.
* @errors GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier.
* @errors GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative,
*         is greater than the value of GL_MAX_LABEL_LENGTH.
*
*/
#define glObjectLabel glad_glObjectLabel
GLAD_API_CALL PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;
/**
* @name glObjectPtrLabel - label a sync object identified by a pointer
* @usage
* @code void glObjectPtrLabel(void * ptr, GLsizei length, const char * label); @endcode
* @param ptr A pointer identifying a sync object.
* @param length The length of the label to be used for the object.
* @param label The address of a string containing the label to assign to the object.
*
* @errors GL_INVALID_VALUE is generated if ptr is not a valid sync object.
* @errors GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative,
*         is greater than the value of GL_MAX_LABEL_LENGTH.
*
*/
#define glObjectPtrLabel glad_glObjectPtrLabel
GLAD_API_CALL PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;
// Unable to find the docs for this function!
#define glPatchParameterfv glad_glPatchParameterfv
GLAD_API_CALL PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;
// Unable to find the docs for this function!
#define glPatchParameteri glad_glPatchParameteri
GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;
/**
* @name glPauseTransformFeedback - pause transform feedback operations
* @usage
* @code void glPauseTransformFeedback(void); @endcode
*
* @errors GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is paused.
*
*/
#define glPauseTransformFeedback glad_glPauseTransformFeedback
GLAD_API_CALL PFNGLPIXELSTOREFPROC glad_glPixelStoref;
// Unable to find the docs for this function!
#define glPixelStoref glad_glPixelStoref
GLAD_API_CALL PFNGLPIXELSTOREIPROC glad_glPixelStorei;
// Unable to find the docs for this function!
#define glPixelStorei glad_glPixelStorei
GLAD_API_CALL PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
// Unable to find the docs for this function!
#define glPointParameterf glad_glPointParameterf
GLAD_API_CALL PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
// Unable to find the docs for this function!
#define glPointParameterfv glad_glPointParameterfv
GLAD_API_CALL PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
// Unable to find the docs for this function!
#define glPointParameteri glad_glPointParameteri
GLAD_API_CALL PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
// Unable to find the docs for this function!
#define glPointParameteriv glad_glPointParameteriv
GLAD_API_CALL PFNGLPOINTSIZEPROC glad_glPointSize;
/**
* @name glPointSize - specify the diameter of rasterized points
* @usage
* @code void glPointSize(GLfloat size); @endcode
* @param size Specifies the diameter of rasterized points. The initial value is 1.
* @note The point size specified by glPointSize is always returned when GL_POINT_SIZE is queried.  Clamping and rounding for points
*       have no effect on the specified value.
*
* @errors GL_INVALID_VALUE is generated if size is less than or equal to 0.
*
*/
#define glPointSize glad_glPointSize
GLAD_API_CALL PFNGLPOLYGONMODEPROC glad_glPolygonMode;
/**
* @name glPolygonMode - select a polygon rasterization mode
* @usage
* @code void glPolygonMode(GLenum face, GLenum mode); @endcode
* @param face Specifies the polygons that <em class="parameter"><b>mode</b></em> applies to. Must be <b>GL_FRONT_AND_BACK</b> for front-
*             and back-facing polygons.
* @param mode Specifies how polygons will be rasterized. Accepted values are <b>GL_POINT</b>, <b>GL_LINE</b>, and <b>GL_FILL</b>. The
*             initial value is <b>GL_FILL</b> for both front- and back-facing polygons.
* @note Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it
*       decomposes triangle stips and fans.
*
* @errors GL_INVALID_ENUM is generated if either face or mode is not an accepted value.
*
*/
#define glPolygonMode glad_glPolygonMode
GLAD_API_CALL PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
/**
* @name glPolygonOffset - set the scale and units used to calculate depth values
* @usage
* @code void glPolygonOffset(GLfloat factor, GLfloat units); @endcode
* @param factor Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
* @param units Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
*
*
*/
#define glPolygonOffset glad_glPolygonOffset
GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;
// Unable to find the docs for this function!
#define glPolygonOffsetClamp glad_glPolygonOffsetClamp
GLAD_API_CALL PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;
/**
* @name glPopDebugGroup - pop the active debug group
* @usage
* @code void glPopDebugGroup(void); @endcode
*
* @errors GL_STACK_UNDERFLOW is generated if an attempt is made to pop the default debug group from the stack.
*
*/
#define glPopDebugGroup glad_glPopDebugGroup
GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
/**
* @name glPrimitiveRestartIndex - specify the primitive restart index
* @usage
* @code void glPrimitiveRestartIndex(GLuint index); @endcode
* @param index Specifies the value to be interpreted as the primitive restart index.
* @note glPrimitiveRestartIndex is available only if the GL version is 3.1 or greater.
*
*
*/
#define glPrimitiveRestartIndex glad_glPrimitiveRestartIndex
GLAD_API_CALL PFNGLPROGRAMBINARYPROC glad_glProgramBinary;
/**
* @name glProgramBinary - load a program object with a program binary
* @usage
* @code void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length); @endcode
* @param program Specifies the name of a program object into which to load a program binary.
* @param binaryFormat Specifies the format of the binary data in binary.
* @param binary Specifies the address an array containing the binary to be loaded into <em class="parameter"><b>program</b></em>.
* @param length Specifies the number of bytes contained in <em class="parameter"><b>binary</b></em>.
* @note A program binary may fail to load if the implementation determines that there has been a change in hardware or software
*       configuration from when the program binary was produced such as having been compiled with an incompatible or outdated version
*       of the compiler.
*
* @errors GL_INVALID_OPERATION is generated if program is not the name of an existing program object.
* @errors GL_INVALID_ENUM is generated if binaryFormat is not a value recognized by the implementation.
*
*/
#define glProgramBinary glad_glProgramBinary
GLAD_API_CALL PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;
// Unable to find the docs for this function!
#define glProgramParameteri glad_glProgramParameteri
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1d glad_glProgramUniform1d
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1dv glad_glProgramUniform1dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1f glad_glProgramUniform1f
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1fv glad_glProgramUniform1fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1i glad_glProgramUniform1i
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1iv glad_glProgramUniform1iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1ui glad_glProgramUniform1ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform1uiv glad_glProgramUniform1uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2d glad_glProgramUniform2d
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2dv glad_glProgramUniform2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2f glad_glProgramUniform2f
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2fv glad_glProgramUniform2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2i glad_glProgramUniform2i
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2iv glad_glProgramUniform2iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2ui glad_glProgramUniform2ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform2uiv glad_glProgramUniform2uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3d glad_glProgramUniform3d
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3dv glad_glProgramUniform3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3f glad_glProgramUniform3f
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3fv glad_glProgramUniform3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3i glad_glProgramUniform3i
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3iv glad_glProgramUniform3iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3ui glad_glProgramUniform3ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform3uiv glad_glProgramUniform3uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4d glad_glProgramUniform4d
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4dv glad_glProgramUniform4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4f glad_glProgramUniform4f
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4fv glad_glProgramUniform4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4i glad_glProgramUniform4i
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4iv glad_glProgramUniform4iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4ui glad_glProgramUniform4ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniform4uiv glad_glProgramUniform4uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2dv glad_glProgramUniformMatrix2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2fv glad_glProgramUniformMatrix2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x3dv glad_glProgramUniformMatrix2x3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x3fv glad_glProgramUniformMatrix2x3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x4dv glad_glProgramUniformMatrix2x4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix2x4fv glad_glProgramUniformMatrix2x4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3dv glad_glProgramUniformMatrix3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3fv glad_glProgramUniformMatrix3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x2dv glad_glProgramUniformMatrix3x2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x2fv glad_glProgramUniformMatrix3x2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x4dv glad_glProgramUniformMatrix3x4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix3x4fv glad_glProgramUniformMatrix3x4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4dv glad_glProgramUniformMatrix4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4fv glad_glProgramUniformMatrix4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x2dv glad_glProgramUniformMatrix4x2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x2fv glad_glProgramUniformMatrix4x2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x3dv glad_glProgramUniformMatrix4x3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;
/**
* @name glProgramUniform - Specify the value of a uniform variable for a specified program object
* @usage
* @code void glProgramUniform1f(GLuint program, GLint location, GLfloat v0); @endcode
* @code void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glProgramUniform1i(GLuint program, GLint location, GLint v0); @endcode
* @code void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1); @endcode
* @code void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glProgramUniform1ui(GLuint program, GLint location, GLuint v0); @endcode
* @code void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1); @endcode
* @code void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value); @endcode
* @code void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param program Specifies the handle of the program containing the uniform variable to be modified.
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector commands (<b>glProgramUniform*v</b>), specifies the number of elements that are to be modified. This should
*              be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glProgramUniform1i and glProgramUniform1iv are the only two functions that may be used to load uniform variables defined
*       as sampler types. Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in within program, an error
*       will be generated, and no changes will be made to the uniform variable storage of program. If location is equal to
*       -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
*
* @errors GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glProgramUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.
*
*/
#define glProgramUniformMatrix4x3fv glad_glProgramUniformMatrix4x3fv
GLAD_API_CALL PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
/**
* @name glProvokingVertex - specifiy the vertex to be used as the source of data for flat shaded varyings
* @usage
* @code void glProvokingVertex(GLenum provokeMode); @endcode
* @param provokeMode Specifies the vertex to be used as the source of data for flat shaded varyings.
* @note glProvokingVertex is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_ENUM is generated if provokeMode is not an accepted value.
*
*/
#define glProvokingVertex glad_glProvokingVertex
GLAD_API_CALL PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;
/**
* @name glPushDebugGroup - push a named debug group into the command stream
* @usage
* @code void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message); @endcode
* @param source The source of the debug message.
* @param id The identifier of the message.
* @param length The length of the message to be sent to the debug output stream.
* @param message The a string containing the message to be sent to the debug output stream.
*
* @errors GL_INVALID_ENUM is generated if the value of source is neither GL_DEBUG_SOURCE_APPLICATION nor GL_DEBUG_SOURCE_THIRD_PARTY.
* @errors GL_INVALID_VALUE is generated if length is negative and the number of characters in message, excluding the null-terminator,
*         is not less than the value of GL_MAX_DEBUG_MESSAGE_LENGTH.
*
*/
#define glPushDebugGroup glad_glPushDebugGroup
GLAD_API_CALL PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
/**
* @name glQueryCounter - record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
* @usage
* @code void glQueryCounter(GLuint id, GLenum target); @endcode
* @param id Specify the name of a query object into which to record the GL time.
* @param target Specify the counter to query. <em class="parameter"><b>target</b></em> must be <b>GL_TIMESTAMP</b>.
* @note glQueryCounter is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_OPERATION is generated if id is the name of a query object that is already in use within a glBeginQuery / glEndQuery
*         block.
* @errors GL_INVALID_VALUE is generated if id is not the name of a query object returned from a previous call to glGenQueries.
* @errors GL_INVALID_ENUM is generated if target is not GL_TIMESTAMP.
*
*/
#define glQueryCounter glad_glQueryCounter
GLAD_API_CALL PFNGLREADBUFFERPROC glad_glReadBuffer;
/**
* @name glReadBuffer, glNamedFramebufferReadBuffer - select a color buffer source for pixels
* @usage
* @code void glReadBuffer(GLenum mode); @endcode
* @code void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode); @endcode
* @param framebuffer Specifies the name of the framebuffer object for <b>glNamedFramebufferReadBuffer</b> function.
* @param mode Specifies a color buffer. Accepted values are <b>GL_FRONT_LEFT</b>, <b>GL_FRONT_RIGHT</b>, <b>GL_BACK_LEFT</b>, <b>GL_BACK_RIGHT</b>,
*             <b>GL_FRONT</b>, <b>GL_BACK</b>, <b>GL_LEFT</b>, <b>GL_RIGHT</b>, and the constants <b>GL_COLOR_ATTACHMENT</b><span
*             class="emphasis"><em>i</em></span>.
*
* @errors GL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values.
* @errors GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist.
* @errors GL_INVALID_OPERATION is generated by glNamedFramebufferReadBuffer if framebuffer is not zero or the name of an existing
*         framebuffer object.
*
*/
#define glReadBuffer glad_glReadBuffer
GLAD_API_CALL PFNGLREADPIXELSPROC glad_glReadPixels;
/**
* @name glReadPixels, glReadnPixels - read a block of pixels from the frame buffer
* @usage
* @code void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data); @endcode
* @code void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data); @endcode
* @param x, y Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner
*             of a rectangular block of pixels.
* @param width, height Specify the dimensions of the pixel rectangle. <em class="parameter"><b>width</b></em> and <em class="parameter"><b>height</b></em>
*                      of one correspond to a single pixel.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RGB</b>, <b>GL_BGR</b>, <b>GL_RGBA</b>,
*               and <b>GL_BGRA</b>.
* @param type Specifies the data type of the pixel data. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>, <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>,
*             or <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>data</b></em> for <b>glReadnPixels</b> function.
* @param data Returns the pixel data.
* @note Values for pixels that lie outside the window connected to the current GL context are undefined.
* @note If an error is generated, no change is made to the contents of data.
*
* @errors GL_INVALID_ENUM is generated if format or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_STENCIL and there is no depth buffer or if there is no stencil buffer.
* @errors GL_INVALID_ENUM is generated if format is GL_DEPTH_STENCIL and type is not GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated if GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the
*         value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero.
* @errors GL_INVALID_OPERATION is generated by glReadnPixels if the buffer size required to store the requested data is greater than
*         bufSize.
*
*/
#define glReadPixels glad_glReadPixels
GLAD_API_CALL PFNGLREADNPIXELSPROC glad_glReadnPixels;
/**
* @name glReadPixels, glReadnPixels - read a block of pixels from the frame buffer
* @usage
* @code void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data); @endcode
* @code void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data); @endcode
* @param x, y Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner
*             of a rectangular block of pixels.
* @param width, height Specify the dimensions of the pixel rectangle. <em class="parameter"><b>width</b></em> and <em class="parameter"><b>height</b></em>
*                      of one correspond to a single pixel.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RGB</b>, <b>GL_BGR</b>, <b>GL_RGBA</b>,
*               and <b>GL_BGRA</b>.
* @param type Specifies the data type of the pixel data. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_24_8</b>, <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>, <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>,
*             or <b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.
* @param bufSize Specifies the size of the buffer <em class="parameter"><b>data</b></em> for <b>glReadnPixels</b> function.
* @param data Returns the pixel data.
* @note Values for pixels that lie outside the window connected to the current GL context are undefined.
* @note If an error is generated, no change is made to the contents of data.
*
* @errors GL_INVALID_ENUM is generated if format or type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_STENCIL and there is no depth buffer or if there is no stencil buffer.
* @errors GL_INVALID_ENUM is generated if format is GL_DEPTH_STENCIL and type is not GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer
*         object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data
*         would be packed to the buffer object such that the memory writes required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_OPERATION is generated if GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the
*         value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero.
* @errors GL_INVALID_OPERATION is generated by glReadnPixels if the buffer size required to store the requested data is greater than
*         bufSize.
*
*/
#define glReadnPixels glad_glReadnPixels
GLAD_API_CALL PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;
/**
* @name glReleaseShaderCompiler - release resources consumed by the implementation's shader compiler
* @usage
* @code void glReleaseShaderCompiler(void); @endcode
*
*
*/
#define glReleaseShaderCompiler glad_glReleaseShaderCompiler
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
/**
* @name glRenderbufferStorage, glNamedRenderbufferStorage - establish data storage, format and dimensions of a
renderbuffer object's image
* @usage
* @code void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorage</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorage</b> function.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorage if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorage if renderbuffer is not the name of an existing renderbuffer
*         object.
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glRenderbufferStorage glad_glRenderbufferStorage
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
/**
* @name glRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample - establish data storage, format, dimensions and sample count of
a renderbuffer object's image
* @usage
* @code void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies a binding target of the allocation for <b>glRenderbufferStorageMultisample</b> function. Must be <b>GL_RENDERBUFFER</b>.
* @param renderbuffer Specifies the name of the renderbuffer object for <b>glNamedRenderbufferStorageMultisample</b> function.
* @param samples Specifies the number of samples to be used for the renderbuffer object's storage.
* @param internalformat Specifies the internal format to use for the renderbuffer object's image.
* @param width Specifies the width of the renderbuffer, in pixels.
* @param height Specifies the height of the renderbuffer, in pixels.
*
* @errors GL_INVALID_ENUM is generated by glRenderbufferStorageMultisample function if target is not GL_RENDERBUFFER.
* @errors GL_INVALID_OPERATION is generated by glNamedRenderbufferStorageMultisample function if renderbuffer is not the name of an
*         existing renderbuffer object.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for internalformat.
* @errors GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES
* @errors GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE.
* @errors GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size.
*
*/
#define glRenderbufferStorageMultisample glad_glRenderbufferStorageMultisample
GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;
/**
* @name glResumeTransformFeedback - resume transform feedback operations
* @usage
* @code void glResumeTransformFeedback(void); @endcode
*
* @errors GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is not paused.
*
*/
#define glResumeTransformFeedback glad_glResumeTransformFeedback
GLAD_API_CALL PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
/**
* @name glSampleCoverage - specify multisample coverage parameters
* @usage
* @code void glSampleCoverage(GLfloat value, GLboolean invert); @endcode
* @param value Specify a single floating-point sample coverage value.  The value is clamped to the range <math overflow="scroll">
<mfenced
*              close="]" open="[">
<mn>0</mn>
<mn>1</mn>
</mfenced>
</math>. The initial value is 1. 0.
* @param invert Specify a single boolean value representing if the coverage masks should be inverted.  <b>GL_TRUE</b> and <b>GL_FALSE</b>
*               are accepted.  The initial value is <b>GL_FALSE</b>.
* @note The type of the value parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described
*       in detail on the removedTypes page.
*
*
*/
#define glSampleCoverage glad_glSampleCoverage
GLAD_API_CALL PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
/**
* @name glSampleMaski - set the value of a sub-word of the sample mask
* @usage
* @code void glSampleMaski(GLuint maskNumber, GLbitfield mask); @endcode
* @param maskNumber Specifies which 32-bit sub-word of the sample mask to update.
* @param mask Specifies the new value of the mask sub-word.
* @note glSampleMaski is available only if the GL version is 3.2 or greater, or if the ARB_texture_multisample extension is supported.
*
* @errors GL_INVALID_VALUE is generated if maskIndex is greater than or equal to the value of GL_MAX_SAMPLE_MASK_WORDS.
*
*/
#define glSampleMaski glad_glSampleMaski
GLAD_API_CALL PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
// Unable to find the docs for this function!
#define glSamplerParameterIiv glad_glSamplerParameterIiv
GLAD_API_CALL PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
// Unable to find the docs for this function!
#define glSamplerParameterIuiv glad_glSamplerParameterIuiv
GLAD_API_CALL PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
// Unable to find the docs for this function!
#define glSamplerParameterf glad_glSamplerParameterf
GLAD_API_CALL PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
// Unable to find the docs for this function!
#define glSamplerParameterfv glad_glSamplerParameterfv
GLAD_API_CALL PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
// Unable to find the docs for this function!
#define glSamplerParameteri glad_glSamplerParameteri
GLAD_API_CALL PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
// Unable to find the docs for this function!
#define glSamplerParameteriv glad_glSamplerParameteriv
GLAD_API_CALL PFNGLSCISSORPROC glad_glScissor;
/**
* @name glScissor - define the scissor box
* @usage
* @code void glScissor(GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param x, y Specify the lower left corner of the scissor box. Initially (0, 0).
* @param width, height Specify the width and height of the scissor box. When a GL context is first attached to a window, <em class="parameter"><b>width</b></em>
*                      and <em class="parameter"><b>height</b></em> are set to the dimensions of that window.
*
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
*
*/
#define glScissor glad_glScissor
GLAD_API_CALL PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;
// Unable to find the docs for this function!
#define glScissorArrayv glad_glScissorArrayv
GLAD_API_CALL PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;
/**
* @name glScissorIndexed - define the scissor box for a specific viewport
* @usage
* @code void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height); @endcode
* @code void glScissorIndexedv(GLuint index, const GLint *v); @endcode
* @param index Specifies the index of the viewport whose scissor box to modify.
* @param left, bottom Specify the coordinate of the bottom left corner of the scissor box, in pixels.
* @param width, height Specify ths dimensions of the scissor box, in pixels.
* @param v For <b>glScissorIndexedv</b>, specifies the address of an array containing the left, bottom, width and height of each scissor
*          box, in that order.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS.
* @errors GL_INVALID_VALUE is generated if any width or height specified in the array v is negative.
*
*/
#define glScissorIndexed glad_glScissorIndexed
GLAD_API_CALL PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;
/**
* @name glScissorIndexed - define the scissor box for a specific viewport
* @usage
* @code void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height); @endcode
* @code void glScissorIndexedv(GLuint index, const GLint *v); @endcode
* @param index Specifies the index of the viewport whose scissor box to modify.
* @param left, bottom Specify the coordinate of the bottom left corner of the scissor box, in pixels.
* @param width, height Specify ths dimensions of the scissor box, in pixels.
* @param v For <b>glScissorIndexedv</b>, specifies the address of an array containing the left, bottom, width and height of each scissor
*          box, in that order.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS.
* @errors GL_INVALID_VALUE is generated if any width or height specified in the array v is negative.
*
*/
#define glScissorIndexedv glad_glScissorIndexedv
GLAD_API_CALL PFNGLSHADERBINARYPROC glad_glShaderBinary;
/**
* @name glShaderBinary - load pre-compiled shader binaries
* @usage
* @code void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length); @endcode
* @param count Specifies the number of shader object handles contained in <em class="parameter"><b>shaders</b></em>.
* @param shaders Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
* @param binaryFormat Specifies the format of the shader binaries contained in <em class="parameter"><b>binary</b></em>.
* @param binary Specifies the address of an array of bytes containing pre-compiled binary shader code.
* @param length Specifies the length of the array whose address is given in <em class="parameter"><b>binary</b></em>.
*
* @errors GL_INVALID_OPERATION is generated if more than one of the handles in shaders refers to the same shader object.
* @errors GL_INVALID_ENUM is generated if binaryFormat is not an accepted value.
* @errors GL_INVALID_VALUE is generated if the data pointed to by binary does not match the format specified by binaryFormat.
*
*/
#define glShaderBinary glad_glShaderBinary
GLAD_API_CALL PFNGLSHADERSOURCEPROC glad_glShaderSource;
/**
* @name glShaderSource - Replaces the source code in a shader object
* @usage
* @code void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length); @endcode
* @param shader Specifies the handle of the shader object whose source code is to be replaced.
* @param count Specifies the number of elements in the <em class="parameter"><b>string</b></em> and <em class="parameter"><b>length</b></em>
*              arrays.
* @param string Specifies an array of pointers to strings containing the source code to be loaded into the shader.
* @param length Specifies an array of string lengths.
* @note OpenGL copies the shader source code strings when glShaderSource is called, so an application may free its copy of the source
*       code strings immediately after the function returns.
*
* @errors GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if shader is not a shader object.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
*
*/
#define glShaderSource glad_glShaderSource
GLAD_API_CALL PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;
/**
* @name glShaderStorageBlockBinding - change an active shader storage block binding
* @usage
* @code void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding); @endcode
* @param program The name of the program containing the block whose binding to change.
* @param storageBlockIndex The index storage block within the program.
* @param storageBlockBinding The index storage block binding to associate with the specified storage block.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of either a program or shader object.
* @errors GL_INVALID_OPERATION is generated if program is the name of a shader object.
* @errors GL_INVALID_VALUE is generated if storageBlockIndex is not an active shader storage block index in program, or if storageBlockBinding
*         is greater than or equal to the value of MAX_SHADER_STORAGE_BUFFER_BINDINGS.
*
*/
#define glShaderStorageBlockBinding glad_glShaderStorageBlockBinding
GLAD_API_CALL PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader;
// Unable to find the docs for this function!
#define glSpecializeShader glad_glSpecializeShader
GLAD_API_CALL PFNGLSTENCILFUNCPROC glad_glStencilFunc;
/**
* @name glStencilFunc - set front and back function and reference value for stencil testing
* @usage
* @code void glStencilFunc(GLenum func, GLint ref, GLuint mask); @endcode
* @param func Specifies the test function. Eight symbolic constants are valid: <b>GL_NEVER</b>, <b>GL_LESS</b>, <b>GL_LEQUAL</b>, <b>GL_GREATER</b>,
*             <b>GL_GEQUAL</b>, <b>GL_EQUAL</b>, <b>GL_NOTEQUAL</b>, and <b>GL_ALWAYS</b>. The initial value is <b>GL_ALWAYS</b>.
* @param ref Specifies the reference value for the stencil test. <em class="parameter"><b>ref</b></em> is clamped to the range <math
*            overflow="scroll">
<mfenced close="]" open="[">
<mn>0</mn>
<mrow>
<msup><mn>2</mn>
<mi mathvariant="italic">n</mi>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfenced>
</math>,
*            where <math overflow="scroll"><mi mathvariant="italic">n</mi></math>
*            is the number of bitplanes in the stencil buffer. The initial value is 0.
* @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial
*             value is all 1's.
* @note Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil test always passes.
* @note glStencilFunc is the same as calling glStencilFuncSeparate with face set to GL_FRONT_AND_BACK.
*
* @errors GL_INVALID_ENUM is generated if func is not one of the eight accepted values.
*
*/
#define glStencilFunc glad_glStencilFunc
GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
/**
* @name glStencilFuncSeparate - set front and/or back function and reference value for stencil testing
* @usage
* @code void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask); @endcode
* @param face Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: <b>GL_FRONT</b>, <b>GL_BACK</b>,
*             and <b>GL_FRONT_AND_BACK</b>.
* @param func Specifies the test function. Eight symbolic constants are valid: <b>GL_NEVER</b>, <b>GL_LESS</b>, <b>GL_LEQUAL</b>, <b>GL_GREATER</b>,
*             <b>GL_GEQUAL</b>, <b>GL_EQUAL</b>, <b>GL_NOTEQUAL</b>, and <b>GL_ALWAYS</b>. The initial value is <b>GL_ALWAYS</b>.
* @param ref Specifies the reference value for the stencil test. <em class="parameter"><b>ref</b></em> is clamped to the range <math
*            overflow="scroll">
<mfenced close="]" open="[">
<mn>0</mn>
<mrow>
<msup><mn>2</mn>
<mi mathvariant="italic">n</mi>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfenced>
</math>,
*            where <math overflow="scroll"><mi mathvariant="italic">n</mi></math>
*            is the number of bitplanes in the stencil buffer. The initial value is 0.
* @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial
*             value is all 1's.
* @note Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil test always passes.
*
* @errors GL_INVALID_ENUM is generated if func is not one of the eight accepted values.
*
*/
#define glStencilFuncSeparate glad_glStencilFuncSeparate
GLAD_API_CALL PFNGLSTENCILMASKPROC glad_glStencilMask;
/**
* @name glStencilMask - control the front and back writing of individual bits in the stencil planes
* @usage
* @code void glStencilMask(GLuint mask); @endcode
* @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all
*             1's.
* @note glStencilMask is the same as calling glStencilMaskSeparate with face set to GL_FRONT_AND_BACK.
*
*
*/
#define glStencilMask glad_glStencilMask
GLAD_API_CALL PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
/**
* @name glStencilMaskSeparate - control the front and/or back writing of individual bits in the stencil planes
* @usage
* @code void glStencilMaskSeparate(GLenum face, GLuint mask); @endcode
* @param face Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: <b>GL_FRONT</b>,
*             <b>GL_BACK</b>, and <b>GL_FRONT_AND_BACK</b>.
* @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all
*             1's.
*
* @errors GL_INVALID_ENUM is generated if face is not one of the accepted tokens.
*
*/
#define glStencilMaskSeparate glad_glStencilMaskSeparate
GLAD_API_CALL PFNGLSTENCILOPPROC glad_glStencilOp;
/**
* @name glStencilOp - set front and back stencil test actions
* @usage
* @code void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass); @endcode
* @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: <b>GL_KEEP</b>, <b>GL_ZERO</b>,
*              <b>GL_REPLACE</b>, <b>GL_INCR</b>, <b>GL_INCR_WRAP</b>, <b>GL_DECR</b>, <b>GL_DECR_WRAP</b>, and <b>GL_INVERT</b>.
*              The initial value is <b>GL_KEEP</b>.
* @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. <em class="parameter"><b>dpfail</b></em>
*               accepts the same symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either
*               there is no depth buffer or depth testing is not enabled. <em class="parameter"><b>dppass</b></em> accepts the same
*               symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @note Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil tests always pass, regardless of any call to glStencilOp.
* @note glStencilOp is the same as calling glStencilOpSeparate with face set to GL_FRONT_AND_BACK.
*
* @errors GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the defined constant values.
*
*/
#define glStencilOp glad_glStencilOp
GLAD_API_CALL PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
/**
* @name glStencilOpSeparate - set front and/or back stencil test actions
* @usage
* @code void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass); @endcode
* @param face Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: <b>GL_FRONT</b>, <b>GL_BACK</b>,
*             and <b>GL_FRONT_AND_BACK</b>.
* @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: <b>GL_KEEP</b>, <b>GL_ZERO</b>,
*              <b>GL_REPLACE</b>, <b>GL_INCR</b>, <b>GL_INCR_WRAP</b>, <b>GL_DECR</b>, <b>GL_DECR_WRAP</b>, and <b>GL_INVERT</b>.
*              The initial value is <b>GL_KEEP</b>.
* @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. <em class="parameter"><b>dpfail</b></em>
*               accepts the same symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either
*               there is no depth buffer or depth testing is not enabled. <em class="parameter"><b>dppass</b></em> accepts the same
*               symbolic constants as <em class="parameter"><b>sfail</b></em>. The initial value is <b>GL_KEEP</b>.
* @note Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if
*       the stencil test always passes.
*
* @errors GL_INVALID_ENUM is generated if face is any value other than GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
* @errors GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the eight defined constant values.
*
*/
#define glStencilOpSeparate glad_glStencilOpSeparate
GLAD_API_CALL PFNGLTEXBUFFERPROC glad_glTexBuffer;
/**
* @name glTexBuffer, glTextureBuffer - attach a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer); @endcode
* @code void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexBuffer</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBuffer</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
*
* @errors GL_INVALID_ENUM is generated by glTexBuffer if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBuffer if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBuffer if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
*
*/
#define glTexBuffer glad_glTexBuffer
GLAD_API_CALL PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;
/**
* @name glTexBufferRange, glTextureBufferRange - attach a range of a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size); @endcode
* @code void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexBufferRange</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBufferRange</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
* @param offset Specifies the offset of the start of the range of the buffer's data store to attach.
* @param size Specifies the size of the range of the buffer's data store to attach.
*
* @errors GL_INVALID_ENUM is generated by glTexBufferRange if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBufferRange if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBufferRange if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset is negative, if size is less than or equal to zero, or if offset + size is greater
*         than the value of GL_BUFFER_SIZE for buffer.
* @errors GL_INVALID_VALUE is generated if offset is not an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.
*
*/
#define glTexBufferRange glad_glTexBufferRange
GLAD_API_CALL PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
/**
* @name glTexImage1D - specify a one-dimensional texture image
* @usage
* @code void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_1D</b> or <b>GL_PROXY_TEXTURE_1D</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the
*                       sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
* @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
*              The height of the 1D texture image is 1.
* @param border This value must be 0.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_RG_INTEGER</b>, <b>GL_RGB_INTEGER</b>,
*               <b>GL_BGR_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGRA_INTEGER</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>,
*             <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
*             <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param data Specifies a pointer to the image data in memory.
* @note glPixelStore modes affect texture images.
* @note data may be a null pointer. In this case texture memory is allocated to accommodate a texture of width width. You can then
*       download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized
*       portion of the texture image to a primitive.
* @note glTexImage1D specifies the one-dimensional texture for the current texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX may be used for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.  Format constants other than GL_STENCIL_INDEX
*         are accepted.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not one of the accepted resolution and format symbolic constants.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalformat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,
*         GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32, and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexImage1D glad_glTexImage1D
GLAD_API_CALL PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
/**
* @name glTexImage2D - specify a two-dimensional texture image
* @usage
* @code void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data); @endcode
* @param target Specifies the target texture. Must be <b>GL_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_PROXY_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image. If <em class="parameter"><b>target</b></em> is <b>GL_TEXTURE_RECTANGLE</b>
*              or <b>GL_PROXY_TEXTURE_RECTANGLE</b>, <em class="parameter"><b>level</b></em> must be 0.
* @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the
*                       sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
* @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
* @param height Specifies the height of the texture image, or the number of layers in a texture array, in the case of the <b>GL_TEXTURE_1D_ARRAY</b>
*               and <b>GL_PROXY_TEXTURE_1D_ARRAY</b> targets. All implementations support 2D texture images that are at least
*               1024 texels high, and texture arrays that are at least 256 layers deep.
* @param border This value must be 0.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_RG_INTEGER</b>, <b>GL_RGB_INTEGER</b>,
*               <b>GL_BGR_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGRA_INTEGER</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>,
*             <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
*             <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param data Specifies a pointer to the image data in memory.
* @note The glPixelStore mode affects texture images.
* @note data may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width width and height
*       height. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to
*       apply an uninitialized portion of the texture image to a primitive.
* @note glTexImage2D specifies the two-dimensional texture for the current texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX may be used for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D,
*         GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
*         GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
*         or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
* @errors GL_INVALID_ENUM is generated if target is one of the six cube map 2D image targets and the width and height parameters are
*         not equal.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than
*         0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than 0 or
*         greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not one of the accepted resolution and format symbolic constants.
* @errors GL_INVALID_VALUE is generated if width or height is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV, and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV, and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_RECTANGLE,
*         and internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F.
* @errors GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalformat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,
*         GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F.
* @errors GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or
*         GL_DEPTH_COMPONENT32F, and format is not GL_DEPTH_COMPONENT.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
* @errors GL_INVALID_VALUE is generated if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE and level is not 0.
*
*/
#define glTexImage2D glad_glTexImage2D
GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
/**
* @name glTexImage2DMultisample - establish the data storage, format, dimensions, and number of samples of a multisample texture's image
* @usage
* @code void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target of the operation. <em class="parameter"><b>target</b></em> must be <b>GL_TEXTURE_2D_MULTISAMPLE</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE</b>.
* @param samples The number of samples in the multisample texture's image.
* @param internalformat The internal format to be used to store the multisample texture's image. <em class="parameter"><b>internalformat</b></em>
*                       must specify a color-renderable, depth-renderable, or stencil-renderable format.
* @param width The width of the multisample texture's image, in texels.
* @param height The height of the multisample texture's image, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @note glTexImage2DMultisample is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than
*         the value of GL_MAX_DEPTH_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of
*         GL_MAX_COLOR_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES.
* @errors GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
*
*/
#define glTexImage2DMultisample glad_glTexImage2DMultisample
GLAD_API_CALL PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
/**
* @name glTexImage3D - specify a three-dimensional texture image
* @usage
* @code void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data); @endcode
* @param target Specifies the target texture. Must be one of <b>GL_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_TEXTURE_2D_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_ARRAY</b>.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <math overflow="scroll"><mi mathvariant="italic">n</mi></math>
*              is the <math overflow="scroll">
<msup><mi mathvariant="italic">n</mi>
<mi mathvariant="italic">th</mi>
</msup>
</math>
*              mipmap reduction image.
* @param internalformat Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the
*                       sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
* @param width Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
* @param height Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
* @param depth Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture
*              images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
* @param border This value must be 0.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_RED_INTEGER</b>, <b>GL_RG_INTEGER</b>, <b>GL_RGB_INTEGER</b>,
*               <b>GL_BGR_INTEGER</b>, <b>GL_RGBA_INTEGER</b>, <b>GL_BGRA_INTEGER</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
*               <b>GL_DEPTH_STENCIL</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>,
*             <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
*             <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param data Specifies a pointer to the image data in memory.
* @note The glPixelStore mode affects texture images.
* @note data may be a null pointer. In this case texture memory is allocated to accommodate a texture of width width, height height,
*       and depth depth. You can then download subtextures to initialize this texture memory. The image is undefined if the
*       user tries to apply an uninitialized portion of the texture image to a primitive.
* @note glTexImage3D specifies the three-dimensional texture for the current texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX may be used for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target is not GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.  Format constants other than GL_STENCIL_INDEX
*         and GL_DEPTH_COMPONENT are accepted.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if internalformat is not one of the accepted resolution and format symbolic constants.
* @errors GL_INVALID_VALUE is generated if width, height, or depth is less than 0 or greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if border is not 0.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format or internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24,
*         or GL_DEPTH_COMPONENT32.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexImage3D glad_glTexImage3D
GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
/**
* @name glTexImage3DMultisample - establish the data storage, format, dimensions, and number of samples of a multisample texture's image
* @usage
* @code void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target of the operation. <em class="parameter"><b>target</b></em> must be <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param samples The number of samples in the multisample texture's image.
* @param internalformat The internal format to be used to store the multisample texture's image. <em class="parameter"><b>internalformat</b></em>
*                       must specify a color-renderable, depth-renderable, or stencil-renderable format.
* @param width The width of the multisample texture's image, in texels.
* @param height The height of the multisample texture's image, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
* @note glTexImage2DMultisample is available only if the GL version is 3.2 or greater.
*
* @errors GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than
*         the value of GL_MAX_DEPTH_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of
*         GL_MAX_COLOR_TEXTURE_SAMPLES.
* @errors GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the
*         value of GL_MAX_INTEGER_SAMPLES.
* @errors GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if depth is negative or is greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
*
*/
#define glTexImage3DMultisample glad_glTexImage3DMultisample
GLAD_API_CALL PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
// Unable to find the docs for this function!
#define glTexParameterIiv glad_glTexParameterIiv
GLAD_API_CALL PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
// Unable to find the docs for this function!
#define glTexParameterIuiv glad_glTexParameterIuiv
GLAD_API_CALL PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
// Unable to find the docs for this function!
#define glTexParameterf glad_glTexParameterf
GLAD_API_CALL PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
// Unable to find the docs for this function!
#define glTexParameterfv glad_glTexParameterfv
GLAD_API_CALL PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
// Unable to find the docs for this function!
#define glTexParameteri glad_glTexParameteri
GLAD_API_CALL PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
// Unable to find the docs for this function!
#define glTexParameteriv glad_glTexParameteriv
GLAD_API_CALL PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;
/**
* @name glTexStorage1D, glTextureStorage1D - simultaneously specify storage for all levels of a one-dimensional texture
* @usage
* @code void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @code void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage1D</b>. Must be one of <b>GL_TEXTURE_1D</b>
*               or <b>GL_PROXY_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage1D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if levels is greater than log2 width +1 .
*
*/
#define glTexStorage1D glad_glTexStorage1D
GLAD_API_CALL PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;
/**
* @name glTexStorage2D, glTextureStorage2D - simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
* @usage
* @code void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2D</b>. Must be one of <b>GL_TEXTURE_2D</b>,
*               <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_PROXY_TEXTURE_RECTANGLE</b>, or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than
*         log2 width +1 .
* @errors GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater
*         than log2 max width, height +1 .
*
*/
#define glTexStorage2D glad_glTexStorage2D
GLAD_API_CALL PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;
/**
* @name glTexStorage2DMultisample, glTextureStorage2DMultisample - specify storage for a two-dimensional multisample texture
* @usage
* @code void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTexStorage2DMultisample glad_glTexStorage2DMultisample
GLAD_API_CALL PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;
/**
* @name glTexStorage3D, glTextureStorage3D - simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
* @usage
* @code void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @code void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3D</b>. Must be one of <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_2D_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in texels.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height, depth or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D and levels is greater than log2 max
*         width, height, depth +1 .
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXURE_CUBE_MAP_ARRAY,
*         or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is greater than log2 max width, height +1 .
*
*/
#define glTexStorage3D glad_glTexStorage3D
GLAD_API_CALL PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;
/**
* @name glTexStorage3DMultisample, glTextureStorage3DMultisample - specify storage for a two-dimensional multisample array texture
* @usage
* @code void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in layers.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if depth is less than 1 or greater than the value of GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTexStorage3DMultisample glad_glTexStorage3DMultisample
GLAD_API_CALL PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
/**
* @name glTexSubImage1D, glTextureSubImage1D - specify a one-dimensional texture subimage
* @usage
* @code void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage1D</b>. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @note glPixelStore modes affect texture images.
* @note glTexSubImage1D and glTextureSubImage1D specify a one-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the allowable values.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , or if xoffset+width > w-b , where w is the GL_TEXTURE_WIDTH, and b is the
*         width of the GL_TEXTURE_BORDER of the texture image being modified. Note that w includes twice the border width.
* @errors GL_INVALID_VALUE is generated if width is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexSubImage1D glad_glTexSubImage1D
GLAD_API_CALL PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
/**
* @name glTexSubImage2D, glTextureSubImage2D - specify a two-dimensional texture subimage
* @usage
* @code void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage2D</b>. Must be <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or <b>GL_TEXTURE_1D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @note glPixelStore modes affect texture images.
* @note glTexSubImage2D and glTextureSubImage3D specify a two-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , where w is
*         the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that
*         w and h include twice the border width.
* @errors GL_INVALID_VALUE is generated if width or height is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexSubImage2D glad_glTexSubImage2D
GLAD_API_CALL PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
/**
* @name glTexSubImage3D, glTextureSubImage3D - specify a three-dimensional texture subimage
* @usage
* @code void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage3D</b>. Must be <b>GL_TEXTURE_3D</b> or <b>GL_TEXTURE_2D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @note The glPixelStore modes affect texture images.
* @note glTexSubImage3D and glTextureSubImage3D specify a three-dimensional or two-dimensional array subtexture for the current
*       texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , or zoffset<
*         -b , or zoffset+depth > d-b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and
*         b is the border width of the texture image being modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_VALUE is generated if width, height, or depth is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTexSubImage3D glad_glTexSubImage3D
GLAD_API_CALL PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;
/**
* @name glTextureBarrier - controls the ordering of reads and writes to rendered fragments across drawing commands
* @usage
* @code void glTextureBarrier(void); @endcode
* @note The situation described above is referred to as a rendering feedback loop and is discussed in more detail in section 9.3
*       of the OpenGL 4.5 Specification.
*
* @errors None.
*
*/
#define glTextureBarrier glad_glTextureBarrier
GLAD_API_CALL PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;
/**
* @name glTexBuffer, glTextureBuffer - attach a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer); @endcode
* @code void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexBuffer</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBuffer</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
*
* @errors GL_INVALID_ENUM is generated by glTexBuffer if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBuffer if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBuffer if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
*
*/
#define glTextureBuffer glad_glTextureBuffer
GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;
/**
* @name glTexBufferRange, glTextureBufferRange - attach a range of a buffer object's data store to a buffer texture object
* @usage
* @code void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size); @endcode
* @code void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexBufferRange</b>. Must be <b>GL_TEXTURE_BUFFER</b>.
* @param texture Specifies the texture object name for <b>glTextureBufferRange</b>.
* @param internalformat Specifies the internal format of the data in the store belonging to <em class="parameter"><b>buffer</b></em>.
* @param buffer Specifies the name of the buffer object whose storage to attach to the active buffer texture.
* @param offset Specifies the offset of the start of the range of the buffer's data store to attach.
* @param size Specifies the size of the range of the buffer's data store to attach.
*
* @errors GL_INVALID_ENUM is generated by glTexBufferRange if target is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_OPERATION is generated by glTextureBufferRange if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated by glTextureBufferRange if the effective target of texture is not GL_TEXTURE_BUFFER.
* @errors GL_INVALID_ENUM is generated if internalformat is not one of the sized internal formats described above.
* @errors GL_INVALID_OPERATION is generated if buffer is not zero and is not the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if offset is negative, if size is less than or equal to zero, or if offset + size is greater
*         than the value of GL_BUFFER_SIZE for buffer.
* @errors GL_INVALID_VALUE is generated if offset is not an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.
*
*/
#define glTextureBufferRange glad_glTextureBufferRange
GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;
// Unable to find the docs for this function!
#define glTextureParameterIiv glad_glTextureParameterIiv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;
// Unable to find the docs for this function!
#define glTextureParameterIuiv glad_glTextureParameterIuiv
GLAD_API_CALL PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;
// Unable to find the docs for this function!
#define glTextureParameterf glad_glTextureParameterf
GLAD_API_CALL PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;
// Unable to find the docs for this function!
#define glTextureParameterfv glad_glTextureParameterfv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;
// Unable to find the docs for this function!
#define glTextureParameteri glad_glTextureParameteri
GLAD_API_CALL PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;
// Unable to find the docs for this function!
#define glTextureParameteriv glad_glTextureParameteriv
GLAD_API_CALL PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;
/**
* @name glTexStorage1D, glTextureStorage1D - simultaneously specify storage for all levels of a one-dimensional texture
* @usage
* @code void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @code void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage1D</b>. Must be one of <b>GL_TEXTURE_1D</b>
*               or <b>GL_PROXY_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage1D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if levels is greater than log2 width +1 .
*
*/
#define glTextureStorage1D glad_glTextureStorage1D
GLAD_API_CALL PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;
/**
* @name glTexStorage2D, glTextureStorage2D - simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
* @usage
* @code void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @code void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2D</b>. Must be one of <b>GL_TEXTURE_2D</b>,
*               <b>GL_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_1D_ARRAY</b>,
*               <b>GL_PROXY_TEXTURE_RECTANGLE</b>, or <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than
*         log2 width +1 .
* @errors GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater
*         than log2 max width, height +1 .
*
*/
#define glTextureStorage2D glad_glTextureStorage2D
GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;
/**
* @name glTexStorage2DMultisample, glTextureStorage2DMultisample - specify storage for a two-dimensional multisample texture
* @usage
* @code void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage2DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage2DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage2DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage2DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTextureStorage2DMultisample glad_glTextureStorage2DMultisample
GLAD_API_CALL PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;
/**
* @name glTexStorage3D, glTextureStorage3D - simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
* @usage
* @code void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @code void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3D</b>. Must be one of <b>GL_TEXTURE_3D</b>,
*               <b>GL_TEXTURE_2D_ARRAY</b>, <b>GL_TEXTURE_CUBE_MAP_ARRAY</b>, <b>GL_PROXY_TEXTURE_3D</b>, <b>GL_PROXY_TEXTURE_2D_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_CUBE_MAP_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param levels Specify the number of texture levels.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in texels.
* @note GL_STENCIL_INDEX8 is accepted for internalformat only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3D if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width, height, depth or levels are less than 1.
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D and levels is greater than log2 max
*         width, height, depth +1 .
* @errors GL_INVALID_OPERATION is generated if target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXURE_CUBE_MAP_ARRAY,
*         or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is greater than log2 max width, height +1 .
*
*/
#define glTextureStorage3D glad_glTextureStorage3D
GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;
/**
* @name glTexStorage3DMultisample, glTextureStorage3DMultisample - specify storage for a two-dimensional multisample array texture
* @usage
* @code void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @code void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); @endcode
* @param target Specifies the target to which the texture object is bound for <b>glTexStorage3DMultisample</b>. Must be one of <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>
*               or <b>GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureStorage3DMultisample</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid non-proxy <em class="parameter"><b>target</b></em> values above.
* @param samples Specify the number of samples in the texture.
* @param internalformat Specifies the sized internal format to be used to store texture image data.
* @param width Specifies the width of the texture, in texels.
* @param height Specifies the height of the texture, in texels.
* @param depth Specifies the depth of the texture, in layers.
* @param fixedsamplelocations Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image,
*                             and the sample locations will not depend on the internal format or size of the image.
*
* @errors GL_INVALID_OPERATION is generated by glTexStorage3DMultisample if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glTextureStorage3DMultisample if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format.
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the accepted targets described above.
* @errors GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if depth is less than 1 or greater than the value of GL_MAX_ARRAY_TEXTURE_LAYERS.
* @errors GL_INVALID_VALUE is generated if levels is less than 1.
* @errors GL_INVALID_VALUE is generated if samples is zero.
* @errors GL_INVALID_OPERATION is generated if samples is greater than the maximum number of samples supported for this target and
*         internalformat.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE.
*
*/
#define glTextureStorage3DMultisample glad_glTextureStorage3DMultisample
GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;
/**
* @name glTexSubImage1D, glTextureSubImage1D - specify a one-dimensional texture subimage
* @usage
* @code void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage1D</b>. Must be <b>GL_TEXTURE_1D</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage1D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @note glPixelStore modes affect texture images.
* @note glTexSubImage1D and glTextureSubImage1D specify a one-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not one of the allowable values.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage1D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , or if xoffset+width > w-b , where w is the GL_TEXTURE_WIDTH, and b is the
*         width of the GL_TEXTURE_BORDER of the texture image being modified. Note that w includes twice the border width.
* @errors GL_INVALID_VALUE is generated if width is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTextureSubImage1D glad_glTextureSubImage1D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;
/**
* @name glTexSubImage2D, glTextureSubImage2D - specify a two-dimensional texture subimage
* @usage
* @code void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage2D</b>. Must be <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
*               <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
*               <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or <b>GL_TEXTURE_1D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage2D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @note glPixelStore modes affect texture images.
* @note glTexSubImage2D and glTextureSubImage3D specify a two-dimensional subtexture for the current texture unit, specified with
*       glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
*         GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage2D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , where w is
*         the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that
*         w and h include twice the border width.
* @errors GL_INVALID_VALUE is generated if width or height is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTextureSubImage2D glad_glTextureSubImage2D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;
/**
* @name glTexSubImage3D, glTextureSubImage3D - specify a three-dimensional texture subimage
* @usage
* @code void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels); @endcode
* @code void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels); @endcode
* @param target Specifies the target to which the texture is bound for <b>glTexSubImage3D</b>. Must be <b>GL_TEXTURE_3D</b> or <b>GL_TEXTURE_2D_ARRAY</b>.
* @param texture Specifies the texture object name for <b>glTextureSubImage3D</b>. The effective target of <em class="parameter"><b>texture</b></em>
*                must be one of the valid <em class="parameter"><b>target</b></em> values above.
* @param level Specifies the level-of-detail number. Level 0 is the base image level. Level <span class="emphasis"><em>n</em></span> is
*              the <span class="emphasis"><em>n</em></span>th mipmap reduction image.
* @param xoffset Specifies a texel offset in the x direction within the texture array.
* @param yoffset Specifies a texel offset in the y direction within the texture array.
* @param zoffset Specifies a texel offset in the z direction within the texture array.
* @param width Specifies the width of the texture subimage.
* @param height Specifies the height of the texture subimage.
* @param depth Specifies the depth of the texture subimage.
* @param format Specifies the format of the pixel data. The following symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
*               <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_DEPTH_COMPONENT</b>, and <b>GL_STENCIL_INDEX</b>.
* @param type Specifies the data type of the pixel data. The following symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
*             <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
*             <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
*             <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
*             <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
*             and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.
* @param pixels Specifies a pointer to the image data in memory.
* @note The glPixelStore modes affect texture images.
* @note glTexSubImage3D and glTextureSubImage3D specify a three-dimensional or two-dimensional array subtexture for the current
*       texture unit, specified with glActiveTexture.
* @note GL_STENCIL_INDEX is accepted for format only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_ENUM is generated if target or the effective target of texture is not GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.
* @errors GL_INVALID_OPERATION is generated by glTextureSubImage3D if texture is not the name of an existing texture object.
* @errors GL_INVALID_ENUM is generated if format is not an accepted format constant.
* @errors GL_INVALID_ENUM is generated if type is not a type constant.
* @errors GL_INVALID_VALUE is generated if level is less than 0.
* @errors GL_INVALID_VALUE may be generated if level is greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.
* @errors GL_INVALID_VALUE is generated if xoffset< -b , xoffset+width > w-b , yoffset< -b , or yoffset+height > h-b , or zoffset<
*         -b , or zoffset+depth > d-b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and
*         b is the border width of the texture image being modified. Note that w, h, and d include twice the border width.
* @errors GL_INVALID_VALUE is generated if width, height, or depth is less than 0.
* @errors GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D
*         operation.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
*         or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB.
* @errors GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
*         GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
*         or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         buffer object's data store is currently mapped.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the
*         data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
* @errors GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and pixels
*         is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
*
*/
#define glTextureSubImage3D glad_glTextureSubImage3D
GLAD_API_CALL PFNGLTEXTUREVIEWPROC glad_glTextureView;
/**
* @name glTextureView - initialize a texture as a data alias of another texture's data store
* @usage
* @code void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers); @endcode
* @param texture Specifies the texture object to be initialized as a view.
* @param target Specifies the target to be used for the newly initialized texture.
* @param origtexture Specifies the name of a texture object of which to make a view.
* @param internalformat Specifies the internal format for the newly created view.
* @param minlevel Specifies lowest level of detail of the view.
* @param numlevels Specifies the number of levels of detail to include in the view.
* @param minlayer Specifies the index of the first layer to include in the view.
* @param numlayers Specifies the number of layers to include in the view.
*
* @errors GL_INVALID_VALUE is generated if minlayer or minlevel are larger than the greatest layer or level of origtexture.
* @errors GL_INVALID_OPERATION is generated if target is not compatible with the target of origtexture.
* @errors GL_INVALID_OPERATION is generated if the dimensions of origtexture are greater than the maximum supported dimensions for
*         target.
* @errors GL_INVALID_OPERATION is generated if internalformat is not compatible with the internal format of origtexture.
* @errors GL_INVALID_OPERATION is generated if texture has already been bound or otherwise given a target.
* @errors GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for origtexture is not GL_TRUE.
* @errors GL_INVALID_OPERATION is generated if origtexture is not the name of an existing texture object.
* @errors GL_INVALID_VALUE is generaged if target is GL_TEXTURE_CUBE_MAP and numlayers is not 6, or if target is GL_TEXTURE_CUBE_MAP_ARRAY
*         and numlayers is not an integer multiple of 6.
* @errors GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_2D_MULTISAMPLE
*         and numlayers does not equal 1.
* @errors GL_INVALID_VALUE is generated if texture zero or is not the name of a texture previously returned from a successful call
*         to glGenTextures.
*
*/
#define glTextureView glad_glTextureView
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;
/**
* @name glTransformFeedbackBufferBase - bind a buffer object to a transform feedback buffer object
* @usage
* @code void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer); @endcode
* @param xfb Name of the transform feedback buffer object.
* @param index Index of the binding point within <em class="parameter"><b>xfb</b></em>.
* @param buffer Name of the buffer object to bind to the specified binding point.
* @note Calling glTransformFeedbackBufferBase is equivalent to calling glTransformFeedbackBufferRange with offset zero and size
*       equal to the size of buffer.
*
* @errors GL_INVALID_OPERATION is generated if xfb is not the name of an existing transform feedback object.
* @errors GL_INVALID_VALUE is generated if in buffer is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of transform feedback buffer binding points
*         (the value of GL_TRANSFORM_FEEDBACK_BUFFER_BINDING).
*
*/
#define glTransformFeedbackBufferBase glad_glTransformFeedbackBufferBase
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;
/**
* @name glTransformFeedbackBufferRange - bind a range within a buffer object to a transform feedback buffer object
* @usage
* @code void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size); @endcode
* @param xfb Name of the transform feedback buffer object.
* @param index Index of the binding point within <em class="parameter"><b>xfb</b></em>.
* @param buffer Name of the buffer object to bind to the specified binding point.
* @param offset The starting offset in basic machine units into the buffer object.
* @param size The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed
*             target.
*
* @errors GL_INVALID_OPERATION is generated if xfb is not the name of an existing transform feedback object.
* @errors GL_INVALID_VALUE is generated if in buffer is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the number of transform feedback buffer binding points
*         (the value of GL_TRANSFORM_FEEDBACK_BUFFER_BINDING).
* @errors GL_INVALID_VALUE is generated if offset is negative.
* @errors GL_INVALID_VALUE is generated if buffer is non-zero and either size is less than or equal to zero, or offset + size is greater
*         than the value of GL_BUFFER_SIZE for buffer.
*
*/
#define glTransformFeedbackBufferRange glad_glTransformFeedbackBufferRange
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
/**
* @name glTransformFeedbackVaryings - specify values to record in transform feedback buffers
* @usage
* @code void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char **varyings, GLenum bufferMode); @endcode
* @param program The name of the target program object.
* @param count The number of varying variables used for transform feedback.
* @param varyings An array of <em class="parameter"><b>count</b></em> zero-terminated strings specifying the names of the varying variables
*                 to use for transform feedback.
* @param bufferMode Identifies the mode used to capture the varying variables when transform feedback is active. <em class="parameter"><b>bufferMode</b></em>
*                   must be <b>GL_INTERLEAVED_ATTRIBS</b> or <b>GL_SEPARATE_ATTRIBS</b>.
* @note glGetTransformFeedbackVarying is available only if the GL version is 3.0 or greater.
*
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object.
* @errors GL_INVALID_VALUE is generated if bufferMode is GL_SEPARATE_ATTRIBS and count is greater than the implementation-dependent
*         limit GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
*
*/
#define glTransformFeedbackVaryings glad_glTransformFeedbackVaryings
GLAD_API_CALL PFNGLUNIFORM1DPROC glad_glUniform1d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1d glad_glUniform1d
GLAD_API_CALL PFNGLUNIFORM1DVPROC glad_glUniform1dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1dv glad_glUniform1dv
GLAD_API_CALL PFNGLUNIFORM1FPROC glad_glUniform1f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1f glad_glUniform1f
GLAD_API_CALL PFNGLUNIFORM1FVPROC glad_glUniform1fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1fv glad_glUniform1fv
GLAD_API_CALL PFNGLUNIFORM1IPROC glad_glUniform1i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1i glad_glUniform1i
GLAD_API_CALL PFNGLUNIFORM1IVPROC glad_glUniform1iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1iv glad_glUniform1iv
GLAD_API_CALL PFNGLUNIFORM1UIPROC glad_glUniform1ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1ui glad_glUniform1ui
GLAD_API_CALL PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform1uiv glad_glUniform1uiv
GLAD_API_CALL PFNGLUNIFORM2DPROC glad_glUniform2d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2d glad_glUniform2d
GLAD_API_CALL PFNGLUNIFORM2DVPROC glad_glUniform2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2dv glad_glUniform2dv
GLAD_API_CALL PFNGLUNIFORM2FPROC glad_glUniform2f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2f glad_glUniform2f
GLAD_API_CALL PFNGLUNIFORM2FVPROC glad_glUniform2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2fv glad_glUniform2fv
GLAD_API_CALL PFNGLUNIFORM2IPROC glad_glUniform2i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2i glad_glUniform2i
GLAD_API_CALL PFNGLUNIFORM2IVPROC glad_glUniform2iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2iv glad_glUniform2iv
GLAD_API_CALL PFNGLUNIFORM2UIPROC glad_glUniform2ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2ui glad_glUniform2ui
GLAD_API_CALL PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform2uiv glad_glUniform2uiv
GLAD_API_CALL PFNGLUNIFORM3DPROC glad_glUniform3d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3d glad_glUniform3d
GLAD_API_CALL PFNGLUNIFORM3DVPROC glad_glUniform3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3dv glad_glUniform3dv
GLAD_API_CALL PFNGLUNIFORM3FPROC glad_glUniform3f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3f glad_glUniform3f
GLAD_API_CALL PFNGLUNIFORM3FVPROC glad_glUniform3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3fv glad_glUniform3fv
GLAD_API_CALL PFNGLUNIFORM3IPROC glad_glUniform3i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3i glad_glUniform3i
GLAD_API_CALL PFNGLUNIFORM3IVPROC glad_glUniform3iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3iv glad_glUniform3iv
GLAD_API_CALL PFNGLUNIFORM3UIPROC glad_glUniform3ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3ui glad_glUniform3ui
GLAD_API_CALL PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform3uiv glad_glUniform3uiv
GLAD_API_CALL PFNGLUNIFORM4DPROC glad_glUniform4d;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4d glad_glUniform4d
GLAD_API_CALL PFNGLUNIFORM4DVPROC glad_glUniform4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4dv glad_glUniform4dv
GLAD_API_CALL PFNGLUNIFORM4FPROC glad_glUniform4f;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4f glad_glUniform4f
GLAD_API_CALL PFNGLUNIFORM4FVPROC glad_glUniform4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4fv glad_glUniform4fv
GLAD_API_CALL PFNGLUNIFORM4IPROC glad_glUniform4i;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4i glad_glUniform4i
GLAD_API_CALL PFNGLUNIFORM4IVPROC glad_glUniform4iv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4iv glad_glUniform4iv
GLAD_API_CALL PFNGLUNIFORM4UIPROC glad_glUniform4ui;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4ui glad_glUniform4ui
GLAD_API_CALL PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniform4uiv glad_glUniform4uiv
GLAD_API_CALL PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
/**
* @name glUniformBlockBinding - assign a binding point to an active uniform block
* @usage
* @code void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding); @endcode
* @param program The name of a program object containing the active uniform block whose binding to assign.
* @param uniformBlockIndex The index of the active uniform block within <em class="parameter"><b>program</b></em> whose binding to assign.
* @param uniformBlockBinding Specifies the binding point to which to bind the uniform block with index <em class="parameter"><b>uniformBlockIndex</b></em>
*                            within <em class="parameter"><b>program</b></em>.
* @note glUniformBlockBinding is available only if the GL version is 3.1 or greater.
*
* @errors GL_INVALID_VALUE is generated if uniformBlockIndex is not an active uniform block index of program.
* @errors GL_INVALID_VALUE is generated if uniformBlockBinding is greater than or equal to the value of GL_MAX_UNIFORM_BUFFER_BINDINGS.
* @errors GL_INVALID_VALUE is generated if program is not the name of a program object generated by the GL.
*
*/
#define glUniformBlockBinding glad_glUniformBlockBinding
GLAD_API_CALL PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2dv glad_glUniformMatrix2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2fv glad_glUniformMatrix2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x3dv glad_glUniformMatrix2x3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x3fv glad_glUniformMatrix2x3fv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x4dv glad_glUniformMatrix2x4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix2x4fv glad_glUniformMatrix2x4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3dv glad_glUniformMatrix3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3fv glad_glUniformMatrix3fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x2dv glad_glUniformMatrix3x2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x2fv glad_glUniformMatrix3x2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x4dv glad_glUniformMatrix3x4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix3x4fv glad_glUniformMatrix3x4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4dv glad_glUniformMatrix4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4fv glad_glUniformMatrix4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x2dv glad_glUniformMatrix4x2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x2fv glad_glUniformMatrix4x2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x3dv glad_glUniformMatrix4x3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
/**
* @name glUniform - Specify the value of a uniform variable for the current program object
* @usage
* @code void glUniform1f(GLint location, GLfloat v0); @endcode
* @code void glUniform2f(GLint location, GLfloat v0, GLfloat v1); @endcode
* @code void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glUniform1i(GLint location, GLint v0); @endcode
* @code void glUniform2i(GLint location, GLint v0, GLint v1); @endcode
* @code void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2); @endcode
* @code void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glUniform1ui(GLint location, GLuint v0); @endcode
* @code void glUniform2ui(GLint location, GLuint v0, GLuint v1); @endcode
* @code void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glUniform1fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform2fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform3fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform4fv(GLint location, GLsizei count, const GLfloat *value); @endcode
* @code void glUniform1iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform2iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform3iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform4iv(GLint location, GLsizei count, const GLint *value); @endcode
* @code void glUniform1uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform2uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform3uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniform4uiv(GLint location, GLsizei count, const GLuint *value); @endcode
* @code void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @code void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); @endcode
* @param location Specifies the location of the uniform variable to be modified.
* @param count For the vector (<b>glUniform*v</b>) commands, specifies the number of elements that are to be modified. This should be 1
*              if the targeted uniform variable is not an array, and 1 or more if it is an array.
* @param transpose For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified uniform variable.
* @param value For the vector and matrix commands, specifies a pointer to an array of <em class="parameter"><b>count</b></em> values that
*              will be used to update the specified uniform variable.
* @note glUniform1i and glUniform1iv are the only two functions that may be used to load uniform variables defined as sampler types.
*       Loading samplers with any other function will result in a GL_INVALID_OPERATION error.
* @note If count is greater than 1 and the indicated uniform variable is not an array, a GL_INVALID_OPERATION error is generated
*       and the specified uniform variable will remain unchanged.
* @note Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match
*       the type and size specified in the name of the command used to load its value, a GL_INVALID_OPERATION error will be generated
*       and the specified uniform variable will remain unchanged.
* @note If location is a value other than -1 and it does not represent a valid uniform variable location in the current program
*       object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object.
*       If location is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not
*       be changed.
*
* @errors GL_INVALID_OPERATION is generated if there is no current program object.
* @errors GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated
*         by the glUniform command.
* @errors GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform
*         variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this
*         function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array
*         of these.
* @errors GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable
*         of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable
*         of type int, ivec2, ivec3, ivec4, or an array of these.
* @errors GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location
*         is not equal to -1.
* @errors GL_INVALID_VALUE is generated if count is less than 0.
* @errors GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
* @errors GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.
*
*/
#define glUniformMatrix4x3fv glad_glUniformMatrix4x3fv
GLAD_API_CALL PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;
// Unable to find the docs for this function!
#define glUniformSubroutinesuiv glad_glUniformSubroutinesuiv
GLAD_API_CALL PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
/**
* @name glUnmapBuffer, glUnmapNamedBuffer - release the mapping of a buffer object's data store into the client's address space
* @usage
* @code GLboolean glUnmapBuffer(GLenum target); @endcode
* @code GLboolean glUnmapNamedBuffer(GLuint buffer); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glUnmapBuffer</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glUnmapNamedBuffer</b>.
* @note If an error is generated, glUnmapBuffer returns GL_FALSE.
* @note The GL_ATOMIC_COUNTER_BUFFER target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glUnmapBuffer if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glUnmapBuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glUnmapNamedBuffer if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not in a mapped state.
*
*/
#define glUnmapBuffer glad_glUnmapBuffer
GLAD_API_CALL PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;
/**
* @name glUnmapBuffer, glUnmapNamedBuffer - release the mapping of a buffer object's data store into the client's address space
* @usage
* @code GLboolean glUnmapBuffer(GLenum target); @endcode
* @code GLboolean glUnmapNamedBuffer(GLuint buffer); @endcode
* @param target Specifies the target to which the buffer object is bound for <b>glUnmapBuffer</b>, which must be one of the buffer binding
*               targets in the following table:
* @param buffer Specifies the name of the buffer object for <b>glUnmapNamedBuffer</b>.
* @note If an error is generated, glUnmapBuffer returns GL_FALSE.
* @note The GL_ATOMIC_COUNTER_BUFFER target is accepted only if the GL version is 4.2 or greater.
* @note The GL_DISPATCH_INDIRECT_BUFFER and GL_SHADER_STORAGE_BUFFER targets are available only if the GL version is 4.3 or greater.
* @note The GL_QUERY_BUFFER target is available only if the GL version is 4.4 or greater.
*
* @errors GL_INVALID_ENUM is generated by glUnmapBuffer if target is not one of the buffer binding targets listed above.
* @errors GL_INVALID_OPERATION is generated by glUnmapBuffer if zero is bound to target.
* @errors GL_INVALID_OPERATION is generated by glUnmapNamedBuffer if buffer is not the name of an existing buffer object.
* @errors GL_INVALID_OPERATION is generated if the buffer object is not in a mapped state.
*
*/
#define glUnmapNamedBuffer glad_glUnmapNamedBuffer
GLAD_API_CALL PFNGLUSEPROGRAMPROC glad_glUseProgram;
/**
* @name glUseProgram - Installs a program object as part of current rendering state
* @usage
* @code void glUseProgram(GLuint program); @endcode
* @param program Specifies the handle of the program object whose executables are to be used as part of current rendering state.
* @note Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the
*       server sides of the contexts share the same address space. If the name space is shared across contexts, any attached
*       objects and the data associated with those attached objects are shared as well.
* @note Applications are responsible for providing the synchronization across API calls when objects are accessed from different
*       execution threads.
*
* @errors GL_INVALID_VALUE is generated if program is neither 0 nor a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
* @errors GL_INVALID_OPERATION is generated if program could not be made part of current state.
* @errors GL_INVALID_OPERATION is generated if transform feedback mode is active.
*
*/
#define glUseProgram glad_glUseProgram
GLAD_API_CALL PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;
/**
* @name glUseProgramStages - bind stages of a program object to a program pipeline
* @usage
* @code void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program); @endcode
* @param pipeline Specifies the program pipeline object to which to bind stages from <em class="parameter"><b>program</b></em>.
* @param stages Specifies a set of program stages to bind to the program pipeline object.
* @param program Specifies the program object containing the shader executables to use in <em class="parameter"><b>pipeline</b></em>.
* @note The GL_COMPUTE_SHADER_BIT bit is available only if the GL version is 4.3 or greater.
*
* @errors GL_INVALID_VALUE is generated if shaders contains set bits that are not recognized, and is not the reserved value GL_ALL_SHADER_BITS.
* @errors GL_INVALID_OPERATION is generated if program refers to a program object that was not linked with its GL_PROGRAM_SEPARABLE
*         status set.
* @errors GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked.
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glUseProgramStages glad_glUseProgramStages
GLAD_API_CALL PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
/**
* @name glValidateProgram - Validates a program object
* @usage
* @code void glValidateProgram(GLuint program); @endcode
* @param program Specifies the handle of the program object to be validated.
* @note This function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued
*       while programmable shaders are part of current state. The error GL_INVALID_OPERATION will be generated by any command
*       that triggers the rendering of geometry if:
* @note any two active samplers in the current program object are of different types, but refer to the same texture image unit,
* @note the number of active samplers in the program exceeds the maximum number of texture image units allowed.
* @note It may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are
*       issued. Therefore, applications are advised to make calls to glValidateProgram to detect these issues during application
*       development.
*
* @errors GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
* @errors GL_INVALID_OPERATION is generated if program is not a program object.
*
*/
#define glValidateProgram glad_glValidateProgram
GLAD_API_CALL PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;
/**
* @name glValidateProgramPipeline - validate a program pipeline object against current GL state
* @usage
* @code void glValidateProgramPipeline(GLuint pipeline); @endcode
* @param pipeline Specifies the name of a program pipeline object to validate.
*
* @errors GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or
*         if such a name has been deleted by a call to glDeleteProgramPipelines.
*
*/
#define glValidateProgramPipeline glad_glValidateProgramPipeline
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;
/**
* @name glVertexAttribBinding - associate a vertex attribute and a vertex buffer binding for a vertex array object
* @usage
* @code void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex); @endcode
* @code void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttribBinding</b>.
* @param attribindex The index of the attribute to associate with a vertex buffer binding.
* @param bindingindex The index of the vertex buffer binding with which to associate the generic vertex attribute.
*
* @errors GL_INVALID_OPERATION is generated by glVertexAttribBinding if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribBinding if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
*
*/
#define glVertexArrayAttribBinding glad_glVertexArrayAttribBinding
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexArrayAttribFormat glad_glVertexArrayAttribFormat
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexArrayAttribIFormat glad_glVertexArrayAttribIFormat
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexArrayAttribLFormat glad_glVertexArrayAttribLFormat
GLAD_API_CALL PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;
/**
* @name glVertexBindingDivisor, glVertexArrayBindingDivisor - modify the rate at which generic vertex attributes
advance
* @usage
* @code void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor); @endcode
* @code void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayBindingDivisor</b> function.
* @param bindingindex The index of the binding whose divisor to modify.
* @param divisor The new value for the instance step rate to apply.
*
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION by glVertexBindingDivisor is generated if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayBindingDivisor if vaobj is not the name of an existing vertex array object.
*
*/
#define glVertexArrayBindingDivisor glad_glVertexArrayBindingDivisor
GLAD_API_CALL PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;
/**
* @name glVertexArrayElementBuffer - configures element array buffer binding of a vertex array object
* @usage
* @code void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer); @endcode
* @param vaobj Specifies the name of the vertex array object.
* @param buffer Specifies the name of the buffer object to use for the element array buffer binding.
*
* @errors GL_INVALID_OPERATION error is generated if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION error is generated if buffer is not zero or the name of an existing buffer object.
*
*/
#define glVertexArrayElementBuffer glad_glVertexArrayElementBuffer
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;
/**
* @name glBindVertexBuffer, glVertexArrayVertexBuffer - bind a buffer to a vertex buffer bind point
* @usage
* @code void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @code void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride); @endcode
* @param vaobj Specifies the name of the vertex array object to be used by <b>glVertexArrayVertexBuffer</b> function.
* @param bindingindex The index of the vertex buffer binding point to which to bind the buffer.
* @param buffer The name of a buffer to bind to the vertex buffer binding point.
* @param offset The offset of the first element of the buffer.
* @param stride The distance between elements within the buffer.
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffer if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffer if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_VALUE is generated if offset or stride is less than zero, or if stride is greater than the value of GL_MAX_VERTEX_ATTRIB_STRIDE.
* @errors GL_INVALID_VALUE is generated if buffer is not zero or the name of an existing buffer object (as returned by glGenBuffers
*         or glCreateBuffers).
*
*/
#define glVertexArrayVertexBuffer glad_glVertexArrayVertexBuffer
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;
/**
* @name glBindVertexBuffers, glVertexArrayVertexBuffers - attach multiple buffer objects to a vertex array object
* @usage
* @code void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @code void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayVertexBuffers</b>.
* @param first Specifies the first vertex buffer binding point to which a buffer object is to be bound.
* @param count Specifies the number of buffers to bind.
* @param buffers Specifies the address of an array of names of existing buffer objects.
* @param offsets Specifies the address of an array of offsets to associate with the binding points.
* @param strides Specifies the address of an array of strides to associate with the binding points.
*
* @errors GL_INVALID_OPERATION is generated by glBindVertexBuffers if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayVertexBuffers if vaobj is not the name of the vertex array object.
* @errors GL_INVALID_OPERATION is generated if $first + count$ is greater than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object.
* @errors GL_INVALID_VALUE is generated if any value in offsets or strides is negative, or if a value is stride is greater than the
*         value of GL_MAX_VERTEX_ATTRIB_STRIDE.
*
*/
#define glVertexArrayVertexBuffers glad_glVertexArrayVertexBuffers
GLAD_API_CALL PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1d glad_glVertexAttrib1d
GLAD_API_CALL PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1dv glad_glVertexAttrib1dv
GLAD_API_CALL PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1f glad_glVertexAttrib1f
GLAD_API_CALL PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1fv glad_glVertexAttrib1fv
GLAD_API_CALL PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1s glad_glVertexAttrib1s
GLAD_API_CALL PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib1sv glad_glVertexAttrib1sv
GLAD_API_CALL PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2d glad_glVertexAttrib2d
GLAD_API_CALL PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2dv glad_glVertexAttrib2dv
GLAD_API_CALL PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2f glad_glVertexAttrib2f
GLAD_API_CALL PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2fv glad_glVertexAttrib2fv
GLAD_API_CALL PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2s glad_glVertexAttrib2s
GLAD_API_CALL PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib2sv glad_glVertexAttrib2sv
GLAD_API_CALL PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3d glad_glVertexAttrib3d
GLAD_API_CALL PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3dv glad_glVertexAttrib3dv
GLAD_API_CALL PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3f glad_glVertexAttrib3f
GLAD_API_CALL PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3fv glad_glVertexAttrib3fv
GLAD_API_CALL PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3s glad_glVertexAttrib3s
GLAD_API_CALL PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib3sv glad_glVertexAttrib3sv
GLAD_API_CALL PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nbv glad_glVertexAttrib4Nbv
GLAD_API_CALL PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Niv glad_glVertexAttrib4Niv
GLAD_API_CALL PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nsv glad_glVertexAttrib4Nsv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nub glad_glVertexAttrib4Nub
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nubv glad_glVertexAttrib4Nubv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nuiv glad_glVertexAttrib4Nuiv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4Nusv glad_glVertexAttrib4Nusv
GLAD_API_CALL PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4bv glad_glVertexAttrib4bv
GLAD_API_CALL PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4d glad_glVertexAttrib4d
GLAD_API_CALL PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4dv glad_glVertexAttrib4dv
GLAD_API_CALL PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4f glad_glVertexAttrib4f
GLAD_API_CALL PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4fv glad_glVertexAttrib4fv
GLAD_API_CALL PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4iv glad_glVertexAttrib4iv
GLAD_API_CALL PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4s glad_glVertexAttrib4s
GLAD_API_CALL PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4sv glad_glVertexAttrib4sv
GLAD_API_CALL PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4ubv glad_glVertexAttrib4ubv
GLAD_API_CALL PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4uiv glad_glVertexAttrib4uiv
GLAD_API_CALL PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttrib4usv glad_glVertexAttrib4usv
GLAD_API_CALL PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;
/**
* @name glVertexAttribBinding - associate a vertex attribute and a vertex buffer binding for a vertex array object
* @usage
* @code void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex); @endcode
* @code void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttribBinding</b>.
* @param attribindex The index of the attribute to associate with a vertex buffer binding.
* @param bindingindex The index of the vertex buffer binding with which to associate the generic vertex attribute.
*
* @errors GL_INVALID_OPERATION is generated by glVertexAttribBinding if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribBinding if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
*
*/
#define glVertexAttribBinding glad_glVertexAttribBinding
GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
/**
* @name glVertexAttribDivisor - modify the rate at which generic vertex attributes advance during instanced rendering
* @usage
* @code void glVertexAttribDivisor(GLuint index, GLuint divisor); @endcode
* @param index Specify the index of the generic vertex attribute.
* @param divisor Specify the number of instances that will pass between updates of the generic attribute at slot <em class="parameter"><b>index</b></em>.
* @note glVertexAttribDivisor is available only if the GL version is 3.3 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
*
*/
#define glVertexAttribDivisor glad_glVertexAttribDivisor
GLAD_API_CALL PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexAttribFormat glad_glVertexAttribFormat
GLAD_API_CALL PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1i glad_glVertexAttribI1i
GLAD_API_CALL PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1iv glad_glVertexAttribI1iv
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1ui glad_glVertexAttribI1ui
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI1uiv glad_glVertexAttribI1uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2i glad_glVertexAttribI2i
GLAD_API_CALL PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2iv glad_glVertexAttribI2iv
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2ui glad_glVertexAttribI2ui
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI2uiv glad_glVertexAttribI2uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3i glad_glVertexAttribI3i
GLAD_API_CALL PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3iv glad_glVertexAttribI3iv
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3ui glad_glVertexAttribI3ui
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI3uiv glad_glVertexAttribI3uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4bv glad_glVertexAttribI4bv
GLAD_API_CALL PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4i glad_glVertexAttribI4i
GLAD_API_CALL PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4iv glad_glVertexAttribI4iv
GLAD_API_CALL PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4sv glad_glVertexAttribI4sv
GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4ubv glad_glVertexAttribI4ubv
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4ui glad_glVertexAttribI4ui
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4uiv glad_glVertexAttribI4uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribI4usv glad_glVertexAttribI4usv
GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexAttribIFormat glad_glVertexAttribIFormat
GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
/**
* @name glVertexAttribPointer - define an array of generic vertex attribute data
* @usage
* @code void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant
*             <b>GL_BGRA</b> is accepted by <b>glVertexAttribPointer</b>. The initial value is 4.
* @param type Specifies the data type of each component in the array. The symbolic constants <b>GL_BYTE</b>, <b>GL_UNSIGNED_BYTE</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_INT</b>, and <b>GL_UNSIGNED_INT</b> are accepted by <b>glVertexAttribPointer</b>
*             and <b>glVertexAttribIPointer</b>. Additionally <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_DOUBLE</b>, <b>GL_FIXED</b>,
*             <b>GL_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>
*             are accepted by <b>glVertexAttribPointer</b>. <b>GL_DOUBLE</b> is also accepted by <b>glVertexAttribLPointer</b> and
*             is the only token accepted by the <em class="parameter"><b>type</b></em> parameter for that function. The initial value
*             is <b>GL_FLOAT</b>.
* @param normalized For <b>glVertexAttribPointer</b>, specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted
*                   directly as fixed-point values (<b>GL_FALSE</b>) when they are accessed.
* @param stride Specifies the byte offset between consecutive generic vertex attributes. If <em class="parameter"><b>stride</b></em> is
*               0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
* @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer
*                currently bound to the <b>GL_ARRAY_BUFFER</b> target. The initial value is 0.
* @note Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements, glDrawRangeElements, glDrawArrays,
*       glMultiDrawArrays, or glMultiDrawElements is called.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
* @errors GL_INVALID_ENUM is generated if type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is negative.
* @errors GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or
*         GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument
*         is not NULL.
*
*/
#define glVertexAttribIPointer glad_glVertexAttribIPointer
GLAD_API_CALL PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL1d glad_glVertexAttribL1d
GLAD_API_CALL PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL1dv glad_glVertexAttribL1dv
GLAD_API_CALL PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL2d glad_glVertexAttribL2d
GLAD_API_CALL PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL2dv glad_glVertexAttribL2dv
GLAD_API_CALL PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL3d glad_glVertexAttribL3d
GLAD_API_CALL PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL3dv glad_glVertexAttribL3dv
GLAD_API_CALL PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL4d glad_glVertexAttribL4d
GLAD_API_CALL PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribL4dv glad_glVertexAttribL4dv
GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;
/**
* @name glVertexAttribFormat, glVertexArrayAttribFormat - specify the organization of vertex arrays
* @usage
* @code void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @code void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayAttrib{I, L}Format</b> functions.
* @param attribindex The generic vertex attribute array being described.
* @param size The number of values per vertex that are stored in the array.
* @param type The type of the data stored in the array.
* @param normalized Specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted directly as fixed-point values
*                   (<b>GL_FALSE</b>) when they are accessed. This parameter is ignored if <em class="parameter"><b>type</b></em> is <b>GL_FIXED</b>.
* @param relativeoffset The distance between elements within the buffer.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not one of the accepted values.
* @errors GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
* @errors GL_INVALID_ENUM is generated if type is not one of the accepted tokens.
* @errors GL_INVALID_ENUM is generated by glVertexAttribIFormat, glVertexAttribLFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if type is GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribFormat, glVertexAttribIFormat and glVertexAttribLFormat if no vertex
*         array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayAttribFormat, glVertexArrayAttribIFormat and glVertexArrayAttribLFormat
*         if vaobj is not the name of an existing vertex array object.
* @errors GL_INVALID_OPERATION is generated under any of the following conditions:
* @errors size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, and size is neither 4 nor GL_BGRA.
* @errors type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors size is GL_BGRA and normalized is GL_FALSE.
*
*/
#define glVertexAttribLFormat glad_glVertexAttribLFormat
GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;
/**
* @name glVertexAttribPointer - define an array of generic vertex attribute data
* @usage
* @code void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant
*             <b>GL_BGRA</b> is accepted by <b>glVertexAttribPointer</b>. The initial value is 4.
* @param type Specifies the data type of each component in the array. The symbolic constants <b>GL_BYTE</b>, <b>GL_UNSIGNED_BYTE</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_INT</b>, and <b>GL_UNSIGNED_INT</b> are accepted by <b>glVertexAttribPointer</b>
*             and <b>glVertexAttribIPointer</b>. Additionally <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_DOUBLE</b>, <b>GL_FIXED</b>,
*             <b>GL_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>
*             are accepted by <b>glVertexAttribPointer</b>. <b>GL_DOUBLE</b> is also accepted by <b>glVertexAttribLPointer</b> and
*             is the only token accepted by the <em class="parameter"><b>type</b></em> parameter for that function. The initial value
*             is <b>GL_FLOAT</b>.
* @param normalized For <b>glVertexAttribPointer</b>, specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted
*                   directly as fixed-point values (<b>GL_FALSE</b>) when they are accessed.
* @param stride Specifies the byte offset between consecutive generic vertex attributes. If <em class="parameter"><b>stride</b></em> is
*               0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
* @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer
*                currently bound to the <b>GL_ARRAY_BUFFER</b> target. The initial value is 0.
* @note Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements, glDrawRangeElements, glDrawArrays,
*       glMultiDrawArrays, or glMultiDrawElements is called.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
* @errors GL_INVALID_ENUM is generated if type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is negative.
* @errors GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or
*         GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument
*         is not NULL.
*
*/
#define glVertexAttribLPointer glad_glVertexAttribLPointer
GLAD_API_CALL PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP1ui glad_glVertexAttribP1ui
GLAD_API_CALL PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
// Unable to find the docs for this function!
#define glVertexAttribP1uiv glad_glVertexAttribP1uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP2ui glad_glVertexAttribP2ui
GLAD_API_CALL PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
// Unable to find the docs for this function!
#define glVertexAttribP2uiv glad_glVertexAttribP2uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP3ui glad_glVertexAttribP3ui
GLAD_API_CALL PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
// Unable to find the docs for this function!
#define glVertexAttribP3uiv glad_glVertexAttribP3uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
/**
* @name glVertexAttrib - Specifies the value of a generic vertex attribute
* @usage
* @code void glVertexAttrib1f(GLuint index, GLfloat v0); @endcode
* @code void glVertexAttrib1s(GLuint index, GLshort v0); @endcode
* @code void glVertexAttrib1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribI1i(GLuint index, GLint v0); @endcode
* @code void glVertexAttribI1ui(GLuint index, GLuint v0); @endcode
* @code void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1); @endcode
* @code void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1); @endcode
* @code void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribI2i(GLuint index, GLint v0, GLint v1); @endcode
* @code void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1); @endcode
* @code void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2); @endcode
* @code void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2); @endcode
* @code void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2); @endcode
* @code void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2); @endcode
* @code void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); @endcode
* @code void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3); @endcode
* @code void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3); @endcode
* @code void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3); @endcode
* @code void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3); @endcode
* @code void glVertexAttribL1d(GLuint index, GLdouble v0); @endcode
* @code void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1); @endcode
* @code void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2); @endcode
* @code void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); @endcode
* @code void glVertexAttrib1fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib1sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI1iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI1uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib2fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib2sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI2iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI2uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib3fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib3sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribI3iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI3uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4fv(GLuint index, const GLfloat *v); @endcode
* @code void glVertexAttrib4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttrib4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttrib4Nbv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttrib4Nsv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttrib4Niv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttrib4Nubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttrib4Nusv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttrib4Nuiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribI4bv(GLuint index, const GLbyte *v); @endcode
* @code void glVertexAttribI4ubv(GLuint index, const GLubyte *v); @endcode
* @code void glVertexAttribI4sv(GLuint index, const GLshort *v); @endcode
* @code void glVertexAttribI4usv(GLuint index, const GLushort *v); @endcode
* @code void glVertexAttribI4iv(GLuint index, const GLint *v); @endcode
* @code void glVertexAttribI4uiv(GLuint index, const GLuint *v); @endcode
* @code void glVertexAttribL1dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL2dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL3dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribL4dv(GLuint index, const GLdouble *v); @endcode
* @code void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @code void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param v0,            v1,            v2,            v3 For the scalar commands, specifies the new values to be used for the specified vertex attribute.
* @param v For the vector commands (<b>glVertexAttrib*v</b>), specifies a pointer to an array of values to be used for the generic
*          vertex attribute.
* @param type For the packed commands (<b>glVertexAttribP*</b>), specified the type of packing used on the data. This parameter must be
*             <b>GL_INT_2_10_10_10_REV</b> or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, to specify signed or unsigned data, respectively,
*             or <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b> to specify floating point data.
* @param normalized For the packed commands, if <b>GL_TRUE</b>, then the values are to be converted to floating point values by normalizing.
*                   Otherwise, they are converted directly to floating-point values. If <em class="parameter"><b>type</b></em> indicates a
*                   floating-pont format, then <em class="parameter"><b>normalized</b></em> value must be <b>GL_FALSE</b>.
* @param value For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
* @note Generic vertex attributes can be updated at any time.
* @note It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This
*       is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex
*       shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location.
*       OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing
*       will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.
* @note There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes
*       with standard attributes.
* @note glVertexAttribL versions are available only if the GL version is 4.1 or higher.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type by glVertexAttribP* only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV,
*         or GL_UNSIGNED_INT_10F_11F_11F_REV.
* @errors GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.
*
*/
#define glVertexAttribP4ui glad_glVertexAttribP4ui
GLAD_API_CALL PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
// Unable to find the docs for this function!
#define glVertexAttribP4uiv glad_glVertexAttribP4uiv
GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
/**
* @name glVertexAttribPointer - define an array of generic vertex attribute data
* @usage
* @code void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @code void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer); @endcode
* @param index Specifies the index of the generic vertex attribute to be modified.
* @param size Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant
*             <b>GL_BGRA</b> is accepted by <b>glVertexAttribPointer</b>. The initial value is 4.
* @param type Specifies the data type of each component in the array. The symbolic constants <b>GL_BYTE</b>, <b>GL_UNSIGNED_BYTE</b>,
*             <b>GL_SHORT</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_INT</b>, and <b>GL_UNSIGNED_INT</b> are accepted by <b>glVertexAttribPointer</b>
*             and <b>glVertexAttribIPointer</b>. Additionally <b>GL_HALF_FLOAT</b>, <b>GL_FLOAT</b>, <b>GL_DOUBLE</b>, <b>GL_FIXED</b>,
*             <b>GL_INT_2_10_10_10_REV</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>
*             are accepted by <b>glVertexAttribPointer</b>. <b>GL_DOUBLE</b> is also accepted by <b>glVertexAttribLPointer</b> and
*             is the only token accepted by the <em class="parameter"><b>type</b></em> parameter for that function. The initial value
*             is <b>GL_FLOAT</b>.
* @param normalized For <b>glVertexAttribPointer</b>, specifies whether fixed-point data values should be normalized (<b>GL_TRUE</b>) or converted
*                   directly as fixed-point values (<b>GL_FALSE</b>) when they are accessed.
* @param stride Specifies the byte offset between consecutive generic vertex attributes. If <em class="parameter"><b>stride</b></em> is
*               0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
* @param pointer Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer
*                currently bound to the <b>GL_ARRAY_BUFFER</b> target. The initial value is 0.
* @note Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements, glDrawRangeElements, glDrawArrays,
*       glMultiDrawArrays, or glMultiDrawElements is called.
* @note GL_UNSIGNED_INT_10F_11F_11F_REV is accepted for type only if the GL version is 4.4 or higher.
*
* @errors GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
* @errors GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
* @errors GL_INVALID_ENUM is generated if type is not an accepted value.
* @errors GL_INVALID_VALUE is generated if stride is negative.
* @errors GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
* @errors GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or
*         GL_BGRA.
* @errors GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
* @errors GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
* @errors GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument
*         is not NULL.
*
*/
#define glVertexAttribPointer glad_glVertexAttribPointer
GLAD_API_CALL PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;
/**
* @name glVertexBindingDivisor, glVertexArrayBindingDivisor - modify the rate at which generic vertex attributes
advance
* @usage
* @code void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor); @endcode
* @code void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor); @endcode
* @param vaobj Specifies the name of the vertex array object for <b>glVertexArrayBindingDivisor</b> function.
* @param bindingindex The index of the binding whose divisor to modify.
* @param divisor The new value for the instance step rate to apply.
*
* @errors GL_INVALID_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS.
* @errors GL_INVALID_OPERATION by glVertexBindingDivisor is generated if no vertex array object is bound.
* @errors GL_INVALID_OPERATION is generated by glVertexArrayBindingDivisor if vaobj is not the name of an existing vertex array object.
*
*/
#define glVertexBindingDivisor glad_glVertexBindingDivisor
GLAD_API_CALL PFNGLVIEWPORTPROC glad_glViewport;
/**
* @name glViewport - set the viewport
* @usage
* @code void glViewport(GLint x, GLint y, GLsizei width, GLsizei height); @endcode
* @param x, y Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0, 0).
* @param width, height Specify the width and height of the viewport. When a GL context is first attached to a window, <em class="parameter"><b>width</b></em>
*                      and <em class="parameter"><b>height</b></em> are set to the dimensions of that window.
*
* @errors GL_INVALID_VALUE is generated if either width or height is negative.
*
*/
#define glViewport glad_glViewport
GLAD_API_CALL PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;
// Unable to find the docs for this function!
#define glViewportArrayv glad_glViewportArrayv
GLAD_API_CALL PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;
// Unable to find the docs for this function!
#define glViewportIndexedf glad_glViewportIndexedf
GLAD_API_CALL PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;
// Unable to find the docs for this function!
#define glViewportIndexedfv glad_glViewportIndexedfv
GLAD_API_CALL PFNGLWAITSYNCPROC glad_glWaitSync;
/**
* @name glWaitSync - instruct the GL server to block until the specified sync object becomes signaled
* @usage
* @code void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout); @endcode
* @param sync Specifies the sync object whose status to wait on.
* @param flags A bitfield controlling the command flushing behavior. <em class="parameter"><b>flags</b></em> may be zero.
* @param timeout Specifies the timeout that the server should wait before continuing. <em class="parameter"><b>timeout</b></em> must be <b>GL_TIMEOUT_IGNORED</b>.
* @note glWaitSync is available only if the GL version is 3.2 or higher.
*
* @errors GL_INVALID_VALUE is generated if sync is not the name of a sync object.
* @errors GL_INVALID_VALUE is generated if flags is not zero.
* @errors GL_INVALID_VALUE is generated if timeout is not GL_TIMEOUT_IGNORED.
*
*/
#define glWaitSync glad_glWaitSync





GLAD_API_CALL int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr);
// Unable to find the docs for this function!
GLAD_API_CALL int gladLoadGL( GLADloadfunc load);


#ifdef GLAD_GL

// Unable to find the docs for this function!
GLAD_API_CALL int gladLoaderLoadGL(void);
// Unable to find the docs for this function!
GLAD_API_CALL void gladLoaderUnloadGL(void);

#endif

#ifdef __cplusplus
}
#endif
#endif

/* Source */
#ifdef GLAD_GL_IMPLEMENTATION
/**
 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef GLAD_IMPL_UTIL_C_
#define GLAD_IMPL_UTIL_C_

#ifdef _MSC_VER
#define GLAD_IMPL_UTIL_SSCANF sscanf_s
#else
#define GLAD_IMPL_UTIL_SSCANF sscanf
#endif

#endif /* GLAD_IMPL_UTIL_C_ */

#ifdef __cplusplus
extern "C" {
#endif



int GLAD_GL_VERSION_1_0 = 0;
int GLAD_GL_VERSION_1_1 = 0;
int GLAD_GL_VERSION_1_2 = 0;
int GLAD_GL_VERSION_1_3 = 0;
int GLAD_GL_VERSION_1_4 = 0;
int GLAD_GL_VERSION_1_5 = 0;
int GLAD_GL_VERSION_2_0 = 0;
int GLAD_GL_VERSION_2_1 = 0;
int GLAD_GL_VERSION_3_0 = 0;
int GLAD_GL_VERSION_3_1 = 0;
int GLAD_GL_VERSION_3_2 = 0;
int GLAD_GL_VERSION_3_3 = 0;
int GLAD_GL_VERSION_4_0 = 0;
int GLAD_GL_VERSION_4_1 = 0;
int GLAD_GL_VERSION_4_2 = 0;
int GLAD_GL_VERSION_4_3 = 0;
int GLAD_GL_VERSION_4_4 = 0;
int GLAD_GL_VERSION_4_5 = 0;
int GLAD_GL_VERSION_4_6 = 0;
int GLAD_GL_EXT_texture_lod_bias = 0;



PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram = NULL;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture = NULL;
PFNGLATTACHSHADERPROC glad_glAttachShader = NULL;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = NULL;
PFNGLBEGINQUERYPROC glad_glBeginQuery = NULL;
PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = NULL;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = NULL;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = NULL;
PFNGLBINDBUFFERPROC glad_glBindBuffer = NULL;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = NULL;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = NULL;
PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase = NULL;
PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange = NULL;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = NULL;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = NULL;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = NULL;
PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture = NULL;
PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures = NULL;
PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline = NULL;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = NULL;
PFNGLBINDSAMPLERPROC glad_glBindSampler = NULL;
PFNGLBINDSAMPLERSPROC glad_glBindSamplers = NULL;
PFNGLBINDTEXTUREPROC glad_glBindTexture = NULL;
PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit = NULL;
PFNGLBINDTEXTURESPROC glad_glBindTextures = NULL;
PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = NULL;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = NULL;
PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer = NULL;
PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers = NULL;
PFNGLBLENDCOLORPROC glad_glBlendColor = NULL;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation = NULL;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = NULL;
PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = NULL;
PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = NULL;
PFNGLBLENDFUNCPROC glad_glBlendFunc = NULL;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = NULL;
PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = NULL;
PFNGLBLENDFUNCIPROC glad_glBlendFunci = NULL;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = NULL;
PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer = NULL;
PFNGLBUFFERDATAPROC glad_glBufferData = NULL;
PFNGLBUFFERSTORAGEPROC glad_glBufferStorage = NULL;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = NULL;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus = NULL;
PFNGLCLAMPCOLORPROC glad_glClampColor = NULL;
PFNGLCLEARPROC glad_glClear = NULL;
PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData = NULL;
PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData = NULL;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = NULL;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = NULL;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = NULL;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = NULL;
PFNGLCLEARCOLORPROC glad_glClearColor = NULL;
PFNGLCLEARDEPTHPROC glad_glClearDepth = NULL;
PFNGLCLEARDEPTHFPROC glad_glClearDepthf = NULL;
PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData = NULL;
PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv = NULL;
PFNGLCLEARSTENCILPROC glad_glClearStencil = NULL;
PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage = NULL;
PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage = NULL;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = NULL;
PFNGLCLIPCONTROLPROC glad_glClipControl = NULL;
PFNGLCOLORMASKPROC glad_glColorMask = NULL;
PFNGLCOLORMASKIPROC glad_glColorMaski = NULL;
PFNGLCOMPILESHADERPROC glad_glCompileShader = NULL;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = NULL;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = NULL;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D = NULL;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = NULL;
PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData = NULL;
PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData = NULL;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = NULL;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = NULL;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = NULL;
PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D = NULL;
PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D = NULL;
PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D = NULL;
PFNGLCREATEBUFFERSPROC glad_glCreateBuffers = NULL;
PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers = NULL;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram = NULL;
PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines = NULL;
PFNGLCREATEQUERIESPROC glad_glCreateQueries = NULL;
PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers = NULL;
PFNGLCREATESAMPLERSPROC glad_glCreateSamplers = NULL;
PFNGLCREATESHADERPROC glad_glCreateShader = NULL;
PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv = NULL;
PFNGLCREATETEXTURESPROC glad_glCreateTextures = NULL;
PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks = NULL;
PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays = NULL;
PFNGLCULLFACEPROC glad_glCullFace = NULL;
PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback = NULL;
PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl = NULL;
PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert = NULL;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = NULL;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = NULL;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = NULL;
PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines = NULL;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries = NULL;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = NULL;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = NULL;
PFNGLDELETESHADERPROC glad_glDeleteShader = NULL;
PFNGLDELETESYNCPROC glad_glDeleteSync = NULL;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures = NULL;
PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = NULL;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = NULL;
PFNGLDEPTHFUNCPROC glad_glDepthFunc = NULL;
PFNGLDEPTHMASKPROC glad_glDepthMask = NULL;
PFNGLDEPTHRANGEPROC glad_glDepthRange = NULL;
PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv = NULL;
PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed = NULL;
PFNGLDEPTHRANGEFPROC glad_glDepthRangef = NULL;
PFNGLDETACHSHADERPROC glad_glDetachShader = NULL;
PFNGLDISABLEPROC glad_glDisable = NULL;
PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib = NULL;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = NULL;
PFNGLDISABLEIPROC glad_glDisablei = NULL;
PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute = NULL;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect = NULL;
PFNGLDRAWARRAYSPROC glad_glDrawArrays = NULL;
PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = NULL;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = NULL;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance = NULL;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer = NULL;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = NULL;
PFNGLDRAWELEMENTSPROC glad_glDrawElements = NULL;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = NULL;
PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = NULL;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance = NULL;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = NULL;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = NULL;
PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = NULL;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced = NULL;
PFNGLENABLEPROC glad_glEnable = NULL;
PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib = NULL;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = NULL;
PFNGLENABLEIPROC glad_glEnablei = NULL;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = NULL;
PFNGLENDQUERYPROC glad_glEndQuery = NULL;
PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = NULL;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = NULL;
PFNGLFENCESYNCPROC glad_glFenceSync = NULL;
PFNGLFINISHPROC glad_glFinish = NULL;
PFNGLFLUSHPROC glad_glFlush = NULL;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = NULL;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange = NULL;
PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri = NULL;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = NULL;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = NULL;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = NULL;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = NULL;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = NULL;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = NULL;
PFNGLFRONTFACEPROC glad_glFrontFace = NULL;
PFNGLGENBUFFERSPROC glad_glGenBuffers = NULL;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = NULL;
PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines = NULL;
PFNGLGENQUERIESPROC glad_glGenQueries = NULL;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = NULL;
PFNGLGENSAMPLERSPROC glad_glGenSamplers = NULL;
PFNGLGENTEXTURESPROC glad_glGenTextures = NULL;
PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = NULL;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = NULL;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = NULL;
PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = NULL;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = NULL;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = NULL;
PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = NULL;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = NULL;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = NULL;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = NULL;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = NULL;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = NULL;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = NULL;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = NULL;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = NULL;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv = NULL;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = NULL;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = NULL;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = NULL;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = NULL;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = NULL;
PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage = NULL;
PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage = NULL;
PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog = NULL;
PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v = NULL;
PFNGLGETDOUBLEVPROC glad_glGetDoublev = NULL;
PFNGLGETERRORPROC glad_glGetError = NULL;
PFNGLGETFLOATI_VPROC glad_glGetFloati_v = NULL;
PFNGLGETFLOATVPROC glad_glGetFloatv = NULL;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = NULL;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = NULL;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = NULL;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv = NULL;
PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus = NULL;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = NULL;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v = NULL;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = NULL;
PFNGLGETINTEGERVPROC glad_glGetIntegerv = NULL;
PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v = NULL;
PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ = NULL;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = NULL;
PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v = NULL;
PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv = NULL;
PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv = NULL;
PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData = NULL;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv = NULL;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv = NULL;
PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel = NULL;
PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel = NULL;
PFNGLGETPOINTERVPROC glad_glGetPointerv = NULL;
PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary = NULL;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = NULL;
PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv = NULL;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog = NULL;
PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv = NULL;
PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex = NULL;
PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName = NULL;
PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv = NULL;
PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = NULL;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = NULL;
PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v = NULL;
PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv = NULL;
PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v = NULL;
PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv = NULL;
PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = NULL;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = NULL;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = NULL;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = NULL;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = NULL;
PFNGLGETQUERYIVPROC glad_glGetQueryiv = NULL;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = NULL;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = NULL;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = NULL;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = NULL;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = NULL;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = NULL;
PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat = NULL;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = NULL;
PFNGLGETSHADERIVPROC glad_glGetShaderiv = NULL;
PFNGLGETSTRINGPROC glad_glGetString = NULL;
PFNGLGETSTRINGIPROC glad_glGetStringi = NULL;
PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = NULL;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = NULL;
PFNGLGETSYNCIVPROC glad_glGetSynciv = NULL;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage = NULL;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = NULL;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = NULL;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = NULL;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = NULL;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = NULL;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = NULL;
PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage = NULL;
PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv = NULL;
PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv = NULL;
PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv = NULL;
PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv = NULL;
PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv = NULL;
PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv = NULL;
PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = NULL;
PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v = NULL;
PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v = NULL;
PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv = NULL;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = NULL;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = NULL;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = NULL;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = NULL;
PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = NULL;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = NULL;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = NULL;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = NULL;
PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv = NULL;
PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv = NULL;
PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv = NULL;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = NULL;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = NULL;
PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv = NULL;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = NULL;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = NULL;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = NULL;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = NULL;
PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage = NULL;
PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage = NULL;
PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv = NULL;
PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv = NULL;
PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv = NULL;
PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv = NULL;
PFNGLHINTPROC glad_glHint = NULL;
PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData = NULL;
PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData = NULL;
PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData = NULL;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer = NULL;
PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage = NULL;
PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage = NULL;
PFNGLISBUFFERPROC glad_glIsBuffer = NULL;
PFNGLISENABLEDPROC glad_glIsEnabled = NULL;
PFNGLISENABLEDIPROC glad_glIsEnabledi = NULL;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = NULL;
PFNGLISPROGRAMPROC glad_glIsProgram = NULL;
PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline = NULL;
PFNGLISQUERYPROC glad_glIsQuery = NULL;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = NULL;
PFNGLISSAMPLERPROC glad_glIsSampler = NULL;
PFNGLISSHADERPROC glad_glIsShader = NULL;
PFNGLISSYNCPROC glad_glIsSync = NULL;
PFNGLISTEXTUREPROC glad_glIsTexture = NULL;
PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = NULL;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = NULL;
PFNGLLINEWIDTHPROC glad_glLineWidth = NULL;
PFNGLLINKPROGRAMPROC glad_glLinkProgram = NULL;
PFNGLLOGICOPPROC glad_glLogicOp = NULL;
PFNGLMAPBUFFERPROC glad_glMapBuffer = NULL;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = NULL;
PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer = NULL;
PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange = NULL;
PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier = NULL;
PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion = NULL;
PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = NULL;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount = NULL;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = NULL;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount = NULL;
PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData = NULL;
PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage = NULL;
PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers = NULL;
PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri = NULL;
PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample = NULL;
PFNGLOBJECTLABELPROC glad_glObjectLabel = NULL;
PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel = NULL;
PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = NULL;
PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = NULL;
PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = NULL;
PFNGLPIXELSTOREFPROC glad_glPixelStoref = NULL;
PFNGLPIXELSTOREIPROC glad_glPixelStorei = NULL;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = NULL;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = NULL;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = NULL;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = NULL;
PFNGLPOINTSIZEPROC glad_glPointSize = NULL;
PFNGLPOLYGONMODEPROC glad_glPolygonMode = NULL;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = NULL;
PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp = NULL;
PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup = NULL;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = NULL;
PFNGLPROGRAMBINARYPROC glad_glProgramBinary = NULL;
PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri = NULL;
PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d = NULL;
PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv = NULL;
PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f = NULL;
PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv = NULL;
PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i = NULL;
PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv = NULL;
PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui = NULL;
PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv = NULL;
PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d = NULL;
PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv = NULL;
PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f = NULL;
PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv = NULL;
PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i = NULL;
PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv = NULL;
PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui = NULL;
PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv = NULL;
PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d = NULL;
PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv = NULL;
PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f = NULL;
PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv = NULL;
PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i = NULL;
PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv = NULL;
PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui = NULL;
PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv = NULL;
PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d = NULL;
PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv = NULL;
PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f = NULL;
PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv = NULL;
PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i = NULL;
PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv = NULL;
PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui = NULL;
PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv = NULL;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = NULL;
PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup = NULL;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter = NULL;
PFNGLREADBUFFERPROC glad_glReadBuffer = NULL;
PFNGLREADPIXELSPROC glad_glReadPixels = NULL;
PFNGLREADNPIXELSPROC glad_glReadnPixels = NULL;
PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler = NULL;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = NULL;
PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = NULL;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = NULL;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski = NULL;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = NULL;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = NULL;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = NULL;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = NULL;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = NULL;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = NULL;
PFNGLSCISSORPROC glad_glScissor = NULL;
PFNGLSCISSORARRAYVPROC glad_glScissorArrayv = NULL;
PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed = NULL;
PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv = NULL;
PFNGLSHADERBINARYPROC glad_glShaderBinary = NULL;
PFNGLSHADERSOURCEPROC glad_glShaderSource = NULL;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding = NULL;
PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader = NULL;
PFNGLSTENCILFUNCPROC glad_glStencilFunc = NULL;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = NULL;
PFNGLSTENCILMASKPROC glad_glStencilMask = NULL;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = NULL;
PFNGLSTENCILOPPROC glad_glStencilOp = NULL;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = NULL;
PFNGLTEXBUFFERPROC glad_glTexBuffer = NULL;
PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange = NULL;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D = NULL;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D = NULL;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = NULL;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D = NULL;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = NULL;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = NULL;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = NULL;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf = NULL;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = NULL;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri = NULL;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = NULL;
PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D = NULL;
PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D = NULL;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample = NULL;
PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D = NULL;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample = NULL;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = NULL;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = NULL;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = NULL;
PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier = NULL;
PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer = NULL;
PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange = NULL;
PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv = NULL;
PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv = NULL;
PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf = NULL;
PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv = NULL;
PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri = NULL;
PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv = NULL;
PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D = NULL;
PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D = NULL;
PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample = NULL;
PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D = NULL;
PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample = NULL;
PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D = NULL;
PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D = NULL;
PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D = NULL;
PFNGLTEXTUREVIEWPROC glad_glTextureView = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = NULL;
PFNGLUNIFORM1DPROC glad_glUniform1d = NULL;
PFNGLUNIFORM1DVPROC glad_glUniform1dv = NULL;
PFNGLUNIFORM1FPROC glad_glUniform1f = NULL;
PFNGLUNIFORM1FVPROC glad_glUniform1fv = NULL;
PFNGLUNIFORM1IPROC glad_glUniform1i = NULL;
PFNGLUNIFORM1IVPROC glad_glUniform1iv = NULL;
PFNGLUNIFORM1UIPROC glad_glUniform1ui = NULL;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = NULL;
PFNGLUNIFORM2DPROC glad_glUniform2d = NULL;
PFNGLUNIFORM2DVPROC glad_glUniform2dv = NULL;
PFNGLUNIFORM2FPROC glad_glUniform2f = NULL;
PFNGLUNIFORM2FVPROC glad_glUniform2fv = NULL;
PFNGLUNIFORM2IPROC glad_glUniform2i = NULL;
PFNGLUNIFORM2IVPROC glad_glUniform2iv = NULL;
PFNGLUNIFORM2UIPROC glad_glUniform2ui = NULL;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = NULL;
PFNGLUNIFORM3DPROC glad_glUniform3d = NULL;
PFNGLUNIFORM3DVPROC glad_glUniform3dv = NULL;
PFNGLUNIFORM3FPROC glad_glUniform3f = NULL;
PFNGLUNIFORM3FVPROC glad_glUniform3fv = NULL;
PFNGLUNIFORM3IPROC glad_glUniform3i = NULL;
PFNGLUNIFORM3IVPROC glad_glUniform3iv = NULL;
PFNGLUNIFORM3UIPROC glad_glUniform3ui = NULL;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = NULL;
PFNGLUNIFORM4DPROC glad_glUniform4d = NULL;
PFNGLUNIFORM4DVPROC glad_glUniform4dv = NULL;
PFNGLUNIFORM4FPROC glad_glUniform4f = NULL;
PFNGLUNIFORM4FVPROC glad_glUniform4fv = NULL;
PFNGLUNIFORM4IPROC glad_glUniform4i = NULL;
PFNGLUNIFORM4IVPROC glad_glUniform4iv = NULL;
PFNGLUNIFORM4UIPROC glad_glUniform4ui = NULL;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = NULL;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = NULL;
PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = NULL;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = NULL;
PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = NULL;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = NULL;
PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = NULL;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = NULL;
PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = NULL;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = NULL;
PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = NULL;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = NULL;
PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = NULL;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = NULL;
PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = NULL;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = NULL;
PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = NULL;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = NULL;
PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = NULL;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = NULL;
PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = NULL;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = NULL;
PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer = NULL;
PFNGLUSEPROGRAMPROC glad_glUseProgram = NULL;
PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages = NULL;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = NULL;
PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline = NULL;
PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding = NULL;
PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat = NULL;
PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat = NULL;
PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat = NULL;
PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor = NULL;
PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers = NULL;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = NULL;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = NULL;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = NULL;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = NULL;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = NULL;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = NULL;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = NULL;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = NULL;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = NULL;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = NULL;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = NULL;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = NULL;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = NULL;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = NULL;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = NULL;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = NULL;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = NULL;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = NULL;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = NULL;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = NULL;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = NULL;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = NULL;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = NULL;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = NULL;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = NULL;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = NULL;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = NULL;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = NULL;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = NULL;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = NULL;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = NULL;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = NULL;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = NULL;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = NULL;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = NULL;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = NULL;
PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding = NULL;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = NULL;
PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat = NULL;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = NULL;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = NULL;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = NULL;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = NULL;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = NULL;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = NULL;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = NULL;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = NULL;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = NULL;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = NULL;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = NULL;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = NULL;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = NULL;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = NULL;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = NULL;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = NULL;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = NULL;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = NULL;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = NULL;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = NULL;
PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat = NULL;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = NULL;
PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d = NULL;
PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv = NULL;
PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d = NULL;
PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv = NULL;
PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d = NULL;
PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv = NULL;
PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d = NULL;
PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv = NULL;
PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat = NULL;
PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer = NULL;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = NULL;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = NULL;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = NULL;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = NULL;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = NULL;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = NULL;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = NULL;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = NULL;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = NULL;
PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor = NULL;
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
PFNGLWAITSYNCPROC glad_glWaitSync = NULL;


static void glad_gl_load_GL_VERSION_1_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_0) return;
    glad_glBlendFunc = (PFNGLBLENDFUNCPROC) load(userptr, "glBlendFunc");
    glad_glClear = (PFNGLCLEARPROC) load(userptr, "glClear");
    glad_glClearColor = (PFNGLCLEARCOLORPROC) load(userptr, "glClearColor");
    glad_glClearDepth = (PFNGLCLEARDEPTHPROC) load(userptr, "glClearDepth");
    glad_glClearStencil = (PFNGLCLEARSTENCILPROC) load(userptr, "glClearStencil");
    glad_glColorMask = (PFNGLCOLORMASKPROC) load(userptr, "glColorMask");
    glad_glCullFace = (PFNGLCULLFACEPROC) load(userptr, "glCullFace");
    glad_glDepthFunc = (PFNGLDEPTHFUNCPROC) load(userptr, "glDepthFunc");
    glad_glDepthMask = (PFNGLDEPTHMASKPROC) load(userptr, "glDepthMask");
    glad_glDepthRange = (PFNGLDEPTHRANGEPROC) load(userptr, "glDepthRange");
    glad_glDisable = (PFNGLDISABLEPROC) load(userptr, "glDisable");
    glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC) load(userptr, "glDrawBuffer");
    glad_glEnable = (PFNGLENABLEPROC) load(userptr, "glEnable");
    glad_glFinish = (PFNGLFINISHPROC) load(userptr, "glFinish");
    glad_glFlush = (PFNGLFLUSHPROC) load(userptr, "glFlush");
    glad_glFrontFace = (PFNGLFRONTFACEPROC) load(userptr, "glFrontFace");
    glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC) load(userptr, "glGetBooleanv");
    glad_glGetDoublev = (PFNGLGETDOUBLEVPROC) load(userptr, "glGetDoublev");
    glad_glGetError = (PFNGLGETERRORPROC) load(userptr, "glGetError");
    glad_glGetFloatv = (PFNGLGETFLOATVPROC) load(userptr, "glGetFloatv");
    glad_glGetIntegerv = (PFNGLGETINTEGERVPROC) load(userptr, "glGetIntegerv");
    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
    glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC) load(userptr, "glGetTexImage");
    glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC) load(userptr, "glGetTexLevelParameterfv");
    glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC) load(userptr, "glGetTexLevelParameteriv");
    glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC) load(userptr, "glGetTexParameterfv");
    glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC) load(userptr, "glGetTexParameteriv");
    glad_glHint = (PFNGLHINTPROC) load(userptr, "glHint");
    glad_glIsEnabled = (PFNGLISENABLEDPROC) load(userptr, "glIsEnabled");
    glad_glLineWidth = (PFNGLLINEWIDTHPROC) load(userptr, "glLineWidth");
    glad_glLogicOp = (PFNGLLOGICOPPROC) load(userptr, "glLogicOp");
    glad_glPixelStoref = (PFNGLPIXELSTOREFPROC) load(userptr, "glPixelStoref");
    glad_glPixelStorei = (PFNGLPIXELSTOREIPROC) load(userptr, "glPixelStorei");
    glad_glPointSize = (PFNGLPOINTSIZEPROC) load(userptr, "glPointSize");
    glad_glPolygonMode = (PFNGLPOLYGONMODEPROC) load(userptr, "glPolygonMode");
    glad_glReadBuffer = (PFNGLREADBUFFERPROC) load(userptr, "glReadBuffer");
    glad_glReadPixels = (PFNGLREADPIXELSPROC) load(userptr, "glReadPixels");
    glad_glScissor = (PFNGLSCISSORPROC) load(userptr, "glScissor");
    glad_glStencilFunc = (PFNGLSTENCILFUNCPROC) load(userptr, "glStencilFunc");
    glad_glStencilMask = (PFNGLSTENCILMASKPROC) load(userptr, "glStencilMask");
    glad_glStencilOp = (PFNGLSTENCILOPPROC) load(userptr, "glStencilOp");
    glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC) load(userptr, "glTexImage1D");
    glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC) load(userptr, "glTexImage2D");
    glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC) load(userptr, "glTexParameterf");
    glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC) load(userptr, "glTexParameterfv");
    glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC) load(userptr, "glTexParameteri");
    glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC) load(userptr, "glTexParameteriv");
    glad_glViewport = (PFNGLVIEWPORTPROC) load(userptr, "glViewport");
}
static void glad_gl_load_GL_VERSION_1_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_1) return;
    glad_glBindTexture = (PFNGLBINDTEXTUREPROC) load(userptr, "glBindTexture");
    glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC) load(userptr, "glCopyTexImage1D");
    glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) load(userptr, "glCopyTexImage2D");
    glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC) load(userptr, "glCopyTexSubImage1D");
    glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) load(userptr, "glCopyTexSubImage2D");
    glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC) load(userptr, "glDeleteTextures");
    glad_glDrawArrays = (PFNGLDRAWARRAYSPROC) load(userptr, "glDrawArrays");
    glad_glDrawElements = (PFNGLDRAWELEMENTSPROC) load(userptr, "glDrawElements");
    glad_glGenTextures = (PFNGLGENTEXTURESPROC) load(userptr, "glGenTextures");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glIsTexture = (PFNGLISTEXTUREPROC) load(userptr, "glIsTexture");
    glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC) load(userptr, "glPolygonOffset");
    glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC) load(userptr, "glTexSubImage1D");
    glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) load(userptr, "glTexSubImage2D");
}
static void glad_gl_load_GL_VERSION_1_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_2) return;
    glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) load(userptr, "glCopyTexSubImage3D");
    glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) load(userptr, "glDrawRangeElements");
    glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC) load(userptr, "glTexImage3D");
    glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) load(userptr, "glTexSubImage3D");
}
static void glad_gl_load_GL_VERSION_1_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_3) return;
    glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC) load(userptr, "glActiveTexture");
    glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC) load(userptr, "glCompressedTexImage1D");
    glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) load(userptr, "glCompressedTexImage2D");
    glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) load(userptr, "glCompressedTexImage3D");
    glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) load(userptr, "glCompressedTexSubImage1D");
    glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) load(userptr, "glCompressedTexSubImage2D");
    glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) load(userptr, "glCompressedTexSubImage3D");
    glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetCompressedTexImage");
    glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) load(userptr, "glSampleCoverage");
}
static void glad_gl_load_GL_VERSION_1_4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_4) return;
    glad_glBlendColor = (PFNGLBLENDCOLORPROC) load(userptr, "glBlendColor");
    glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC) load(userptr, "glBlendEquation");
    glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) load(userptr, "glBlendFuncSeparate");
    glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC) load(userptr, "glMultiDrawArrays");
    glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC) load(userptr, "glMultiDrawElements");
    glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) load(userptr, "glPointParameterf");
    glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) load(userptr, "glPointParameterfv");
    glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC) load(userptr, "glPointParameteri");
    glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC) load(userptr, "glPointParameteriv");
}
static void glad_gl_load_GL_VERSION_1_5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_5) return;
    glad_glBeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, "glBeginQuery");
    glad_glBindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, "glBindBuffer");
    glad_glBufferData = (PFNGLBUFFERDATAPROC) load(userptr, "glBufferData");
    glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, "glBufferSubData");
    glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, "glDeleteBuffers");
    glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, "glDeleteQueries");
    glad_glEndQuery = (PFNGLENDQUERYPROC) load(userptr, "glEndQuery");
    glad_glGenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, "glGenBuffers");
    glad_glGenQueries = (PFNGLGENQUERIESPROC) load(userptr, "glGenQueries");
    glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, "glGetBufferParameteriv");
    glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, "glGetBufferPointerv");
    glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, "glGetBufferSubData");
    glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, "glGetQueryObjectiv");
    glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, "glGetQueryObjectuiv");
    glad_glGetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, "glGetQueryiv");
    glad_glIsBuffer = (PFNGLISBUFFERPROC) load(userptr, "glIsBuffer");
    glad_glIsQuery = (PFNGLISQUERYPROC) load(userptr, "glIsQuery");
    glad_glMapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, "glMapBuffer");
    glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, "glUnmapBuffer");
}
static void glad_gl_load_GL_VERSION_2_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_2_0) return;
    glad_glAttachShader = (PFNGLATTACHSHADERPROC) load(userptr, "glAttachShader");
    glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) load(userptr, "glBindAttribLocation");
    glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) load(userptr, "glBlendEquationSeparate");
    glad_glCompileShader = (PFNGLCOMPILESHADERPROC) load(userptr, "glCompileShader");
    glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC) load(userptr, "glCreateProgram");
    glad_glCreateShader = (PFNGLCREATESHADERPROC) load(userptr, "glCreateShader");
    glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC) load(userptr, "glDeleteProgram");
    glad_glDeleteShader = (PFNGLDELETESHADERPROC) load(userptr, "glDeleteShader");
    glad_glDetachShader = (PFNGLDETACHSHADERPROC) load(userptr, "glDetachShader");
    glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) load(userptr, "glDisableVertexAttribArray");
    glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) load(userptr, "glDrawBuffers");
    glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) load(userptr, "glEnableVertexAttribArray");
    glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) load(userptr, "glGetActiveAttrib");
    glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) load(userptr, "glGetActiveUniform");
    glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC) load(userptr, "glGetAttachedShaders");
    glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) load(userptr, "glGetAttribLocation");
    glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) load(userptr, "glGetProgramInfoLog");
    glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC) load(userptr, "glGetProgramiv");
    glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) load(userptr, "glGetShaderInfoLog");
    glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) load(userptr, "glGetShaderSource");
    glad_glGetShaderiv = (PFNGLGETSHADERIVPROC) load(userptr, "glGetShaderiv");
    glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) load(userptr, "glGetUniformLocation");
    glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) load(userptr, "glGetUniformfv");
    glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) load(userptr, "glGetUniformiv");
    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
    glad_glIsProgram = (PFNGLISPROGRAMPROC) load(userptr, "glIsProgram");
    glad_glIsShader = (PFNGLISSHADERPROC) load(userptr, "glIsShader");
    glad_glLinkProgram = (PFNGLLINKPROGRAMPROC) load(userptr, "glLinkProgram");
    glad_glShaderSource = (PFNGLSHADERSOURCEPROC) load(userptr, "glShaderSource");
    glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC) load(userptr, "glStencilFuncSeparate");
    glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC) load(userptr, "glStencilMaskSeparate");
    glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) load(userptr, "glStencilOpSeparate");
    glad_glUniform1f = (PFNGLUNIFORM1FPROC) load(userptr, "glUniform1f");
    glad_glUniform1fv = (PFNGLUNIFORM1FVPROC) load(userptr, "glUniform1fv");
    glad_glUniform1i = (PFNGLUNIFORM1IPROC) load(userptr, "glUniform1i");
    glad_glUniform1iv = (PFNGLUNIFORM1IVPROC) load(userptr, "glUniform1iv");
    glad_glUniform2f = (PFNGLUNIFORM2FPROC) load(userptr, "glUniform2f");
    glad_glUniform2fv = (PFNGLUNIFORM2FVPROC) load(userptr, "glUniform2fv");
    glad_glUniform2i = (PFNGLUNIFORM2IPROC) load(userptr, "glUniform2i");
    glad_glUniform2iv = (PFNGLUNIFORM2IVPROC) load(userptr, "glUniform2iv");
    glad_glUniform3f = (PFNGLUNIFORM3FPROC) load(userptr, "glUniform3f");
    glad_glUniform3fv = (PFNGLUNIFORM3FVPROC) load(userptr, "glUniform3fv");
    glad_glUniform3i = (PFNGLUNIFORM3IPROC) load(userptr, "glUniform3i");
    glad_glUniform3iv = (PFNGLUNIFORM3IVPROC) load(userptr, "glUniform3iv");
    glad_glUniform4f = (PFNGLUNIFORM4FPROC) load(userptr, "glUniform4f");
    glad_glUniform4fv = (PFNGLUNIFORM4FVPROC) load(userptr, "glUniform4fv");
    glad_glUniform4i = (PFNGLUNIFORM4IPROC) load(userptr, "glUniform4i");
    glad_glUniform4iv = (PFNGLUNIFORM4IVPROC) load(userptr, "glUniform4iv");
    glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) load(userptr, "glUniformMatrix2fv");
    glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) load(userptr, "glUniformMatrix3fv");
    glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) load(userptr, "glUniformMatrix4fv");
    glad_glUseProgram = (PFNGLUSEPROGRAMPROC) load(userptr, "glUseProgram");
    glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) load(userptr, "glValidateProgram");
    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
    glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) load(userptr, "glVertexAttrib4Nbv");
    glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) load(userptr, "glVertexAttrib4Niv");
    glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) load(userptr, "glVertexAttrib4Nsv");
    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
    glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) load(userptr, "glVertexAttrib4Nuiv");
    glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) load(userptr, "glVertexAttrib4Nusv");
    glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) load(userptr, "glVertexAttrib4bv");
    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
    glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) load(userptr, "glVertexAttrib4iv");
    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
    glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) load(userptr, "glVertexAttrib4ubv");
    glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) load(userptr, "glVertexAttrib4uiv");
    glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) load(userptr, "glVertexAttrib4usv");
    glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) load(userptr, "glVertexAttribPointer");
}
static void glad_gl_load_GL_VERSION_2_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_2_1) return;
    glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC) load(userptr, "glUniformMatrix2x3fv");
    glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC) load(userptr, "glUniformMatrix2x4fv");
    glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC) load(userptr, "glUniformMatrix3x2fv");
    glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC) load(userptr, "glUniformMatrix3x4fv");
    glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC) load(userptr, "glUniformMatrix4x2fv");
    glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC) load(userptr, "glUniformMatrix4x3fv");
}
static void glad_gl_load_GL_VERSION_3_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_0) return;
    glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC) load(userptr, "glBeginConditionalRender");
    glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) load(userptr, "glBeginTransformFeedback");
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC) load(userptr, "glBindFragDataLocation");
    glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) load(userptr, "glBindFramebuffer");
    glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) load(userptr, "glBindRenderbuffer");
    glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) load(userptr, "glBindVertexArray");
    glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) load(userptr, "glBlitFramebuffer");
    glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckFramebufferStatus");
    glad_glClampColor = (PFNGLCLAMPCOLORPROC) load(userptr, "glClampColor");
    glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC) load(userptr, "glClearBufferfi");
    glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC) load(userptr, "glClearBufferfv");
    glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC) load(userptr, "glClearBufferiv");
    glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC) load(userptr, "glClearBufferuiv");
    glad_glColorMaski = (PFNGLCOLORMASKIPROC) load(userptr, "glColorMaski");
    glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) load(userptr, "glDeleteFramebuffers");
    glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) load(userptr, "glDeleteRenderbuffers");
    glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) load(userptr, "glDeleteVertexArrays");
    glad_glDisablei = (PFNGLDISABLEIPROC) load(userptr, "glDisablei");
    glad_glEnablei = (PFNGLENABLEIPROC) load(userptr, "glEnablei");
    glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) load(userptr, "glEndConditionalRender");
    glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) load(userptr, "glEndTransformFeedback");
    glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) load(userptr, "glFlushMappedBufferRange");
    glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glFramebufferRenderbuffer");
    glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) load(userptr, "glFramebufferTexture1D");
    glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) load(userptr, "glFramebufferTexture2D");
    glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) load(userptr, "glFramebufferTexture3D");
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) load(userptr, "glGenFramebuffers");
    glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) load(userptr, "glGenRenderbuffers");
    glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) load(userptr, "glGenVertexArrays");
    glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) load(userptr, "glGenerateMipmap");
    glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) load(userptr, "glGetBooleani_v");
    glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) load(userptr, "glGetFragDataLocation");
    glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetFramebufferAttachmentParameteriv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetRenderbufferParameteriv");
    glad_glGetStringi = (PFNGLGETSTRINGIPROC) load(userptr, "glGetStringi");
    glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) load(userptr, "glGetTexParameterIiv");
    glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) load(userptr, "glGetTexParameterIuiv");
    glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) load(userptr, "glGetTransformFeedbackVarying");
    glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) load(userptr, "glGetUniformuiv");
    glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) load(userptr, "glGetVertexAttribIiv");
    glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) load(userptr, "glGetVertexAttribIuiv");
    glad_glIsEnabledi = (PFNGLISENABLEDIPROC) load(userptr, "glIsEnabledi");
    glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) load(userptr, "glIsFramebuffer");
    glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) load(userptr, "glIsRenderbuffer");
    glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) load(userptr, "glIsVertexArray");
    glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) load(userptr, "glMapBufferRange");
    glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) load(userptr, "glRenderbufferStorage");
    glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glRenderbufferStorageMultisample");
    glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) load(userptr, "glTexParameterIiv");
    glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) load(userptr, "glTexParameterIuiv");
    glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) load(userptr, "glTransformFeedbackVaryings");
    glad_glUniform1ui = (PFNGLUNIFORM1UIPROC) load(userptr, "glUniform1ui");
    glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) load(userptr, "glUniform1uiv");
    glad_glUniform2ui = (PFNGLUNIFORM2UIPROC) load(userptr, "glUniform2ui");
    glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) load(userptr, "glUniform2uiv");
    glad_glUniform3ui = (PFNGLUNIFORM3UIPROC) load(userptr, "glUniform3ui");
    glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) load(userptr, "glUniform3uiv");
    glad_glUniform4ui = (PFNGLUNIFORM4UIPROC) load(userptr, "glUniform4ui");
    glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) load(userptr, "glUniform4uiv");
    glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC) load(userptr, "glVertexAttribI1i");
    glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC) load(userptr, "glVertexAttribI1iv");
    glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC) load(userptr, "glVertexAttribI1ui");
    glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC) load(userptr, "glVertexAttribI1uiv");
    glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC) load(userptr, "glVertexAttribI2i");
    glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC) load(userptr, "glVertexAttribI2iv");
    glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC) load(userptr, "glVertexAttribI2ui");
    glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC) load(userptr, "glVertexAttribI2uiv");
    glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC) load(userptr, "glVertexAttribI3i");
    glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC) load(userptr, "glVertexAttribI3iv");
    glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC) load(userptr, "glVertexAttribI3ui");
    glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC) load(userptr, "glVertexAttribI3uiv");
    glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC) load(userptr, "glVertexAttribI4bv");
    glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) load(userptr, "glVertexAttribI4i");
    glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) load(userptr, "glVertexAttribI4iv");
    glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC) load(userptr, "glVertexAttribI4sv");
    glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC) load(userptr, "glVertexAttribI4ubv");
    glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) load(userptr, "glVertexAttribI4ui");
    glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) load(userptr, "glVertexAttribI4uiv");
    glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC) load(userptr, "glVertexAttribI4usv");
    glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) load(userptr, "glVertexAttribIPointer");
}
static void glad_gl_load_GL_VERSION_3_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_1) return;
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, "glCopyBufferSubData");
    glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, "glDrawArraysInstanced");
    glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, "glDrawElementsInstanced");
    glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, "glGetActiveUniformBlockName");
    glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, "glGetActiveUniformBlockiv");
    glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, "glGetActiveUniformName");
    glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, "glGetActiveUniformsiv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, "glGetUniformBlockIndex");
    glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, "glGetUniformIndices");
    glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) load(userptr, "glPrimitiveRestartIndex");
    glad_glTexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, "glTexBuffer");
    glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, "glUniformBlockBinding");
}
static void glad_gl_load_GL_VERSION_3_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_2) return;
    glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, "glClientWaitSync");
    glad_glDeleteSync = (PFNGLDELETESYNCPROC) load(userptr, "glDeleteSync");
    glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glDrawElementsBaseVertex");
    glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, "glDrawElementsInstancedBaseVertex");
    glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, "glDrawRangeElementsBaseVertex");
    glad_glFenceSync = (PFNGLFENCESYNCPROC) load(userptr, "glFenceSync");
    glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, "glFramebufferTexture");
    glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) load(userptr, "glGetBufferParameteri64v");
    glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) load(userptr, "glGetInteger64i_v");
    glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, "glGetInteger64v");
    glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, "glGetMultisamplefv");
    glad_glGetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, "glGetSynciv");
    glad_glIsSync = (PFNGLISSYNCPROC) load(userptr, "glIsSync");
    glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glMultiDrawElementsBaseVertex");
    glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, "glProvokingVertex");
    glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, "glSampleMaski");
    glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, "glTexImage2DMultisample");
    glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, "glTexImage3DMultisample");
    glad_glWaitSync = (PFNGLWAITSYNCPROC) load(userptr, "glWaitSync");
}
static void glad_gl_load_GL_VERSION_3_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_3) return;
    glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) load(userptr, "glBindFragDataLocationIndexed");
    glad_glBindSampler = (PFNGLBINDSAMPLERPROC) load(userptr, "glBindSampler");
    glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) load(userptr, "glDeleteSamplers");
    glad_glGenSamplers = (PFNGLGENSAMPLERSPROC) load(userptr, "glGenSamplers");
    glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) load(userptr, "glGetFragDataIndex");
    glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) load(userptr, "glGetQueryObjecti64v");
    glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) load(userptr, "glGetQueryObjectui64v");
    glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) load(userptr, "glGetSamplerParameterIiv");
    glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) load(userptr, "glGetSamplerParameterIuiv");
    glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) load(userptr, "glGetSamplerParameterfv");
    glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) load(userptr, "glGetSamplerParameteriv");
    glad_glIsSampler = (PFNGLISSAMPLERPROC) load(userptr, "glIsSampler");
    glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC) load(userptr, "glQueryCounter");
    glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) load(userptr, "glSamplerParameterIiv");
    glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) load(userptr, "glSamplerParameterIuiv");
    glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) load(userptr, "glSamplerParameterf");
    glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) load(userptr, "glSamplerParameterfv");
    glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) load(userptr, "glSamplerParameteri");
    glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) load(userptr, "glSamplerParameteriv");
    glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) load(userptr, "glVertexAttribDivisor");
    glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) load(userptr, "glVertexAttribP1ui");
    glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) load(userptr, "glVertexAttribP1uiv");
    glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) load(userptr, "glVertexAttribP2ui");
    glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) load(userptr, "glVertexAttribP2uiv");
    glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) load(userptr, "glVertexAttribP3ui");
    glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) load(userptr, "glVertexAttribP3uiv");
    glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) load(userptr, "glVertexAttribP4ui");
    glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) load(userptr, "glVertexAttribP4uiv");
}
static void glad_gl_load_GL_VERSION_4_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_0) return;
    glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, "glBeginQueryIndexed");
    glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, "glBindTransformFeedback");
    glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, "glBlendEquationSeparatei");
    glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, "glBlendEquationi");
    glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, "glBlendFuncSeparatei");
    glad_glBlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, "glBlendFunci");
    glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, "glDeleteTransformFeedbacks");
    glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, "glDrawArraysIndirect");
    glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, "glDrawElementsIndirect");
    glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, "glDrawTransformFeedback");
    glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, "glDrawTransformFeedbackStream");
    glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, "glEndQueryIndexed");
    glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, "glGenTransformFeedbacks");
    glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, "glGetActiveSubroutineName");
    glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, "glGetActiveSubroutineUniformName");
    glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, "glGetActiveSubroutineUniformiv");
    glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, "glGetProgramStageiv");
    glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, "glGetQueryIndexediv");
    glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, "glGetSubroutineIndex");
    glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, "glGetSubroutineUniformLocation");
    glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, "glGetUniformSubroutineuiv");
    glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, "glGetUniformdv");
    glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, "glIsTransformFeedback");
    glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, "glMinSampleShading");
    glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, "glPatchParameterfv");
    glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, "glPatchParameteri");
    glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, "glPauseTransformFeedback");
    glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, "glResumeTransformFeedback");
    glad_glUniform1d = (PFNGLUNIFORM1DPROC) load(userptr, "glUniform1d");
    glad_glUniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, "glUniform1dv");
    glad_glUniform2d = (PFNGLUNIFORM2DPROC) load(userptr, "glUniform2d");
    glad_glUniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, "glUniform2dv");
    glad_glUniform3d = (PFNGLUNIFORM3DPROC) load(userptr, "glUniform3d");
    glad_glUniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, "glUniform3dv");
    glad_glUniform4d = (PFNGLUNIFORM4DPROC) load(userptr, "glUniform4d");
    glad_glUniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, "glUniform4dv");
    glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, "glUniformMatrix2dv");
    glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, "glUniformMatrix2x3dv");
    glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, "glUniformMatrix2x4dv");
    glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, "glUniformMatrix3dv");
    glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, "glUniformMatrix3x2dv");
    glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, "glUniformMatrix3x4dv");
    glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, "glUniformMatrix4dv");
    glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, "glUniformMatrix4x2dv");
    glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, "glUniformMatrix4x3dv");
    glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, "glUniformSubroutinesuiv");
}
static void glad_gl_load_GL_VERSION_4_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_1) return;
    glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) load(userptr, "glActiveShaderProgram");
    glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) load(userptr, "glBindProgramPipeline");
    glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC) load(userptr, "glClearDepthf");
    glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) load(userptr, "glCreateShaderProgramv");
    glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) load(userptr, "glDeleteProgramPipelines");
    glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC) load(userptr, "glDepthRangeArrayv");
    glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC) load(userptr, "glDepthRangeIndexed");
    glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC) load(userptr, "glDepthRangef");
    glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) load(userptr, "glGenProgramPipelines");
    glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) load(userptr, "glGetDoublei_v");
    glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC) load(userptr, "glGetFloati_v");
    glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) load(userptr, "glGetProgramBinary");
    glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) load(userptr, "glGetProgramPipelineInfoLog");
    glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) load(userptr, "glGetProgramPipelineiv");
    glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) load(userptr, "glGetShaderPrecisionFormat");
    glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) load(userptr, "glGetVertexAttribLdv");
    glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) load(userptr, "glIsProgramPipeline");
    glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC) load(userptr, "glProgramBinary");
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
    glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC) load(userptr, "glProgramUniform1d");
    glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC) load(userptr, "glProgramUniform1dv");
    glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) load(userptr, "glProgramUniform1f");
    glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) load(userptr, "glProgramUniform1fv");
    glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) load(userptr, "glProgramUniform1i");
    glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) load(userptr, "glProgramUniform1iv");
    glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) load(userptr, "glProgramUniform1ui");
    glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) load(userptr, "glProgramUniform1uiv");
    glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC) load(userptr, "glProgramUniform2d");
    glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC) load(userptr, "glProgramUniform2dv");
    glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) load(userptr, "glProgramUniform2f");
    glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) load(userptr, "glProgramUniform2fv");
    glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) load(userptr, "glProgramUniform2i");
    glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) load(userptr, "glProgramUniform2iv");
    glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) load(userptr, "glProgramUniform2ui");
    glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) load(userptr, "glProgramUniform2uiv");
    glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC) load(userptr, "glProgramUniform3d");
    glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC) load(userptr, "glProgramUniform3dv");
    glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) load(userptr, "glProgramUniform3f");
    glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) load(userptr, "glProgramUniform3fv");
    glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) load(userptr, "glProgramUniform3i");
    glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) load(userptr, "glProgramUniform3iv");
    glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) load(userptr, "glProgramUniform3ui");
    glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) load(userptr, "glProgramUniform3uiv");
    glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC) load(userptr, "glProgramUniform4d");
    glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC) load(userptr, "glProgramUniform4dv");
    glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) load(userptr, "glProgramUniform4f");
    glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) load(userptr, "glProgramUniform4fv");
    glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) load(userptr, "glProgramUniform4i");
    glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) load(userptr, "glProgramUniform4iv");
    glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) load(userptr, "glProgramUniform4ui");
    glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) load(userptr, "glProgramUniform4uiv");
    glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC) load(userptr, "glProgramUniformMatrix2dv");
    glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) load(userptr, "glProgramUniformMatrix2fv");
    glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) load(userptr, "glProgramUniformMatrix2x3dv");
    glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) load(userptr, "glProgramUniformMatrix2x3fv");
    glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) load(userptr, "glProgramUniformMatrix2x4dv");
    glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) load(userptr, "glProgramUniformMatrix2x4fv");
    glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC) load(userptr, "glProgramUniformMatrix3dv");
    glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) load(userptr, "glProgramUniformMatrix3fv");
    glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) load(userptr, "glProgramUniformMatrix3x2dv");
    glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) load(userptr, "glProgramUniformMatrix3x2fv");
    glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) load(userptr, "glProgramUniformMatrix3x4dv");
    glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) load(userptr, "glProgramUniformMatrix3x4fv");
    glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC) load(userptr, "glProgramUniformMatrix4dv");
    glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) load(userptr, "glProgramUniformMatrix4fv");
    glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) load(userptr, "glProgramUniformMatrix4x2dv");
    glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) load(userptr, "glProgramUniformMatrix4x2fv");
    glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) load(userptr, "glProgramUniformMatrix4x3dv");
    glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) load(userptr, "glProgramUniformMatrix4x3fv");
    glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) load(userptr, "glReleaseShaderCompiler");
    glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC) load(userptr, "glScissorArrayv");
    glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC) load(userptr, "glScissorIndexed");
    glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC) load(userptr, "glScissorIndexedv");
    glad_glShaderBinary = (PFNGLSHADERBINARYPROC) load(userptr, "glShaderBinary");
    glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) load(userptr, "glUseProgramStages");
    glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) load(userptr, "glValidateProgramPipeline");
    glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) load(userptr, "glVertexAttribL1d");
    glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) load(userptr, "glVertexAttribL1dv");
    glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) load(userptr, "glVertexAttribL2d");
    glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) load(userptr, "glVertexAttribL2dv");
    glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) load(userptr, "glVertexAttribL3d");
    glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) load(userptr, "glVertexAttribL3dv");
    glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) load(userptr, "glVertexAttribL4d");
    glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) load(userptr, "glVertexAttribL4dv");
    glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) load(userptr, "glVertexAttribLPointer");
    glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC) load(userptr, "glViewportArrayv");
    glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC) load(userptr, "glViewportIndexedf");
    glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC) load(userptr, "glViewportIndexedfv");
}
static void glad_gl_load_GL_VERSION_4_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_2) return;
    glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) load(userptr, "glBindImageTexture");
    glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawArraysInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseVertexBaseInstance");
    glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackInstanced");
    glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackStreamInstanced");
    glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) load(userptr, "glGetActiveAtomicCounterBufferiv");
    glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) load(userptr, "glGetInternalformativ");
    glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) load(userptr, "glMemoryBarrier");
    glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC) load(userptr, "glTexStorage1D");
    glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) load(userptr, "glTexStorage2D");
    glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) load(userptr, "glTexStorage3D");
}
static void glad_gl_load_GL_VERSION_4_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_3) return;
    glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) load(userptr, "glBindVertexBuffer");
    glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC) load(userptr, "glClearBufferData");
    glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC) load(userptr, "glClearBufferSubData");
    glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) load(userptr, "glCopyImageSubData");
    glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) load(userptr, "glDebugMessageCallback");
    glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) load(userptr, "glDebugMessageControl");
    glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) load(userptr, "glDebugMessageInsert");
    glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) load(userptr, "glDispatchCompute");
    glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) load(userptr, "glDispatchComputeIndirect");
    glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) load(userptr, "glFramebufferParameteri");
    glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) load(userptr, "glGetDebugMessageLog");
    glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetFramebufferParameteriv");
    glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC) load(userptr, "glGetInternalformati64v");
    glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) load(userptr, "glGetObjectLabel");
    glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) load(userptr, "glGetObjectPtrLabel");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) load(userptr, "glGetProgramInterfaceiv");
    glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) load(userptr, "glGetProgramResourceIndex");
    glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) load(userptr, "glGetProgramResourceLocation");
    glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) load(userptr, "glGetProgramResourceLocationIndex");
    glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) load(userptr, "glGetProgramResourceName");
    glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) load(userptr, "glGetProgramResourceiv");
    glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC) load(userptr, "glInvalidateBufferData");
    glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC) load(userptr, "glInvalidateBufferSubData");
    glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) load(userptr, "glInvalidateFramebuffer");
    glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) load(userptr, "glInvalidateSubFramebuffer");
    glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC) load(userptr, "glInvalidateTexImage");
    glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC) load(userptr, "glInvalidateTexSubImage");
    glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) load(userptr, "glMultiDrawArraysIndirect");
    glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) load(userptr, "glMultiDrawElementsIndirect");
    glad_glObjectLabel = (PFNGLOBJECTLABELPROC) load(userptr, "glObjectLabel");
    glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) load(userptr, "glObjectPtrLabel");
    glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) load(userptr, "glPopDebugGroup");
    glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) load(userptr, "glPushDebugGroup");
    glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC) load(userptr, "glShaderStorageBlockBinding");
    glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) load(userptr, "glTexBufferRange");
    glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) load(userptr, "glTexStorage2DMultisample");
    glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) load(userptr, "glTexStorage3DMultisample");
    glad_glTextureView = (PFNGLTEXTUREVIEWPROC) load(userptr, "glTextureView");
    glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) load(userptr, "glVertexAttribBinding");
    glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) load(userptr, "glVertexAttribFormat");
    glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) load(userptr, "glVertexAttribIFormat");
    glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC) load(userptr, "glVertexAttribLFormat");
    glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) load(userptr, "glVertexBindingDivisor");
}
static void glad_gl_load_GL_VERSION_4_4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_4) return;
    glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC) load(userptr, "glBindBuffersBase");
    glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC) load(userptr, "glBindBuffersRange");
    glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC) load(userptr, "glBindImageTextures");
    glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC) load(userptr, "glBindSamplers");
    glad_glBindTextures = (PFNGLBINDTEXTURESPROC) load(userptr, "glBindTextures");
    glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC) load(userptr, "glBindVertexBuffers");
    glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC) load(userptr, "glBufferStorage");
    glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC) load(userptr, "glClearTexImage");
    glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC) load(userptr, "glClearTexSubImage");
}
static void glad_gl_load_GL_VERSION_4_5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_5) return;
    glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC) load(userptr, "glBindTextureUnit");
    glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC) load(userptr, "glBlitNamedFramebuffer");
    glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckNamedFramebufferStatus");
    glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC) load(userptr, "glClearNamedBufferData");
    glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC) load(userptr, "glClearNamedBufferSubData");
    glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) load(userptr, "glClearNamedFramebufferfi");
    glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) load(userptr, "glClearNamedFramebufferfv");
    glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) load(userptr, "glClearNamedFramebufferiv");
    glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) load(userptr, "glClearNamedFramebufferuiv");
    glad_glClipControl = (PFNGLCLIPCONTROLPROC) load(userptr, "glClipControl");
    glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) load(userptr, "glCompressedTextureSubImage1D");
    glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) load(userptr, "glCompressedTextureSubImage2D");
    glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) load(userptr, "glCompressedTextureSubImage3D");
    glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC) load(userptr, "glCopyNamedBufferSubData");
    glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC) load(userptr, "glCopyTextureSubImage1D");
    glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC) load(userptr, "glCopyTextureSubImage2D");
    glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC) load(userptr, "glCopyTextureSubImage3D");
    glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC) load(userptr, "glCreateBuffers");
    glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC) load(userptr, "glCreateFramebuffers");
    glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC) load(userptr, "glCreateProgramPipelines");
    glad_glCreateQueries = (PFNGLCREATEQUERIESPROC) load(userptr, "glCreateQueries");
    glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC) load(userptr, "glCreateRenderbuffers");
    glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC) load(userptr, "glCreateSamplers");
    glad_glCreateTextures = (PFNGLCREATETEXTURESPROC) load(userptr, "glCreateTextures");
    glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC) load(userptr, "glCreateTransformFeedbacks");
    glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC) load(userptr, "glCreateVertexArrays");
    glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC) load(userptr, "glDisableVertexArrayAttrib");
    glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC) load(userptr, "glEnableVertexArrayAttrib");
    glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) load(userptr, "glFlushMappedNamedBufferRange");
    glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC) load(userptr, "glGenerateTextureMipmap");
    glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) load(userptr, "glGetCompressedTextureImage");
    glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) load(userptr, "glGetCompressedTextureSubImage");
    glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) load(userptr, "glGetGraphicsResetStatus");
    glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) load(userptr, "glGetNamedBufferParameteri64v");
    glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedBufferParameteriv");
    glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC) load(userptr, "glGetNamedBufferPointerv");
    glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC) load(userptr, "glGetNamedBufferSubData");
    glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferAttachmentParameteriv");
    glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferParameteriv");
    glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedRenderbufferParameteriv");
    glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC) load(userptr, "glGetQueryBufferObjecti64v");
    glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC) load(userptr, "glGetQueryBufferObjectiv");
    glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC) load(userptr, "glGetQueryBufferObjectui64v");
    glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC) load(userptr, "glGetQueryBufferObjectuiv");
    glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC) load(userptr, "glGetTextureImage");
    glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC) load(userptr, "glGetTextureLevelParameterfv");
    glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC) load(userptr, "glGetTextureLevelParameteriv");
    glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC) load(userptr, "glGetTextureParameterIiv");
    glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC) load(userptr, "glGetTextureParameterIuiv");
    glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC) load(userptr, "glGetTextureParameterfv");
    glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC) load(userptr, "glGetTextureParameteriv");
    glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC) load(userptr, "glGetTextureSubImage");
    glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC) load(userptr, "glGetTransformFeedbacki64_v");
    glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC) load(userptr, "glGetTransformFeedbacki_v");
    glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC) load(userptr, "glGetTransformFeedbackiv");
    glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC) load(userptr, "glGetVertexArrayIndexed64iv");
    glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC) load(userptr, "glGetVertexArrayIndexediv");
    glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC) load(userptr, "glGetVertexArrayiv");
    glad_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetnCompressedTexImage");
    glad_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC) load(userptr, "glGetnTexImage");
    glad_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC) load(userptr, "glGetnUniformdv");
    glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) load(userptr, "glGetnUniformfv");
    glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) load(userptr, "glGetnUniformiv");
    glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) load(userptr, "glGetnUniformuiv");
    glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) load(userptr, "glInvalidateNamedFramebufferData");
    glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) load(userptr, "glInvalidateNamedFramebufferSubData");
    glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC) load(userptr, "glMapNamedBuffer");
    glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC) load(userptr, "glMapNamedBufferRange");
    glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) load(userptr, "glMemoryBarrierByRegion");
    glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC) load(userptr, "glNamedBufferData");
    glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) load(userptr, "glNamedBufferStorage");
    glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) load(userptr, "glNamedBufferSubData");
    glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) load(userptr, "glNamedFramebufferDrawBuffer");
    glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) load(userptr, "glNamedFramebufferDrawBuffers");
    glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) load(userptr, "glNamedFramebufferParameteri");
    glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) load(userptr, "glNamedFramebufferReadBuffer");
    glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glNamedFramebufferRenderbuffer");
    glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) load(userptr, "glNamedFramebufferTexture");
    glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glNamedFramebufferTextureLayer");
    glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC) load(userptr, "glNamedRenderbufferStorage");
    glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glNamedRenderbufferStorageMultisample");
    glad_glReadnPixels = (PFNGLREADNPIXELSPROC) load(userptr, "glReadnPixels");
    glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC) load(userptr, "glTextureBarrier");
    glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC) load(userptr, "glTextureBuffer");
    glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC) load(userptr, "glTextureBufferRange");
    glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC) load(userptr, "glTextureParameterIiv");
    glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC) load(userptr, "glTextureParameterIuiv");
    glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC) load(userptr, "glTextureParameterf");
    glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC) load(userptr, "glTextureParameterfv");
    glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC) load(userptr, "glTextureParameteri");
    glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC) load(userptr, "glTextureParameteriv");
    glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC) load(userptr, "glTextureStorage1D");
    glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC) load(userptr, "glTextureStorage2D");
    glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) load(userptr, "glTextureStorage2DMultisample");
    glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC) load(userptr, "glTextureStorage3D");
    glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) load(userptr, "glTextureStorage3DMultisample");
    glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC) load(userptr, "glTextureSubImage1D");
    glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC) load(userptr, "glTextureSubImage2D");
    glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC) load(userptr, "glTextureSubImage3D");
    glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) load(userptr, "glTransformFeedbackBufferBase");
    glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) load(userptr, "glTransformFeedbackBufferRange");
    glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC) load(userptr, "glUnmapNamedBuffer");
    glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC) load(userptr, "glVertexArrayAttribBinding");
    glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC) load(userptr, "glVertexArrayAttribFormat");
    glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC) load(userptr, "glVertexArrayAttribIFormat");
    glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC) load(userptr, "glVertexArrayAttribLFormat");
    glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC) load(userptr, "glVertexArrayBindingDivisor");
    glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC) load(userptr, "glVertexArrayElementBuffer");
    glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC) load(userptr, "glVertexArrayVertexBuffer");
    glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC) load(userptr, "glVertexArrayVertexBuffers");
}
static void glad_gl_load_GL_VERSION_4_6( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_6) return;
    glad_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawArraysIndirectCount");
    glad_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawElementsIndirectCount");
    glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) load(userptr, "glPolygonOffsetClamp");
    glad_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC) load(userptr, "glSpecializeShader");
}



#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
#define GLAD_GL_IS_SOME_NEW_VERSION 1
#else
#define GLAD_GL_IS_SOME_NEW_VERSION 0
#endif

static int glad_gl_get_extensions( int version, const char **out_exts, unsigned int *out_num_exts_i, char ***out_exts_i) {
#if GLAD_GL_IS_SOME_NEW_VERSION
    if(GLAD_VERSION_MAJOR(version) < 3) {
#else
    GLAD_UNUSED(version);
    GLAD_UNUSED(out_num_exts_i);
    GLAD_UNUSED(out_exts_i);
#endif
        if (glad_glGetString == NULL) {
            return 0;
        }
        *out_exts = (const char *)glad_glGetString(GL_EXTENSIONS);
#if GLAD_GL_IS_SOME_NEW_VERSION
    } else {
        unsigned int index = 0;
        unsigned int num_exts_i = 0;
        char **exts_i = NULL;
        if (glad_glGetStringi == NULL || glad_glGetIntegerv == NULL) {
            return 0;
        }
        glad_glGetIntegerv(GL_NUM_EXTENSIONS, (int*) &num_exts_i);
        if (num_exts_i > 0) {
            exts_i = (char **) malloc(num_exts_i * (sizeof *exts_i));
        }
        if (exts_i == NULL) {
            return 0;
        }
        for(index = 0; index < num_exts_i; index++) {
            const char *gl_str_tmp = (const char*) glad_glGetStringi(GL_EXTENSIONS, index);
            size_t len = strlen(gl_str_tmp) + 1;

            char *local_str = (char*) malloc(len * sizeof(char));
            if(local_str != NULL) {
                memcpy(local_str, gl_str_tmp, len * sizeof(char));
            }

            exts_i[index] = local_str;
        }

        *out_num_exts_i = num_exts_i;
        *out_exts_i = exts_i;
    }
#endif
    return 1;
}
static void glad_gl_free_extensions(char **exts_i, unsigned int num_exts_i) {
    if (exts_i != NULL) {
        unsigned int index;
        for(index = 0; index < num_exts_i; index++) {
            free((void *) (exts_i[index]));
        }
        free((void *)exts_i);
        exts_i = NULL;
    }
}
static int glad_gl_has_extension(int version, const char *exts, unsigned int num_exts_i, char **exts_i, const char *ext) {
    if(GLAD_VERSION_MAJOR(version) < 3 || !GLAD_GL_IS_SOME_NEW_VERSION) {
        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == NULL || ext == NULL) {
            return 0;
        }
        while(1) {
            loc = strstr(extensions, ext);
            if(loc == NULL) {
                return 0;
            }
            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }
    } else {
        unsigned int index;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];
            if(strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }
    return 0;
}

static GLADapiproc glad_gl_get_proc_from_userptr(void *userptr, const char* name) {
    return (GLAD_GNUC_EXTENSION (GLADapiproc (*)(const char *name)) userptr)(name);
}

// Unable to find the docs for this function!
static int glad_gl_find_extensions_gl( int version) {
    const char *exts = NULL;
    unsigned int num_exts_i = 0;
    char **exts_i = NULL;
    if (!glad_gl_get_extensions(version, &exts, &num_exts_i, &exts_i)) return 0;

    GLAD_GL_EXT_texture_lod_bias = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_lod_bias");

    glad_gl_free_extensions(exts_i, num_exts_i);

    return 1;
}

// Unable to find the docs for this function!
static int glad_gl_find_core_gl(void) {
    int i;
    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        "OpenGL SC ",
        NULL
    };
    int major = 0;
    int minor = 0;
    version = (const char*) glad_glGetString(GL_VERSION);
    if (!version) return 0;
    for (i = 0;  prefixes[i];  i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }

    GLAD_IMPL_UTIL_SSCANF(version, "%d.%d", &major, &minor);

    GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
    GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
    GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
    GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
    GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
    GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
    GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
    GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
    GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
    GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
    GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
    GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
    GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;
    GLAD_GL_VERSION_4_1 = (major == 4 && minor >= 1) || major > 4;
    GLAD_GL_VERSION_4_2 = (major == 4 && minor >= 2) || major > 4;
    GLAD_GL_VERSION_4_3 = (major == 4 && minor >= 3) || major > 4;
    GLAD_GL_VERSION_4_4 = (major == 4 && minor >= 4) || major > 4;
    GLAD_GL_VERSION_4_5 = (major == 4 && minor >= 5) || major > 4;
    GLAD_GL_VERSION_4_6 = (major == 4 && minor >= 6) || major > 4;

    return GLAD_MAKE_VERSION(major, minor);
}

int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr) {
    int version;

    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
    if(glad_glGetString == NULL) return 0;
    if(glad_glGetString(GL_VERSION) == NULL) return 0;
    version = glad_gl_find_core_gl();

    glad_gl_load_GL_VERSION_1_0(load, userptr);
    glad_gl_load_GL_VERSION_1_1(load, userptr);
    glad_gl_load_GL_VERSION_1_2(load, userptr);
    glad_gl_load_GL_VERSION_1_3(load, userptr);
    glad_gl_load_GL_VERSION_1_4(load, userptr);
    glad_gl_load_GL_VERSION_1_5(load, userptr);
    glad_gl_load_GL_VERSION_2_0(load, userptr);
    glad_gl_load_GL_VERSION_2_1(load, userptr);
    glad_gl_load_GL_VERSION_3_0(load, userptr);
    glad_gl_load_GL_VERSION_3_1(load, userptr);
    glad_gl_load_GL_VERSION_3_2(load, userptr);
    glad_gl_load_GL_VERSION_3_3(load, userptr);
    glad_gl_load_GL_VERSION_4_0(load, userptr);
    glad_gl_load_GL_VERSION_4_1(load, userptr);
    glad_gl_load_GL_VERSION_4_2(load, userptr);
    glad_gl_load_GL_VERSION_4_3(load, userptr);
    glad_gl_load_GL_VERSION_4_4(load, userptr);
    glad_gl_load_GL_VERSION_4_5(load, userptr);
    glad_gl_load_GL_VERSION_4_6(load, userptr);

    if (!glad_gl_find_extensions_gl(version)) return 0;



    return version;
}


// Unable to find the docs for this function!
int gladLoadGL( GLADloadfunc load) {
    return gladLoadGLUserPtr( glad_gl_get_proc_from_userptr, GLAD_GNUC_EXTENSION (void*) load);
}



 

#ifdef GLAD_GL

#ifndef GLAD_LOADER_LIBRARY_C_
#define GLAD_LOADER_LIBRARY_C_

#include <stddef.h>
#include <stdlib.h>

#if GLAD_PLATFORM_WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif


static void* glad_get_dlopen_handle(const char *lib_names[], int length) {
    void *handle = NULL;
    int i;

    for (i = 0; i < length; ++i) {
#if GLAD_PLATFORM_WIN32
  #if GLAD_PLATFORM_UWP
        size_t buffer_size = (strlen(lib_names[i]) + 1) * sizeof(WCHAR);
        LPWSTR buffer = (LPWSTR) malloc(buffer_size);
        if (buffer != NULL) {
            int ret = MultiByteToWideChar(CP_ACP, 0, lib_names[i], -1, buffer, buffer_size);
            if (ret != 0) {
                handle = (void*) LoadPackagedLibrary(buffer, 0);
            }
            free((void*) buffer);
        }
  #else
        handle = (void*) LoadLibraryA(lib_names[i]);
  #endif
#else
        handle = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
#endif
        if (handle != NULL) {
            return handle;
        }
    }

    return NULL;
}

static void glad_close_dlopen_handle(void* handle) {
    if (handle != NULL) {
#if GLAD_PLATFORM_WIN32
        FreeLibrary((HMODULE) handle);
#else
        dlclose(handle);
#endif
    }
}

static GLADapiproc glad_dlsym_handle(void* handle, const char *name) {
    if (handle == NULL) {
        return NULL;
    }

#if GLAD_PLATFORM_WIN32
    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);
#else
    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);
#endif
}

#endif /* GLAD_LOADER_LIBRARY_C_ */

typedef void* (GLAD_API_PTR *GLADglprocaddrfunc)(const char*);
struct _glad_gl_userptr {
    void *handle;
    GLADglprocaddrfunc gl_get_proc_address_ptr;
};

static GLADapiproc glad_gl_get_proc(void *vuserptr, const char *name) {
    struct _glad_gl_userptr userptr = *(struct _glad_gl_userptr*) vuserptr;
    GLADapiproc result = NULL;

    if(userptr.gl_get_proc_address_ptr != NULL) {
        result = GLAD_GNUC_EXTENSION (GLADapiproc) userptr.gl_get_proc_address_ptr(name);
    }
    if(result == NULL) {
        result = glad_dlsym_handle(userptr.handle, name);
    }

    return result;
}

static void* _glad_GL_loader_handle = NULL;

static void* glad_gl_dlopen_handle(void) {
#if GLAD_PLATFORM_APPLE
    static const char *NAMES[] = {
        "../Frameworks/OpenGL.framework/OpenGL",
        "/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
    };
#elif GLAD_PLATFORM_WIN32
    static const char *NAMES[] = {"opengl32.dll"};
#else
    static const char *NAMES[] = {
  #if defined(__CYGWIN__)
        "libGL-1.so",
  #endif
        "libGL.so.1",
        "libGL.so"
    };
#endif

    if (_glad_GL_loader_handle == NULL) {
        _glad_GL_loader_handle = glad_get_dlopen_handle(NAMES, sizeof(NAMES) / sizeof(NAMES[0]));
    }

    return _glad_GL_loader_handle;
}

static struct _glad_gl_userptr glad_gl_build_userptr(void *handle) {
    struct _glad_gl_userptr userptr;

    userptr.handle = handle;
#if GLAD_PLATFORM_APPLE || defined(__HAIKU__)
    userptr.gl_get_proc_address_ptr = NULL;
#elif GLAD_PLATFORM_WIN32
    userptr.gl_get_proc_address_ptr =
        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "wglGetProcAddress");
#else
    userptr.gl_get_proc_address_ptr =
        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "glXGetProcAddressARB");
#endif

    return userptr;
}

// Unable to find the docs for this function!
int gladLoaderLoadGL(void) {
    int version = 0;
    void *handle;
    int did_load = 0;
    struct _glad_gl_userptr userptr;

    did_load = _glad_GL_loader_handle == NULL;
    handle = glad_gl_dlopen_handle();
    if (handle) {
        userptr = glad_gl_build_userptr(handle);

        version = gladLoadGLUserPtr(glad_gl_get_proc, &userptr);

        if (did_load) {
            gladLoaderUnloadGL();
        }
    }

    return version;
}



// Unable to find the docs for this function!
void gladLoaderUnloadGL(void) {
    if (_glad_GL_loader_handle != NULL) {
        glad_close_dlopen_handle(_glad_GL_loader_handle);
        _glad_GL_loader_handle = NULL;
    }
}

#endif /* GLAD_GL */

#ifdef __cplusplus
}
#endif

#endif /* GLAD_GL_IMPLEMENTATION */

